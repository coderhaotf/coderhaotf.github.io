<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux账号管理</title>
    <url>/article/2020/02/24/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<h2 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h2><h5 id="查看账号"><a href="#查看账号" class="headerlink" title="查看账号"></a>查看账号</h5><pre><code class="linux">[root@localhost ~]# head -n 4 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin</code></pre>
<ul>
<li><ol>
<li>帐号名称</li>
</ol>
</li>
<li><ol start="2">
<li>密码： 具体密码放在/etc/shadow 中了，所以这里只会看到一个“ x ”</li>
</ol>
</li>
<li><ol start="3">
<li>UID： 这个就是使用者识别码；0（系统管理员）| 1<del>999（系统帐号） | 1000</del>60000（可登陆帐号）给一般使用者用的。</li>
</ol>
</li>
<li><ol start="4">
<li>GID： 这个与 /etc/group 有关；</li>
</ol>
</li>
<li><ol start="5">
<li>使用者信息说明栏;</li>
</ol>
</li>
<li><ol start="6">
<li>主文件夹： 这是使用者的主文件夹;</li>
</ol>
</li>
<li><ol start="7">
<li>Shell： 当使用者登陆系统后就会取得一个 Shell 来与系统的核心沟通以进行使用者的操作任务。</li>
</ol>
</li>
</ul>
<h5 id="查看密码"><a href="#查看密码" class="headerlink" title="查看密码"></a>查看密码</h5><pre><code class="linux">[root@localhost ~]# head -n 4 /etc/shadow
root:$1$PVouuTVF$M9aj8PmDWwU4026X2VAAe0:18026:0:99999:7:::
bin:*:16659:0:99999:7:::
daemon:*:16659:0:99999:7:::
adm:*:16659:0:99999:7:::

// 查看上一次修改密码的日期
[root@localhost ~]# date -u -d &quot;1970-01-01 UTC $((18026 * 86400 )) seconds&quot;
Fri May 10 00:00:00 UTC 2019</code></pre>
<ul>
<li><ol>
<li>帐号名称;</li>
</ol>
</li>
<li><ol start="2">
<li>密码： 这个字段内的数据才是真正的密码，而且是经过编码的密码;</li>
</ol>
</li>
<li><ol start="3">
<li>最近更动密码的日期;</li>
</ol>
</li>
<li><ol start="4">
<li>密码不可被更动的天数；</li>
</ol>
</li>
</ul>
<h2 id="查看群组信息"><a href="#查看群组信息" class="headerlink" title="查看群组信息"></a>查看群组信息</h2><p>用户帐号相关的两个文件是 /etc/passwd 与 /etc/shadow ，与此类似，群组相关信息在 /etc/group 与 /etc/gshadow 文件中；</p>
<h5 id="查看群组"><a href="#查看群组" class="headerlink" title="查看群组"></a>查看群组</h5><pre><code class="linux">[root@localhost ~]# head -n 4 /etc/group
root:x:0:
bin:x:1:
daemon:x:2:
sys:x:3:</code></pre>
<h5 id="查看密码-1"><a href="#查看密码-1" class="headerlink" title="查看密码"></a>查看密码</h5><pre><code class="linux">[root@localhost ~]# head -n 4 /etc/gshadow
root:::
bin:::
daemon:::
sys:::</code></pre>
<ul>
<li><ol>
<li>群组名称</li>
</ol>
</li>
<li><ol start="2">
<li>密码栏，同样的，开头为 ! 表示无合法密码，所以无群组管理员</li>
</ol>
</li>
<li><ol start="3">
<li>群组管理员的帐号 （相关信息在 gpasswd 中介绍）</li>
</ol>
</li>
<li><ol start="4">
<li>有加入该群组支持的所属帐号 （与 /etc/group 内容相同！）</li>
</ol>
</li>
</ul>
<h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h5 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h5><pre><code class="linux">[root@localhost ~]# useradd user1
[root@localhost ~]# grep user1 /etc/passwd /etc/shadow /etc/group
/etc/passwd:user1:x:1001:1001::/home/user1:/bin/bash
/etc/shadow:user1:!!:18027
/etc/group:user1:x:1001:  // 默认会创建一个与帐号一模一样的群组名

[root@localhost ~]# su user1
[user1@localhost root]$ cd ~
[user1@localhost ~]$ pwd
/home/user1   // 默认在home目录下创建一个同名用户目录

// -D 查看该命令的默认配置
[root@localhost user1]# useradd -D
GROUP=100
HOME=/home  // 使用者主文件夹的基准目录（basedir）
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes</code></pre>
<h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><p>使用 useradd 创建了帐号之后，在默认的情况下，该帐号是暂时被封锁的， 也就是说，该帐号是无法登陆的，你可以去瞧一瞧 /etc/shadow 内的第二个字段就知道了（<code>/etc/shadow:user1:!!:18027</code>）。</p>
<pre><code class="linux">[root@localhost user1]# passwd --stdin user1
Changing password for user user1.
user1
passwd: all authentication tokens updated successfully.
[root@localhost user1]# grep user1 /etc/shadow
user1:$1$zQ.ACG7G$BOzh/LS6Zfa7uBIwjlV1j1:18027:0:99999:7:::</code></pre>
<p>passwd 的使用真的要很注意，要帮一般帐号创建密码需要使用“ passwd 帐号 ”的格式，使用“ passwd ”表示修改自己的密码！</p>
<h5 id="锁定账号"><a href="#锁定账号" class="headerlink" title="锁定账号"></a>锁定账号</h5><pre><code class="linux">// -l 锁定账号
[root@localhost ~]# passwd -l user1
Locking password for user user1.
passwd: Success

// -S 查看账号密码状态，需要root权限
[root@localhost ~]# passwd -S user1
user1 LK 2019-05-10 0 99999 7 -1 (Password locked.)

// 密码前面加上!!
[root@localhost ~]# grep user1 /etc/shadow
user1:!!$1$zQ.ACG7G$BOzh/LS6Zfa7uBIwjlV1j1:18027:0:99999:7:::

// -u 解锁账号
[root@localhost ~]# passwd -u user1
Unlocking password for user user1.
passwd: Success

// !! 去掉了
[root@localhost ~]# grep user1 /etc/shadow
user1:$1$zQ.ACG7G$BOzh/LS6Zfa7uBIwjlV1j1:18027:0:99999:7:::</code></pre>
<h5 id="查看密码状态"><a href="#查看密码状态" class="headerlink" title="查看密码状态"></a>查看密码状态</h5><p>上例用到了<code>passwd -S username</code>来查看密码状态，但是显然信息太过简略了，下面介绍一个新命令chage:</p>
<pre><code class="linux">[root@localhost ~]# chage -l user1
Last password change                                : May 11, 2019
Password expires                                    : never
Password inactive                                   : never
Account expires                                     : never
Minimum number of days between password change      : 0
Maximum number of days between password change      : 99999
Number of days of warning before password expires   : 7</code></pre>
<p>选项与参数：<br>    -l ：列出该帐号的详细密码参数；<br>    -d ：后面接日期，修改 shadow 第三字段（最近一次更改密码的日期），格式 YYYY-MM-DD<br>    -E ：后面接日期，修改 shadow 第八字段（帐号失效日），格式 YYYY-MM-DD<br>    -I ：后面接天数，修改 shadow 第七字段（密码失效日期）<br>    -m ：后面接天数，修改 shadow 第四字段（密码最短保留天数）<br>    -M ：后面接天数，修改 shadow 第五字段（密码多久需要进行变更）<br>    -W ：后面接天数，修改 shadow 第六字段（密码过期前警告日期）</p>
<h5 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h5><p>所谓这“人有失手，马有乱蹄”，有的时候在useradd 的时候加入了错误的设置数据。或者是，在使用 useradd 后，发现某些地方还可以进行细部修改。 此时，当然我们可以直接到 /etc/passwd 或 /etc/shadow 去修改相对应字段的数据， 或者使用命令<code>usermod</code> 。</p>
<p>值得注意的是，修改用户时需要退出相关进程：</p>
<pre><code class="linux">[root@localhost ~]# usermod -l user11 user1
usermod: user user1 is currently used by process 3060

[root@localhost ~]# pkill -9 -u user1
[root@localhost ~]# Killed
[root@localhost ~]# exit

[root@localhost ~]# usermod -l user11 user1
[root@localhost ~]# grep user /etc/passwd
user11:x:1001:1001::/home/user1:/bin/bash  // 用户名变为user11</code></pre>
<p>选项与参数：<br>    -c ：后面接帐号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些帐号的说明。<br>    -d ：后面接帐号的主文件夹，即修改 /etc/passwd 的第六栏；<br>    -e ：后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据啦！<br>    -f ：后面接天数，为 shadow 的第七字段。<br>    -g ：后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段！<br>    -G ：后面接次要群组，修改这个使用者能够支持的群组，修改的是 /etc/group 啰～<br>    -a ：与 -G 合用，可“增加次要群组的支持”而非“设置”喔！<br>    -l ：后面接帐号名称。亦即是修改帐号名称， /etc/passwd 的第一栏！<br>    -s ：后面接 Shell 的实际文件，例如 /bin/bash 或 /bin/csh 等等。<br>    -u ：后面接 UID 数字啦！即 /etc/passwd 第三栏的数据；<br>    -L ：暂时将使用者的密码冻结，让他无法登陆。其实仅改 /etc/shadow 的密码栏。<br>    -U ：将 /etc/shadow 密码栏的 ! 拿掉，解冻啦！</p>
<h5 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h5><p><code>userdel</code>指令的目的在删除使用者的相关数据，而使用者的数据有：</p>
<ul>
<li>使用者帐号/密码相关参数：/etc/passwd, /etc/shadow</li>
<li>使用者群组相关参数：/etc/group, /etc/gshadow</li>
<li>使用者个人文件数据： /home/username, /var/spool/mail/username..</li>
</ul>
<pre><code class="linux">[root@localhost ~]# userdel -r user1
[root@localhost ~]# grep user1 /etc/passwd
[root@localhost ~]# </code></pre>
<p>选项与参数：<br>-r ：连同使用者的主文件夹也一起删除</p>
<p>如果想要完整的将某个帐号完整的移除，最好可以在下达 userdel -r username 之前， 先以“ find / -user username ”查出整个系统内属于 username 的文件，然后再加以删除。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux磁盘管理</title>
    <url>/article/2020/02/24/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<h2 id="一切从“-”开始"><a href="#一切从“-”开始" class="headerlink" title="一切从“/”开始"></a>一切从“/”开始</h2><p>在Linux系统中，目录、字符设备、块设备、套接字、打印机等都被抽象成了文件，即“Linux系统中一切都是文件”。</p>
<p>在Windows操作系统中，想要找到一个文件，我们要依次进入该文件所在的磁盘分区（假设这里是D盘），然后在进入该分区下的具体目录，最终找到这个文件。但是在Linux系统中并不存在C/D/E/F等盘符，Linux系统中的一切文件都是从“根（/）”目录开始的，并按照文件系统层次化标准（FHS）采用树形结构来存放文件，以及定义了常见目录的用途。</p>
<p>根目录下输入<code>ls</code>，可以查看下面常见目录</p>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>应放置文件的内容</th>
</tr>
</thead>
<tbody><tr>
<td>/boot</td>
<td>开机所需文件—内核、开机菜单以及所需配置文件等</td>
</tr>
<tr>
<td>/dev</td>
<td>以文件形式存放任何设备与接口</td>
</tr>
<tr>
<td>/etc</td>
<td>配置文件</td>
</tr>
<tr>
<td>/home</td>
<td>用户主目录</td>
</tr>
<tr>
<td>/bin</td>
<td>存放单用户模式下还可以操作的命令</td>
</tr>
<tr>
<td>/lib</td>
<td>开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数</td>
</tr>
<tr>
<td>/sbin</td>
<td>开机过程中需要的命令</td>
</tr>
<tr>
<td>/media</td>
<td>用于挂载设备文件的目录</td>
</tr>
<tr>
<td>/opt</td>
<td>放置第三方的软件</td>
</tr>
<tr>
<td>/root</td>
<td>系统管理员的家目录</td>
</tr>
<tr>
<td>/srv</td>
<td>一些网络服务的数据文件目录</td>
</tr>
<tr>
<td>/tmp</td>
<td>任何人均可使用的“共享”临时目录</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td>
</tr>
<tr>
<td>/usr/local</td>
<td>用户自行安装的软件</td>
</tr>
<tr>
<td>/usr/sbin</td>
<td>Linux系统开机时不会使用到的软件/命令/脚本</td>
</tr>
<tr>
<td>/usr/share</td>
<td>帮助与说明文件，也可放置共享文件</td>
</tr>
<tr>
<td>/var</td>
<td>主要存放经常变化的文件，如日志</td>
</tr>
</tbody></table>
<h2 id="磁盘基础"><a href="#磁盘基础" class="headerlink" title="磁盘基础"></a>磁盘基础</h2><h5 id="磁盘命名"><a href="#磁盘命名" class="headerlink" title="磁盘命名"></a>磁盘命名</h5><p>在Linux系统中一切都是文件，硬件设备也不例外。既然是文件，就必须有文件名称。系统内核中的udev设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等。</p>
<p>常见的硬件设备及其文件名称如下：</p>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody><tr>
<td>IDE设备</td>
<td>/dev/hd[a-d]</td>
</tr>
<tr>
<td>SCSI/SATA/U盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>软驱</td>
<td>/dev/fd[0-1]</td>
</tr>
<tr>
<td>打印机</td>
<td>/dev/lp[0-15]</td>
</tr>
<tr>
<td>光驱</td>
<td>/dev/cdrom</td>
</tr>
<tr>
<td>鼠标</td>
<td>/dev/mouse</td>
</tr>
</tbody></table>
<p>系统采用a～p来代表16块不同的硬盘（默认从a开始分配），而且硬盘的分区编号也很有讲究：</p>
<blockquote>
<p>主分区或扩展分区的编号从1开始，到4结束；<br>逻辑分区从编号5开始。</p>
</blockquote>
<h5 id="主分区、扩展分区、逻辑分区"><a href="#主分区、扩展分区、逻辑分区" class="headerlink" title="主分区、扩展分区、逻辑分区"></a>主分区、扩展分区、逻辑分区</h5><p>给一块磁盘分区时，我们可以选择MBR（Master Boot Record）磁盘分区模式（还有一种更先进的GPT模式）进行分区。</p>
<p><strong>==<em>在MBR模式下，主分区与扩展分区之和++最多是 4++ 个，且扩展分区最多++只能有 1++ 个。在扩展分区上面，可以创建 ++n 个++逻辑分区。</em>==</strong></p>
<h6 id="主分区跟扩展分区为什么最多是四个呢？"><a href="#主分区跟扩展分区为什么最多是四个呢？" class="headerlink" title="主分区跟扩展分区为什么最多是四个呢？"></a>主分区跟扩展分区为什么最多是四个呢？</h6><ul>
<li><p>首先，硬盘设备是由大量的扇区组成的，每个扇区的容量为512字节。</p>
</li>
<li><p>其次，MBR的意思是：主引导记录（Master Boot Record），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的<strong>==首个扇区==</strong>，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。</p>
</li>
<li><p>接着，主引导扇区的内部结构，其开头的446字节内容特指为“主引导记录”（MBR），其后是4个16字节的“磁盘分区表”（DPT），以及2字节的结束标志（55AA）。</p>
</li>
<li><p>最后，分区表中每记录一个分区的引用信息就需要16字节，这样一来最多只有4个分区信息可以写到第一个扇区中，这4个分区就是4个主分区。</p>
</li>
</ul>
<h6 id="逻辑分区为什么可以是n个呢？"><a href="#逻辑分区为什么可以是n个呢？" class="headerlink" title="逻辑分区为什么可以是n个呢？"></a>逻辑分区为什么可以是n个呢？</h6><ul>
<li>类似主引导扇区，扩展分区利用最前面几个扇区来记载逻辑分区的引用信息。</li>
</ul>
<h5 id="磁盘分区实质"><a href="#磁盘分区实质" class="headerlink" title="磁盘分区实质"></a>磁盘分区实质</h5><ul>
<li>其实所谓的“分区”只是针对那个64 Bytes的磁盘分区表进行设置而已！</li>
<li>硬盘默认的分区表仅能写入四组分区信息</li>
<li>这四组分区信息我们称为主要（Primary）或延伸（Extended）分区</li>
<li>分区的最小单位“通常”为柱面（cylinder）</li>
<li>当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据的处理</li>
</ul>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>了解磁盘基础之后，我们就可以进行磁盘分区实操了。先了解一下分区整个流程：</p>
<ol>
<li>对磁盘进行分区，以创建可用的 partition ；</li>
<li>对该 partition 进行格式化 （format），以创建系统可用的 filesystem；</li>
<li>若想要仔细一点，则可对刚刚创建好的 filesystem 进行检验；</li>
<li>在 Linux 系统上，需要创建挂载点 （亦即是目录），并将它挂载上来；</li>
</ol>
<h5 id="查看分区状态"><a href="#查看分区状态" class="headerlink" title="查看分区状态"></a>查看分区状态</h5><p>在分区之前，我们需要先了解机器的磁盘状态：</p>
<p><strong>lsblk 列出系统上的所有磁盘列表 ：</strong></p>
<pre><code>[root@localhost ~]# lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0    2M  0 part 
├─sda2            8:2    0    2M  0 part 
├─sda3            8:3    0    2G  0 part /boot
├─sda4            8:4    0    1K  0 part 
└─sda5            8:5    0   18G  0 part 
  ├─centos-root 253:0    0  9.8G  0 lvm  /
  ├─centos-swap 253:1    0 1000M  0 lvm  [SWAP]
  ├─centos-var  253:2    0    2G  0 lvm  /var
  └─centos-home 253:3    0  5.3G  0 lvm  /home
sdb               8:16   0   20G  0 disk 
sr0              11:0    1    4G  0 rom  </code></pre><p>为了方便演示，新增了<code>sdb</code>磁盘，原来的<code>sda</code>磁盘则已经进行了分区。</p>
<p><strong>blkid 列出设备的 UUID 等参数</strong> :</p>
<pre><code>[root@localhost ~]# blkid
/dev/sda3: UUID=&quot;c225904f-a210-43cc-8c8c-e210642262f6&quot; TYPE=&quot;xfs&quot; 
/dev/sda5: UUID=&quot;OXEomY-lqXp-6Beu-cebI-T9wv-Z4S8-UZ9Aq9&quot; TYPE=&quot;LVM2_member&quot; 
/dev/sr0: UUID=&quot;2015-12-09-23-14-10-00&quot; LABEL=&quot;CentOS 7 x86_64&quot; TYPE=&quot;iso9660&quot; PTTYPE=&quot;dos&quot; 
/dev/mapper/centos-root: UUID=&quot;775ac81a-210f-4089-87a3-a9a6a680b018&quot; TYPE=&quot;xfs&quot; 
/dev/mapper/centos-swap: UUID=&quot;f229bae3-e7f5-4da0-8f45-8269bd0f03e7&quot; TYPE=&quot;swap&quot; 
/dev/mapper/centos-var: UUID=&quot;9acbfd67-676d-4b0d-9c78-63e5fbdf1236&quot; TYPE=&quot;xfs&quot; 
/dev/mapper/centos-home: UUID=&quot;557aae02-8971-4d3f-a258-e3222b1483f1&quot; TYPE=&quot;xfs&quot; </code></pre><p><strong>parted 列出磁盘的分区表类型与分区信息</strong> ：</p>
<pre><code>[root@localhost ~]# parted /dev/sda print
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sda: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End     Size    Type      File system  Flags
 1      1049kB  3146kB  2097kB  primary
 2      3146kB  5243kB  2097kB  primary
 3      5243kB  2102MB  2097MB  primary   xfs          boot
 4      2102MB  21.5GB  19.4GB  extended
 5      2103MB  21.5GB  19.4GB  logical                lvm</code></pre><h5 id="进行分区"><a href="#进行分区" class="headerlink" title="进行分区"></a>进行分区</h5><blockquote>
<p>“MBR 分区表请使用 <code>fdisk</code> 分区， GPT 分区表请使用 <code>gdisk</code> 分区！”</p>
</blockquote>
<p>整个分区操作分两步：</p>
<ol>
<li>gdisk、fdisk分区</li>
<li>partprobe 更新 Linux 核心的分区表信息</li>
</ol>
<h6 id="gdisk、fdisk分区"><a href="#gdisk、fdisk分区" class="headerlink" title="gdisk、fdisk分区"></a>gdisk、fdisk分区</h6><p>下面我们用<code>gdisk</code>命令来进行分区，没有该命令的先<code>yum install -y gdisk</code>进行安装。</p>
<pre><code>[root@localhost ~]# gdisk /dev/sdb
GPT fdisk (gdisk) version 0.8.10

Partition table scan:
  MBR: not present
  BSD: not present
  APM: not present
  GPT: not present

Creating new GPT entries.

Command (? for help): ?
b    back up GPT data to a file
c    change a partition&#39;s name
d    delete a partition
i    show detailed information on a partition
l    list known partition types
n    add a new partition
o    create a new empty GUID partition table (GPT)
p    print the partition table
q    quit without saving changes
r    recovery and transformation options (experts only)
s    sort partitions
t    change a partition&#39;s type code
v    verify disk
w    write table to disk and exit
x    extra functionality (experts only)
?    print this menu

Command (? for help): p
Disk /dev/sdb: 41943040 sectors, 20.0 GiB
Logical sector size: 512 bytes
Disk identifier (GUID): 0F88B5F3-360F-4B70-A503-2C705CA23023
Partition table holds up to 128 entries
First usable sector is 34, last usable sector is 41943006
Partitions will be aligned on 2048-sector boundaries
Total free space is 41942973 sectors (20.0 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name

Command (? for help): n
Partition number (1-128, default 1): 
First sector (34-41943006, default = 2048) or {+-}size{KMGTP}: 
Last sector (2048-41943006, default = 41943006) or {+-}size{KMGTP}: +5G
Current type is &#39;Linux filesystem&#39;
Hex code or GUID (L to show codes, Enter = 8300): 
Changed type of partition to &#39;Linux filesystem&#39;

Command (? for help): p
Disk /dev/sdb: 41943040 sectors, 20.0 GiB
Logical sector size: 512 bytes
Disk identifier (GUID): 0F88B5F3-360F-4B70-A503-2C705CA23023
Partition table holds up to 128 entries
First usable sector is 34, last usable sector is 41943006
Partitions will be aligned on 2048-sector boundaries
Total free space is 31457213 sectors (15.0 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048        10487807   5.0 GiB     8300  Linux filesystem

Command (? for help):</code></pre><p>该命令非常简单，输入<code>?</code>命令可以看到详细的操作命令指南，完全不需要记忆就可以对一个磁盘进行增删分区操作。</p>
<p>最后， 如果一切的分区状态都正常的话，还需要执行一步操作写入磁盘分区表：</p>
<pre><code>Command (? for help): w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? (Y/N): y
OK; writing new GUID partition table (GPT) to /dev/sdb.
The operation has completed successfully.</code></pre><h6 id="partprobe-更新-Linux-核心的分区表信息"><a href="#partprobe-更新-Linux-核心的分区表信息" class="headerlink" title="partprobe 更新 Linux 核心的分区表信息"></a>partprobe 更新 Linux 核心的分区表信息</h6><p>进行分区操作之后，如果 Linux 此时还在使用这颗磁盘，为了担心系统出问题，所以分区表并没有被更新，这时需要我们手动更新：</p>
<pre><code>[root@localhost ~]# partprobe -s
/dev/sda: msdos partitions 1 2 3 4 &lt;5&gt;
/dev/sdb: gpt partitions 1 2
[root@localhost ~]# cat /proc/partitions
major minor  #blocks  name

   8        0   20971520 sda
   8        1       2048 sda1
   8        2       2048 sda2
   8        3    2048000 sda3
   8        4          0 sda4
   8        5   18917376 sda5
  11        0    4228096 sr0
   8       16   20971520 sdb
   8       17    5242880 sdb1
   8       18    6291456 sdb2</code></pre><h5 id="磁盘格式化（创建文件系统）"><a href="#磁盘格式化（创建文件系统）" class="headerlink" title="磁盘格式化（创建文件系统）"></a>磁盘格式化（创建文件系统）</h5><p>我们常听到的“格式化”其实应该称为“创建文件系统 （make filesystem）”才对啦！所以使用的指令是 mkfs 喔！</p>
<p>如果我们要创建的是 xfs 文件系统， 那使用的是 mkfs.xfs 这个指令。这个指令是这样使用的： <code>mkfs.xfs device</code>；如果创建 ext4 系统，则用 <code>mkfs.ext4 device</code>;</p>
<pre><code>[root@localhost ~]# mkfs.xfs /dev/sdb1
meta-data=/dev/sdb1              isize=256    agcount=4, agsize=327680 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=0        finobt=0
data     =                       bsize=4096   blocks=1310720, imaxpct=25
...
[root@localhost ~]# mkfs.ext4 /dev/sdb2
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
393216 inodes, 1572864 blocks
...</code></pre><p>查看格式化结果：</p>
<pre><code>[root@localhost ~]# parted /dev/sdb print
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End     Size    File system  Name              Flags
 1      1049kB  5370MB  5369MB  xfs          Linux filesystem
 2      5370MB  11.8GB  6442MB  ext4         Linux filesystem</code></pre><h5 id="文件系统挂载与卸载"><a href="#文件系统挂载与卸载" class="headerlink" title="文件系统挂载与卸载"></a>文件系统挂载与卸载</h5><p>磁盘格式化之后是不是就能使用了呢？当然还不行，格式化就类似酒店房间已经打扫干净，最后还要给客户办理入住手续啊，毕竟一个房间只能接待一位客户，这就是所谓的挂载。</p>
<blockquote>
<p>挂载点：挂载点是目录， 而这个目录是进入磁盘分区（其实是文件系统啦！）的入口。</p>
</blockquote>
<p>进行挂载操作前，需要了解几点：</p>
<ul>
<li>单一文件系统不应该被重复挂载在不同的挂载点（目录）中；</li>
<li>单一目录不应该重复挂载多个文件系统；</li>
<li>要作为挂载点的目录，理论上应该都是空目录才是。</li>
</ul>
<h6 id="挂载磁盘-mount-device-dirname"><a href="#挂载磁盘-mount-device-dirname" class="headerlink" title="挂载磁盘 mount device dirname"></a>挂载磁盘 mount device dirname</h6><pre><code>[root@localhost ~]# mkdir -p /test/xfs_test
[root@localhost ~]# mkdir -p /test/ext4_test
[root@localhost ~]# mount /dev/sdb1 /test/xfs_test/
[root@localhost ~]# mount /dev/sdb2 /test/ext4_test/

[root@localhost ~]# df /test/xfs_test/
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/sdb1        5232640 32928   5199712   1% /test/xfs_test
[root@localhost ~]# df /test/ext4_test/
Filesystem     1K-blocks  Used Available Use% Mounted on
/dev/sdb2        6061632 24568   5706108   1% /test/ext4_test</code></pre><h6 id="挂载目录-mount-–bind-dirname-target-dirname"><a href="#挂载目录-mount-–bind-dirname-target-dirname" class="headerlink" title="挂载目录 mount  –bind dirname target_dirname"></a>挂载目录 mount  –bind dirname target_dirname</h6><pre><code>[root@localhost ~]# mkdir -p /test/var
[root@localhost ~]# mount --bind /test/var/ /test/xfs_test/

[root@localhost ~]# ls -lid /test/var/ /test/xfs_test/
34108202 drwxr-xr-x. 2 root root 6 Sep  8 10:35 /test/var/
34108202 drwxr-xr-x. 2 root root 6 Sep  8 10:35 /test/xfs_test/

[root@localhost ~]# touch /test/var/a.txt
[root@localhost ~]# ls /test/xfs_test/
a.txt</code></pre><h6 id="卸载-umount-device-mountpoint"><a href="#卸载-umount-device-mountpoint" class="headerlink" title="卸载 umount device | mountpoint"></a>卸载 umount device | mountpoint</h6><pre><code>[root@localhost ~]# umount /dev/sdb1
[root@localhost ~]# umount /dev/sdb2

[root@localhost ~]# lsblk /dev/sdb
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sdb      8:16   0  20G  0 disk 
├─sdb1   8:17   0   5G  0 part 
└─sdb2   8:18   0   6G  0 part </code></pre><p>此时挂载点已经消失，即卸载成功。</p>
<h2 id="设置开机挂载"><a href="#设置开机挂载" class="headerlink" title="设置开机挂载"></a>设置开机挂载</h2><p>我们上面讨论整个挂载的流程，磁盘分区也顺其自然成功挂载上去了，一切看起来都很完美了！</p>
<p>不过，这里还有一个坑爹的地方，就是上面的所有操作都是临时有效的，当机器重启之后，我们需要重新进行挂载。</p>
<p>那么可不可以在开机的时候就将我要的文件系统都挂好呢？当然可以啰！那就直接到 <code>/etc/fstab</code> 里面去修改就行啰！</p>
<pre><code>[root@localhost ~]# vim /etc/fstab
/dev/mapper/centos-root /                       xfs     defaults        0 0
UUID=c225904f-a210-43cc-8c8c-e210642262f6 /boot                   xfs     defaults        0 0
/dev/mapper/centos-home /home                   xfs     defaults        0 0
/dev/mapper/centos-var  /var                    xfs     defaults        0 0
/dev/mapper/centos-swap swap                    swap    defaults        0 0
/dev/sdb1               /test/xfs_test          xfs     defaults        0 0
/dev/sdb2               /test/ext4_test         ext4     defaults        0 0</code></pre><pre><code>[root@localhost ~]# reboot
[root@localhost ~]# lsblk /dev/sdb
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sdb      8:16   0  20G  0 disk 
├─sdb1   8:17   0   5G  0 part /test/xfs_test
└─sdb2   8:18   0   6G  0 part /test/ext4_test</code></pre>]]></content>
  </entry>
  <entry>
    <title>Linux权限命令</title>
    <url>/article/2020/02/24/Linux%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<h4 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限"></a>查看文件权限</h4><pre><code class="linux">ll /
lrwxrwxrwx.   1 root root     7 Mar 29 11:44 bin -&gt; usr/bin
dr-xr-xr-x.   5 root root  4096 Mar 29 11:48 boot
//...</code></pre>
<p>输出结果的第一个字段就是描述文件和目录权限的编码。这个字段的第一个字符代表了对象的类型：</p>
<ul>
<li>-  代表文件</li>
<li>d  代表目录</li>
<li>l  代表链接</li>
<li>c  代表字符型设备</li>
<li>b  代表块设备</li>
<li>n  代表网络设备</li>
</ul>
<p>之后有3组三字符的编码。每一组定义了3种访问权限：</p>
<ul>
<li>r 代表对象是可读的</li>
<li>w 代表对象是可写的</li>
<li>x 代表对象是可执行的</li>
</ul>
<p>若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别：</p>
<ul>
<li>对象的属主</li>
<li>对象的属组</li>
<li>系统其他用户</li>
</ul>
<h4 id="默认文件权限"><a href="#默认文件权限" class="headerlink" title="默认文件权限"></a>默认文件权限</h4><p>umask值用于设置用户在创建文件时的默认权限，当我们在系统中创建目录或文件时，目录或文件所具有的默认权限就是由umask值决定的。</p>
<p>对于root用户，系统默认的umask值是0022；对于普通用户，系统默认的umask值是0002。执行umask命令可以查看当前用户的umask值。</p>
<pre><code class="linux">[root@localhost ~]# umask
0022
[user1@localhost ~]$ umask
0002</code></pre>
<p>umask值一共有4组数字，其中第1组数字用于定义<strong>特殊权限</strong>，我们一般不予考虑，与一般权限有关的是后3组数字。</p>
<p>默认情况下，对于目录，用户所能拥有的<strong>最大权限是777</strong>；<br>对于文件，用户所能拥有的最大权限是目录的<strong>最大权限去掉执行权限，即666</strong>。<br>因为x执行权限对于目录是必须的，没有执行权限就无法进入目录，而对于文件则不必默认赋予x执行权限。</p>
<p>默认权限是所能拥有的权限减去umask值：<br>创建目录默认权限是 rwxr-xr-x (777 - 022  -&gt;  755)<br>创建文件默认权限是 rw-r–r– (666 - 022 -&gt; 644)</p>
<pre><code class="linux">[root@localhost ~]# touch a.txt
[root@localhost ~]# mkdir b
[root@localhost ~]# ll
-rw-r--r--. 1 root root    0 Apr 18 09:25 a.txt
drwxr-xr-x. 2 root root 4096 Apr 18 09:25 b</code></pre>
<p>umask可以通过修改/etc/profile或者/etc/bashrc里面的值进行永久修改：</p>
<pre><code class="linux">[root@localhost ~]# cat /etc/profile | grep umask
# By default, we want umask to get set. This sets it for login shell
    umask 002
    umask 022</code></pre>
<p>他们的区别是/etc/profile只在用户第一次登录时被执行，而/etc/bashrc则在用户每次登录加载Bash Shell时都会被执行。</p>
<p>因而，如果是修改/etc/profile文件，将只对新创建的用户生效；而如果是修改/etc/bashrc文件，则对所有用户都生效。</p>
<h4 id="查看群组与用户"><a href="#查看群组与用户" class="headerlink" title="查看群组与用户"></a>查看群组与用户</h4><p>查看当前系统所有组</p>
<pre><code class="linux">[root@localhost ~]# cat /etc/group
root:x:0:
bin:x:1:
// ...
daemon:x:2:
sshd:x:74:
haotengfei:x:1000:
user1:x:1001:</code></pre>
<p>查看当前系统所有用户名</p>
<pre><code class="linux">cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F&quot;:&quot; &#39;{ print $1&quot;|&quot;$3&quot;|&quot;$4 }&#39;|more
root|0|0
sync|5|0
haotengfei|1000|1000
user1|1001|1001
user2|1002|1002
user3|1003|1003</code></pre>
<h4 id="权限操作"><a href="#权限操作" class="headerlink" title="权限操作"></a>权限操作</h4><p>改变所属用户组</p>
<pre><code class="linux">[root@localhost ~]# chgrp user1 a.txt
[root@localhost ~]# ll
-rw-r--r--. 1 root user1    0 Apr 18 09:25 a.txt</code></pre>
<p>改变所属用户</p>
<pre><code class="linux">[root@localhost ~]# chown user2 a.txt
[root@localhost ~]# ll
-rw-r--r--. 1 user2 root    0 Apr 18 09:25 a.txt</code></pre>
<p>改变所属权限</p>
<pre><code class="linux">[root@localhost ~]# chmod 777 a.txt
[root@localhost ~]# ll
-rwxrwxrwx. 1 root root    0 Apr 18 09:25 a.txt</code></pre>
<pre><code class="linux">// u代表用户，g代表用户组，o代表其他人
[root@localhost ~]# chmod u=x,g=x,o=x a.txt
[root@localhost ~]# ll
---x--x--x. 1 root root    0 Apr 18 09:25 a.txt</code></pre>
<p>改变文件夹下文件权限</p>
<pre><code class="linux">[root@localhost ~]# mv a.txt b/
[root@localhost ~]# cd b
[root@localhost b]# ll
---x--x--x. 1 root root 0 Apr 18 09:25 a.txt

[root@localhost ~]# chmod 777 b
[root@localhost ~]# ll
drwxrwxrwx. 2 root root 4096 Apr 18 10:01 b
[root@localhost ~]# ll b/a.txt
---x--x--x. 1 root root 0 Apr 18 09:25 b/a.txt // 文件夹下权限没有被修改

[root@localhost ~]# chmod -R 777 b
[root@localhost ~]# ll b/a.txt
-rwxrwxrwx. 1 root root 0 Apr 18 09:25 b/a.txt // 此时被修改</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Linux文件压缩</title>
    <url>/article/2020/02/24/Linux%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9.html</url>
    <content><![CDATA[<p>文件压缩是Linux环境下非常常见的操作，我们可以通过一个常用的常见来熟悉相关命令。</p>
<h4 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h4><pre><code class="linux">[root@localhost ~]# ll -hS /etc/* | head -n 3
// -h: 显示默认单位
// -S： 按照大小排序
// -n: 从头显示前3行
-rw-r--r--.  1 root root 655K Jun  7  2013 /etc/services
-rw-r--r--.  1 root root  25K Aug  5  2015 /etc/dnsmasq.conf
-rw-r--r--.  1 root root  19K Mar 31 07:47 /etc/ld.so.cache</code></pre>
<h4 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h4><pre><code class="linux">[root@localhost ~]# ll /home/user1
total 0
-rw-rw-r--. 1 user1 user1 0 Apr 18 09:00 a
[root@localhost ~]# cp -ai /etc/services  /home/user1/services.cp
- a 保留链接和文件属性，递归拷贝目录，相当于下面的d、p、r三个选项组合。
- d 拷贝时保留链接。
- f 删除已经存在目标文件而不提示。
- i 覆盖目标文件前将给出确认提示，属交互式拷贝。
- p 复制源文件内容后，还将把其修改时间和访问权限也复制到新文件中。
- r 若源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件
[root@localhost ~]# ll /home/user1/
// total后面的数字是指当前目录下所有文件所占用的空间总和
total 656
-rw-rw-r--. 1 user1 user1      0 Apr 18 09:00 a
-rw-r--r--. 1 root  root  670293 Jun  7  2013 services.cp</code></pre>
<h4 id="打包与压缩"><a href="#打包与压缩" class="headerlink" title="打包与压缩"></a>打包与压缩</h4><p>首先要弄清两个概念：打包和压缩。</p>
<p>打包是指将一大堆文件或目录变成一个总的文件；</p>
<p>压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p>
<p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p>
<h6 id="准备拷贝文件"><a href="#准备拷贝文件" class="headerlink" title="准备拷贝文件"></a>准备拷贝文件</h6><pre><code class="linux">// 拷贝两份文件
[root@localhost user1]# cp services.cp services.cp01
[root@localhost user1]# cp services.cp services.cp02</code></pre>
<h6 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h6><pre><code class="linux">// 打包
[root@localhost user1]# tar -cvf 1.tar services.cp services.cp01 services.cp02

// 打包与压缩
[root@localhost user1]# tar -zcvf 1.tar.gz services.cp services.cp01
// 打包与压缩
[root@localhost user1]# tar -jcvf 1.tar.bz2 services.cp services.cp02
选项与参数：
-c ：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）
-t ：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；
-x ：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开
特别留意的是， -c, -t, -x 不可同时出现在一串命令行中。
-z ：通过 gzip 的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz
-j ：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2
-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！
-f filename：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！
-C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。

-p（小写） ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件
-P（大写） ：保留绝对路径，亦即允许备份数据中含有根目录存在之意；
--exclude=FILE：在压缩的过程中，不要将 FILE 打包！</code></pre>
<h6 id="查看打包效果"><a href="#查看打包效果" class="headerlink" title="查看打包效果"></a>查看打包效果</h6><pre><code class="linux">// 查看打包与压缩效果
[root@localhost user1]# ll -hS
total 84K
-rw-r--r--. 1 root root 40K Apr 24 10:35 1.tar
-rw-r--r--. 1 root root 10K Apr 24 10:07 services.cp
-rw-r--r--. 1 root root 10K Apr 24 10:34 services.cp01
-rw-r--r--. 1 root root 10K Apr 24 10:34 services.cp02
-rw-r--r--. 1 root root 161 Apr 24 10:38 1.tar.gz
-rw-r--r--. 1 root root 148 Apr 24 10:38 1.tar.bz2</code></pre>
<h6 id="查看打包后包含文件"><a href="#查看打包后包含文件" class="headerlink" title="查看打包后包含文件"></a>查看打包后包含文件</h6><pre><code class="linux">[root@localhost user1]# tar -tvf 1.tar
-rw-r--r-- root/root     10240 2019-04-24 10:07 services.cp
-rw-r--r-- root/root     10240 2019-04-24 10:34 services.cp01
-rw-r--r-- root/root     10240 2019-04-24 10:34 services.cp02

[root@localhost user1]# tar -tvf 1.tar.gz
-rw-r--r-- root/root     10240 2019-04-24 10:07 services.cp
-rw-r--r-- root/root     10240 2019-04-24 10:34 services.cp01

[root@localhost user1]# tar -tvf 1.tar.bz2
-rw-r--r-- root/root     10240 2019-04-24 10:07 services.cp
-rw-r--r-- root/root     10240 2019-04-24 10:34 services.cp02</code></pre>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><h6 id="解压打包文件"><a href="#解压打包文件" class="headerlink" title="解压打包文件"></a>解压打包文件</h6><pre><code class="linux">[root@localhost user1]# mkdir untar
[root@localhost user1]# tar -xvf 1.tar -C ./untar/
services.cp
services.cp01
services.cp02
[root@localhost user1]# ll ./untar/
total 36
-rw-r--r--. 1 root root 10240 Apr 24 10:07 services.cp
-rw-r--r--. 1 root root 10240 Apr 24 10:34 services.cp01
-rw-r--r--. 1 root root 10240 Apr 24 10:34 services.cp02</code></pre>
<h6 id="解压压缩文件"><a href="#解压压缩文件" class="headerlink" title="解压压缩文件"></a>解压压缩文件</h6><pre><code class="linux">[root@localhost user1]# mkdir untar.gz
[root@localhost user1]# tar -xvf 1.tar.gz -C ./untar.gz/
// 也可以加上压缩类型 -zxvf , -jxvf
services.cp
services.cp01
[root@localhost user1]# ll ./untar.gz/
total 24
-rw-r--r--. 1 root root 10240 Apr 24 10:07 services.cp
-rw-r--r--. 1 root root 10240 Apr 24 10:34 services.cp01</code></pre>
<h6 id="解压部分文件"><a href="#解压部分文件" class="headerlink" title="解压部分文件"></a>解压部分文件</h6><pre><code class="linux">[root@localhost user1]# mkdir untar.bz2
[root@localhost user1]# tar -jxvf 1.tar.bz2 services.cp02 -C ./untar.bz2/
services.cp02
[root@localhost user1]# ll ./untar.bz2/
total 0 ???为什么没有解压过来？</code></pre>
]]></content>
  </entry>
  <entry>
    <title>ACL管理</title>
    <url>/article/2020/02/24/ACL%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<h2 id="ACL-Access-Control-List"><a href="#ACL-Access-Control-List" class="headerlink" title="ACL(Access Control List)"></a>ACL(Access Control List)</h2><p>传统的权限仅有三种身份（owner, group, others）搭配三种权限 （r,w,x)而已，并没有办法单纯的针对某一个使用者或某一个群组来设置特定的权<br>限需求， 此时就得要使用 ACL 这个机制。</p>
<p>测试系统是否有支持 ACL：</p>
<pre><code class="linux">// dmesg命令显示linux内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信息。
[root@localhost ~]# dmesg | grep -i acl
[    1.138270] systemd[1]: systemd 219 running in system mode. (+PAM +AUDIT +SELINUX +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ -LZ4 -SECCOMP +BLKID +ELFUTILS +KMOD +IDN)
[    2.320454] SGI XFS with ACLs, security attributes, no debug enabled</code></pre>
<h5 id="查看ACL"><a href="#查看ACL" class="headerlink" title="查看ACL"></a>查看ACL</h5><pre><code class="linux">[root@localhost ~]# touch acl.test1
[root@localhost ~]# ll acl.test1
-rw-r--r--. 1 root root 0 May 13 06:19 acl.test2

[root@localhost ~]# getfacl acl.test1
# file: acl.test1
# owner: root
# group: root
user::rw-
group::r--
other::r--</code></pre>
<h5 id="设置ACL"><a href="#设置ACL" class="headerlink" title="设置ACL"></a>设置ACL</h5><pre><code class="linux">[root@localhost ~]# setfacl -m u:user1:rwx acl.test1 
[root@localhost ~]# ll acl.test1 
-rw-rwxr--+ 1 root root 0 May 13 06:12 acl.test1</code></pre>
<p>选项与参数：<br>    -m ：设置后续的 acl 参数给文件使用，不可与 -x 合用；<br>    -x ：删除后续的 acl 参数，不可与 -m 合用；<br>    -b ：移除“所有的” ACL 设置参数；<br>    -k ：移除“默认的” ACL 参数，关于所谓的“默认”参数于后续范例中介绍；<br>    -R ：递回设置 acl ，亦即包括次目录都会被设置起来；<br>    -d ：设置“默认 acl 参数”的意思！只对目录有效，在该目录新建的数据会引用此默认值</p>
<pre><code class="linux">[root@localhost ~]# getfacl acl.test1 
# file: acl.test1
# owner: root
# group: root
user::rw-
user:user1:rwx  // 新增
group::r--
mask::rwx       // 新增
other::r--</code></pre>
<h5 id="移除ACL"><a href="#移除ACL" class="headerlink" title="移除ACL"></a>移除ACL</h5><pre><code class="linux">[root@localhost ~]# setfacl -x u:user1 acl.test1
[root@localhost ~]# getfacl acl.test1
# file: acl.test1
# owner: root
# group: root
user::rw-
group::r--
mask::r--
other::r--</code></pre>
<h5 id="测试ACL权限"><a href="#测试ACL权限" class="headerlink" title="测试ACL权限"></a>测试ACL权限</h5><pre><code class="linux">[root@localhost ~]# cd /home/user1/
[root@localhost user1]# ll
total 0
[root@localhost user1]# touch acl.test
[root@localhost user1]# setfacl -m u:user1:rx acl.test 
[root@localhost user1]# su user1
[user1@localhost ~]$ ll
total 4
-rw-r-xr--+ 1 root root 0 May 13 07:01 acl.test

// 没有w权限
[user1@localhost ~]$ echo &#39;some text&#39; &gt;&gt; acl.test 
bash: acl.test: Permission denied

// 有x权限，可以删除
[user1@localhost ~]$ rm -f acl.test 
[user1@localhost ~]$ ll
total 0</code></pre>
<h5 id="有效权限：“-m-权限-”"><a href="#有效权限：“-m-权限-”" class="headerlink" title="有效权限：“ m:权限 ”"></a>有效权限：“ m:权限 ”</h5><p>细心的朋友可能注意到设置ACL值的时候，出现了一个<code>mask</code>值；</p>
<p>意义是： 使用者或群组所设置的权限必须要存在于 mask 的权限设置范围内才会生效，此即“有效权限 （effective permission）”</p>
<pre><code class="linux">[root@localhost user1]# touch acl.mask.test
[root@localhost user1]# setfacl -m u:user1:rwx acl.mask.test 
[root@localhost user1]# getfacl acl.mask.test 
# file: acl.mask.test
# owner: root
# group: root
user::rw-
user:user1:rwx
group::r--
mask::rwx      // 默认rwx
other::r--

[root@localhost user1]# setfacl -m m:x acl.mask.test 
[root@localhost user1]# getfacl acl.mask.test 
# file: acl.mask.test
# owner: root
# group: root
user::rw-
user:user1:rwx          #effective:--x  // 表示起效果的权限
group::r--              #effective:---
mask::--x
other::r--</code></pre>
<p>测试验证一番：</p>
<pre><code class="linux">[root@localhost user1]# su user1
[user1@localhost ~]$ ll
total 4
-rw---xr--+ 1 root root 0 May 13 07:34 acl.mask.test

[user1@localhost ~]$ echo &#39;other text&#39; &gt;&gt; acl.mask.test 
bash: acl.mask.test: Permission denied

[user1@localhost ~]$ rm -f acl.mask.test 
[user1@localhost ~]$ ll
total 0</code></pre>
<h5 id="使用默认权限给文件夹设置ACL"><a href="#使用默认权限给文件夹设置ACL" class="headerlink" title="使用默认权限给文件夹设置ACL"></a>使用默认权限给文件夹设置ACL</h5><pre><code class="linux">[root@localhost user1]# setfacl -m d:u:user1:rwx acl.dir/
[root@localhost user1]# getfacl acl.dir/
# file: acl.dir/
# owner: root
# group: root
user::rwx
group::r-x
other::r-x
default:user::rwx
default:user:user1:rwx
default:group::r-x
default:mask::rwx
default:other::r-x

// 不能默认权限设置文件
[root@localhost user1]# touch acl.txt
[root@localhost user1]# setfacl -m d:u:user1:rwx acl.txt 
setfacl: acl.txt: Only directories can have default ACLs</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Vim快速入门</title>
    <url>/article/2020/02/24/Vim%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<p>Vim 是一款多模式文本编辑器，主要有以下四种模式</p>
<h2 id="正常模式（Normal-mode）"><a href="#正常模式（Normal-mode）" class="headerlink" title="正常模式（Normal-mode）"></a>正常模式（Normal-mode）</h2><pre><code class="bash"># 进入正常模式
$ vim + enter</code></pre>
<p>按大小写I,i,O,o,A,a皆可进入插入模式。但是光标位置会有区别。</p>
<ul>
<li>如果是i, 则光标没有移动</li>
<li>如果是shift+i,则光标移到改行首位</li>
<li>如果是a,则光标移动到下一位</li>
<li>如果是shift+a,则光标移动到改行末尾</li>
<li>如果是o,则光标移到下一行，并生成一空行</li>
<li>如果是shift+o,则光标移到上一行，并生成一空行</li>
</ul>
<h5 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h5><p>按住键盘的 H,J,K,L 可以在正常模式下进行光标的左右上下移动。</p>
<h5 id="复制张贴"><a href="#复制张贴" class="headerlink" title="复制张贴"></a>复制张贴</h5><ul>
<li><code>yy + p</code>，复制光标所在行，然后粘贴到光标所在行；</li>
<li><code>n + yy + p</code>,复制光标以下n行，然后粘贴到光标所在行，复制时会提示复制行数；</li>
<li><code>y$ + p</code>,复制光标到行尾数据，然后粘贴到光标所在行；</li>
<li><code>dd + p</code>，剪切光标所在行，然后粘贴到光标所在行；</li>
<li><code>n + dd + p</code>,剪切光标以下n行，然后粘贴到光标所在行，复制时会提示复制行数；</li>
<li><code>d$ + p</code>,剪切光标到行尾数据，然后粘贴到光标所在行；</li>
</ul>
<h5 id="撤销替换删除"><a href="#撤销替换删除" class="headerlink" title="撤销替换删除"></a>撤销替换删除</h5><ul>
<li><code>u</code>,撤销上一步操作，可以多次操作连续撤销；</li>
<li><code>ctrl + r</code>,取消撤销命令，与撤销命令相反；</li>
<li><code>x</code>,删除光标所在字符；</li>
<li><code>r</code>,下一个输入替换所在字符；</li>
</ul>
<h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5><ul>
<li><code>:set nu</code>,显示行号；</li>
<li><code>:set nonu</code>,不显示行号；</li>
<li><code>n + shift + g</code>,跳转到底n行；</li>
<li><code>gg</code>,跳转到首行；</li>
<li><code>shift + g</code>,跳转到末行；</li>
<li><code>^</code>,跳转到行头；</li>
<li><code>$</code>,跳转到行尾；</li>
</ul>
<h2 id="插入模式（Insert-mode"><a href="#插入模式（Insert-mode" class="headerlink" title="插入模式（Insert-mode)"></a>插入模式（Insert-mode)</h2><h5 id="退出与保存"><a href="#退出与保存" class="headerlink" title="退出与保存"></a>退出与保存</h5><ul>
<li><code>:q, :q!</code>,不保存退出；</li>
<li><code>:wq</code>,保存退出；</li>
<li><code>:w /path/to/save</code>,保存到某一文件；</li>
<li><code>:! + cmd</code>,在不退出情况下执行其他命令，按enter退出回到编辑器环境；</li>
</ul>
<h2 id="命令模式（Command-mode）"><a href="#命令模式（Command-mode）" class="headerlink" title="命令模式（Command-mode）"></a>命令模式（Command-mode）</h2><h5 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h5><ul>
<li><code>set nohlsearch</code>, 隐藏高亮效果；</li>
</ul>
<h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><ul>
<li><code>/xxx + enter</code>,查找匹配xxx的字符，按n跳转到下一个匹配字符，按shift+n跳转到上一个匹配项；</li>
<li><code>:s/old/new + enter</code>,替换光标所在行第一个匹配项； </li>
<li><code>:s/old/new/g + enter</code>,替换光标所在行所有匹配项； </li>
<li><code>:%s/old/new + enter</code>,替换所有行第一个匹配项； </li>
<li><code>:%s/old/new/g + enter</code>,替换所有行所有匹配项； </li>
<li><code>:3,5s/old/new + enter</code>,替换第三到第五行第一个匹配项； </li>
<li><code>:3,5s/old/new/g + enter</code>,替换第三到第五行所有匹配项； </li>
</ul>
<h2 id="可视模式（Visual-mode）"><a href="#可视模式（Visual-mode）" class="headerlink" title="可视模式（Visual-mode）"></a>可视模式（Visual-mode）</h2><p>正常模式下按v进入可视模式；<br>按<code>shift+v</code>进入块可视模式；</p>
<h2 id="永久设置"><a href="#永久设置" class="headerlink" title="永久设置"></a>永久设置</h2><p>在编辑器环境下例如行号显示之类的设置是暂时的，关闭编辑器后会失效，如果需要永久起效需要设置<code>/etc/vimrc</code>文件；</p>
]]></content>
  </entry>
  <entry>
    <title>面试经典问题汇总</title>
    <url>/article/2020/01/28/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<h2 id="GET与POST请求的区别"><a href="#GET与POST请求的区别" class="headerlink" title="GET与POST请求的区别"></a>GET与POST请求的区别</h2><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p>
<p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP连接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p>
<p>为什么GET与POST请求还有这么多差异呢？根源在于浏览器与服务器的限制。</p>
<h5 id="缓存上的区别"><a href="#缓存上的区别" class="headerlink" title="缓存上的区别"></a><strong>缓存上的区别</strong></h5><ul>
<li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li>
<li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li>
</ul>
<h5 id="安全上的区别"><a href="#安全上的区别" class="headerlink" title="安全上的区别"></a><strong>安全上的区别</strong></h5><ul>
<li>查询字符串（名称/值对）是在 GET 请求的 URL 中发送的，有安全问题。</li>
<li>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的，因此安全性较get高</li>
</ul>
<p><strong>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。</strong></p>
<p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p>
<ul>
<li>HTTP 协议 未规定 GET 和POST的长度限制</li>
<li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li>
<li>不同的浏览器和WEB服务器，限制的最大长度不一样</li>
<li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>有关 GET 请求的其他一些注释：</p>
<ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据</li>
</ul>
<p>有关 POST 请求的其他一些注释：</p>
<ul>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求</li>
</ul>
<h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<p>描述符可同时具有的键值</p>
<table>
<thead>
<tr>
<th></th>
<th>configurable</th>
<th>enumerable</th>
<th>value</th>
<th>writable</th>
<th>get</th>
<th>set</th>
</tr>
</thead>
<tbody><tr>
<td>数据描述符</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>存取描述符</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<h5 id="数据属性："><a href="#数据属性：" class="headerlink" title="数据属性："></a>数据属性：</h5><pre><code class="js">var obj = {};
Object.defineProperty(obj, &quot;key&quot;, {
  enumerable: false,
  configurable: false,
  writable: false,
  value: &quot;static&quot;
});
</code></pre>
<h5 id="访问器属性："><a href="#访问器属性：" class="headerlink" title="访问器属性："></a>访问器属性：</h5><pre><code class="js">var obj = {
  _year:2001,
  get year() {
    return this._year;
  },
  set year(val){
    this._year = val
  }
}
console.log(obj._year); //2001
console.log(obj.year); //2001
obj.year = &#39;hello&#39;;
console.log(obj._year); // hello
console.log(obj.year); // hello</code></pre>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><h5 id="为什么要事件委托："><a href="#为什么要事件委托：" class="headerlink" title="为什么要事件委托："></a>为什么要事件委托：</h5><ul>
<li>绑定事件越多，浏览器内存占用越大，严重影响性能。</li>
<li>ajax的出现，局部刷新的盛行，导致每次加载完，都要重新绑定事件</li>
<li>部分浏览器移除元素时，绑定的事件并没有被及时移除，导致的内存泄漏，严重影响性能</li>
<li>大部分ajax局部刷新的，只是显示的数据，而操作却是大部分相同的，重复绑定，会导致代码的耦合性过大，严重影响后期的维护。</li>
</ul>
<h5 id="事件委托的简单实现："><a href="#事件委托的简单实现：" class="headerlink" title="事件委托的简单实现："></a>事件委托的简单实现：</h5><pre><code class="js">function _addEvent(obj,type,fn){
    obj.addEventListener(type,fn,false);
}
function _delegate(obj,tag,fn){
    function cb(e){
        var target = e.target || e.srcElement;
        var tags = obj.getElementsByTagName(tag);
        if(tags.length === 0){return;}
        while(e.nodeName.toLowerCase() !== tag){
            target = target.parentNode;
        }
        for(var i = 0; i &lt; tags.length; i++){
            if(tags[i] === target){
                alert(i);
                break;
            }
        }
    }
    _addEvent(obj,&quot;click&quot;,cb);
}</code></pre>
<h5 id="事件委托的缺点："><a href="#事件委托的缺点：" class="headerlink" title="事件委托的缺点："></a>事件委托的缺点：</h5><p>通过jQuery的源码可以获知，事件委托的性能受下面三个因素所影响：</p>
<ul>
<li>DOM遍历的次数</li>
<li>DOM结构的层数</li>
<li>事件委托绑定的个数</li>
</ul>
<h5 id="提高事件委托性能的解决方案："><a href="#提高事件委托性能的解决方案：" class="headerlink" title="提高事件委托性能的解决方案："></a>提高事件委托性能的解决方案：</h5><ul>
<li>降低层级，尽量在父级绑定</li>
<li>减少绑定的次数</li>
</ul>
<h2 id="图片预加载与懒加载"><a href="#图片预加载与懒加载" class="headerlink" title="图片预加载与懒加载"></a>图片预加载与懒加载</h2><h5 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h5><p>######方法一：用CSS和JavaScript实现预加载</p>
<p>使用纯CSS:</p>
<pre><code class="css">background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px; }  </code></pre>
<p>使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。</p>
<pre><code class="js">function preloader() {
    if (document.getElementById) {
        document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(http://domain.tld/image-01.png) no-repeat -9999px -9999px&quot;;
    }
}

function addLoadEvent(func) {
    var oldonload = window.onload;
    if (typeof window.onload != &#39;function&#39;) {
        window.onload = func;
    } else {
        window.onload = function() {
            if (oldonload) {
                oldonload();
            }
            func();
        }
    }
}
addLoadEvent(preloader);</code></pre>
<h6 id="方法二：仅使用JavaScript实现预加载"><a href="#方法二：仅使用JavaScript实现预加载" class="headerlink" title="方法二：仅使用JavaScript实现预加载"></a>方法二：仅使用JavaScript实现预加载</h6><p>上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。</p>
<pre><code class="js">var images = new Array()
function preload() {
    for (i = 0; i &lt; preload.arguments.length; i++) {
        images[i] = new Image()
        images[i].src = preload.arguments[i]
    }
}
preload(
    &quot;http://domain.tld/gallery/image-001.jpg&quot;,
    &quot;http://domain.tld/gallery/image-002.jpg&quot;,
    &quot;http://domain.tld/gallery/image-003.jpg&quot;)</code></pre>
<h6 id="方法三：使用Ajax实现预加载"><a href="#方法三：使用Ajax实现预加载" class="headerlink" title="方法三：使用Ajax实现预加载"></a>方法三：使用Ajax实现预加载</h6><pre><code class="js">window.onload = function() {
setTimeout(function() {
    // XHR to request a JS and a CSS
    var xhr = new XMLHttpRequest();
    xhr.open(&#39;GET&#39;, &#39;http://domain.tld/preload.js&#39;);
    xhr.send(&#39;&#39;);
    xhr = new XMLHttpRequest();
    xhr.open(&#39;GET&#39;, &#39;http://domain.tld/preload.css&#39;);
    xhr.send(&#39;&#39;);
    // preload image
    new Image().src = &quot;http://domain.tld/preload.png&quot;;
}, 1000);
};</code></pre>
<h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5><ul>
<li>第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟。</li>
<li>第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。</li>
<li>第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现。</li>
</ul>
<pre><code class="js">(function($) {
    $.fn.scrollLoading = function(options) {
        var defaults = {
            attr: &quot;data-url&quot;,
            container: $(window),
            callback: $.noop
        };
        var params = $.extend({}, defaults, options || {});
        params.cache = [];
        $(this).each(function() {
            var node = this.nodeName.toLowerCase(), url = $(this).attr(params[&quot;attr&quot;]);
            var data = {
                obj: $(this),
                tag: node,
                url: url
            };
            params.cache.push(data);

        });
        var callback = function(call) {
            if ($.isFunction(params.callback)) {
                params.callback.call(call.get(0));
            }
        };
        var loading = function() {
            var contHeight = params.container.height();
            if ($(window).get(0) === window) {
                contop = $(window).scrollTop();
            } else {
                contop = params.container.offset().top;
            }
            $.each(params.cache, function(i, data) {
                var o = data.obj, tag = data.tag, url = data.url, post, posb;
                if (o) {
                    post = o.offset().top - contop, post + o.height();
                    if (o.is(&#39;:visible&#39;) &amp;&amp; (post &gt;= 0 &amp;&amp; post &lt; contHeight) || (posb &gt; 0 &amp;&amp; posb &lt;= contHeight)) {
                        if (url) {
                            if (tag === &quot;img&quot;) {
                                callback(o.attr(&quot;src&quot;, url));
                            } else {
                                o.load(url, {}, function() {
                                    callback(o);
                                });
                            }
                        } else {
                            callback(o);
                        }
                        data.obj = null;
                    }
                }
            });
        };
        loading();
        params.container.bind(&quot;scroll&quot;, loading);
    };
})(jQuery);</code></pre>
<h2 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h2><ul>
<li>mouseover 事件具有冒泡特性，也就是说无论鼠标是从别的元素移动到element或者是从element的子元素移动到element都会触发mouseover事件。</li>
<li>mouseenter 事件，该事件没有冒泡特性，也就是说只有鼠标穿过该事件的时候才会触发mouseenter</li>
</ul>
<h6 id="mouseover-模拟-mouseenter"><a href="#mouseover-模拟-mouseenter" class="headerlink" title="mouseover 模拟 mouseenter"></a>mouseover 模拟 mouseenter</h6><pre><code class="js">var selector = document.getElementById(&#39;test&#39;);
  selector.addEventListener(&quot;mouseover&quot;, function( event ) {
    var target = event.target,
        related = event.relatedTarget,//触发事件前所在的节点
        match;
    // 通过触发事件节点找到绑定事件节点
    while ( target &amp;&amp; target !== document &amp;&amp; target!== this ) {
        target = target.parentNode;
        if (target === this) {match = true;}
    }
    // 没找到绑定事件的节点
    if ( !match ) { return; }
    // 判断是不是冒泡触发的节点，如果是则related置为target
    while ( related &amp;&amp; related != target &amp;&amp; related != document ) {
        related = related.parentNode;
    }
    // 冒泡触发，也就是子节点触发
    if ( related == target ) { return; }
    //......mouseenter事件代码
  }, false);</code></pre>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><pre><code class="js">function f1(){
    var n = [1,2];
    add = function(){
        n.unshift(0);
        return n;
    }
    function f2(){
        n.push(3);
        return n;
    }
    return f2;
}

var result1 = f1();//拷贝一份
var result2 = f1();//拷贝一份
var result3 = f1();//拷贝一份
var a1 = result1();add();console.log(a1);//[1, 2, 3]
var a2 = result2();add();console.log(a2);//[1, 2, 3]
var a3 = result3();add();console.log(a3);//[0, 0, 0, 1, 2, 3]
var a4 = add();
console.log(a1 === a2);//false
console.log(a2 === a3);//false
console.log(a3 === a4);//true</code></pre>
<h2 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h2><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>使用new命令时，它后面的函数依次执行下面的步骤。</p>
<ul>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的prototype属性。</li>
<li>将这个空对象赋值给函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ul>
<p>实现代码：</p>
<pre><code class="js">function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {
  // 将 arguments 对象转为数组
  var args = [].slice.call(arguments);
  // 取出构造函数
  var constructor = args.shift();
  // 创建一个空对象，继承构造函数的 prototype 属性
  var context = Object.create(constructor.prototype);
  // 执行构造函数
  var result = constructor.apply(context, args);
  // 如果返回结果是对象，就直接返回，否则返回 context 对象
  return (typeof result === &#39;object&#39; &amp;&amp; result != null) ? result : context;
}

// 实例
var actor = _new(Person, &#39;张三&#39;, 28);</code></pre>
<h5 id="保证构造函数使用new"><a href="#保证构造函数使用new" class="headerlink" title="保证构造函数使用new"></a>保证构造函数使用new</h5><h6 id="方法一，严格模式"><a href="#方法一，严格模式" class="headerlink" title="方法一，严格模式"></a>方法一，严格模式</h6><pre><code class="js">function Fubar(foo, bar){
  &#39;use strict&#39;;
  this._foo = foo;
  this._bar = bar;
}
Fubar()
// TypeError: Cannot set property &#39;_foo&#39; of undefined</code></pre>
<h6 id="方法二，new-target"><a href="#方法二，new-target" class="headerlink" title="方法二，new.target"></a>方法二，new.target</h6><pre><code class="js">function f() {
  if (!new.target) {
    throw new Error(&#39;请使用 new 命令调用！&#39;);
  }
  // ...
}
f() // Uncaught Error: 请使用 new 命令调用！</code></pre>
<h2 id="call-、-apply-、bind-的实现"><a href="#call-、-apply-、bind-的实现" class="headerlink" title="call 、 apply 、bind 的实现"></a>call 、 apply 、bind 的实现</h2><h5 id="call-的实现"><a href="#call-的实现" class="headerlink" title="call 的实现"></a>call 的实现</h5><pre><code class="js">if(!Function.prototype.call){
    Function.prototype.call = function(args){
        if (typeof this !== &quot;function&quot;) {
            throw Error(&quot;函数才能调用call方法&quot;);
        }
        //this绑定的指向
        var context = arguments[0];
        //调用call的函数
        var fn = this;
        //call调用时的传参
        var param = Array.prototype.slice.call(arguments,1);
        //创建一个唯一key;
        var key = &#39;fn&#39; + Math.random();
        if (context == undefined) {
            //return eval(&quot;fn(&quot; + param + &quot;)&quot;);
            return fn(...param);
        }else{
            //保证是对象
            context = Object(context);
            //将函数变为context的方法
            context[key] = fn;
            //通过对象方法的形式调用
            //return eval(&quot;context[key](&quot; + param + &quot;)&quot;);
            return context[key](...param);
        }
    }
}</code></pre>
<h5 id="apply-的实现"><a href="#apply-的实现" class="headerlink" title="apply 的实现"></a>apply 的实现</h5><pre><code class="js">if(!Function.prototype.apply){
    Function.prototype.myapply = function(args){
        if (typeof this !== &quot;function&quot;) {
            throw Error(&quot;函数才能调用appy方法&quot;);
        }
        //this绑定的指向
        var context = arguments[0];
        //调用apply的函数
        var fn = this;
        //apply调用时的传参
        var param = arguments[1] instanceof Array ? arguments[1] : [];
        //创建一个唯一key;
        var key = &#39;fn&#39; + Math.random();
        if (context == undefined) {
            //return eval(&quot;fn(&quot; + param + &quot;)&quot;);
            return fn(...param);
        }else{
            //保证是对象
            context = Object(context);
            //将函数变为context的方法
            context[key] = fn;
            //通过对象方法的形式调用
            //return eval(&quot;context[key](&quot; + param + &quot;)&quot;);
            return context[key](...param);
        }
    }
}</code></pre>
<h5 id="bind-的实现"><a href="#bind-的实现" class="headerlink" title="bind 的实现"></a>bind 的实现</h5><pre><code class="js">if (!Function.prototype.bind) {
    Function.prototype.mybind = function(args){
        if (typeof this !== &quot;function&quot;) {
            throw Error(&quot;函数才能调用bind方法&quot;);
        }
        //this绑定的指向
        var context = arguments[0];
        //调用bind的函数
        var fn = this;
        //bind调用时的传参
        var param = Array.prototype.slice.call(arguments,1);
        //返回的函数，等待下一步调用
        var callback = function(){
            //判断callback是直接调用还是new调用
            fn.apply(this instanceof callback ? this : context,
                //合并参数
                param.concat(Array.prototype.slice.call(arguments))
            );
        }
        //维护原型关系
        if (fn.prototype) {
            callback.prototype = Object.create(fn.prototype);
        }
        //返回待调用的函数
        return callback;
    }
}</code></pre>
<h2 id="异步加载js的方法"><a href="#异步加载js的方法" class="headerlink" title="异步加载js的方法"></a>异步加载js的方法</h2><p>defer属性和async属性到底应该使用哪一个？</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。</p>
<p>如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。</p>
<h5 id="defer："><a href="#defer：" class="headerlink" title="defer："></a>defer：</h5><p>有了defer属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在DOMContentLoaded事件触发前执行（即刚刚读取完</html>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>
<p>对于内置而不是加载外部脚本的script标签，以及动态生成的script标签，defer属性不起作用。</p>
<ul>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有defer属性的script元素。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载script元素加载的外部脚本。</li>
<li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li>
</ul>
<h5 id="async"><a href="#async" class="headerlink" title="async:"></a>async:</h5><p>async属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。</p>
<ul>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有async属性的script标签。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载script标签中的外部脚本。</li>
<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li>
<li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li>
</ul>
<h5 id="ES6-模块-type-”module”"><a href="#ES6-模块-type-”module”" class="headerlink" title="ES6 模块(type=”module”)"></a>ES6 模块(type=”module”)</h5><p>浏览器对于带有type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。</p>
<p><code>&lt;script&gt;</code>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<h5 id="动态创建script标签"><a href="#动态创建script标签" class="headerlink" title="动态创建script标签"></a>动态创建script标签</h5><h2 id="Ajax解决浏览器的缓存问题"><a href="#Ajax解决浏览器的缓存问题" class="headerlink" title="Ajax解决浏览器的缓存问题"></a>Ajax解决浏览器的缓存问题</h2><p>Ajax能提高页面载入速度的主要原因是通过Ajax减少了重复数据的载入，也即在载入数据的同时将数据缓存到内存中，一旦数据被加载，只要没有刷新页面，这些数据就会一直被缓存在内存中，当提交的URL与历史的URL一致时，就不需要提交给服务器，也即不需要从服务器获取数据，虽然降低了服务器的负载，提高了用户体验，但不能获取最新的数据。为了保证读取的信息都是最新的，需要禁止其缓存功能。</p>
<ul>
<li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</li>
<li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</li>
<li>在URL后面加上一个随机数： “fresh=” + Math.random()。</li>
<li>在URL后面加上时间搓：”nowtime=” + new Date().getTime()。</li>
<li>如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</li>
</ul>
<h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><h5 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h5><p>根据用户输入信息发请求的时候，为了防止频繁触发请求，需要等待用户最后输入的时候再发送请求，也就是防抖：</p>
<pre><code class="js">function debounce(fn,delay){
    //利用闭包，保留定时器的指引
    var timer = null;
    return function(){
        //每调用一次就取消上一次回调。
        clearTimeout(timer);
        //重新开启定时器，过一段时间后若无操作，则执行回调
        timer = setTimeout(fn,delay)
    }
}
var scroll = debounce(function(){
    console.log(&#39;do something!!!&#39;)
},500)
window.onscroll = scroll;</code></pre>
<h5 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h5><p>当滚动鼠标时，因为滚动事件触发间隔极短，需要限制其在某个时间段内，只执行一次。</p>
<pre><code class="js">function throttle(fn,interval){
    //设定初始时间
    var begin = new Date();
    //定时器指引
    var timer = null;
    return function(){
        //总是清除上一次回调
        clearTimeout(timer);
        //获取当前时间
        var now = new Date();
        //当时间间隔大于设定，执行回调
        if (now - begin &gt; interval) {
            //重置开始时间
            begin = now;
            fn();
        }else{
            timer = setTimeout(function(){
                //若距离上一次触发大于时间间隔，执行一次回调
                begin = now;
                fn();
            },interval)
        }
    }
}
var scroll = throttle(function(){
    console.log(&#39;do something!!!&#39;)
},500)
window.onscroll = scroll;</code></pre>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a><a href="http://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">浏览器缓存</a></h2><p>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；</p>
<p>区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>
<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。</p>
<ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</li>
</ul>
<h6 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h6><p>在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</li>
</ul>
<p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p>
<p>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。</p>
<h5 id="强缓存的管理"><a href="#强缓存的管理" class="headerlink" title="强缓存的管理"></a>强缓存的管理</h5><p>通常有2种方式来设置是否启用强缓存：</p>
<ul>
<li>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li>
<li>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</li>
</ul>
<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。</p>
<h6 id="Last-Modified，If-Modified-Since"><a href="#Last-Modified，If-Modified-Since" class="headerlink" title="Last-Modified，If-Modified-Since"></a>Last-Modified，If-Modified-Since</h6><ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间；</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值；</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</li>
</ul>
<h6 id="ETag、If-None-Match"><a href="#ETag、If-None-Match" class="headerlink" title="ETag、If-None-Match"></a>ETag、If-None-Match</h6><ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系；</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值；</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化；</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
</ul>
<h5 id="协商缓存的管理"><a href="#协商缓存的管理" class="headerlink" title="协商缓存的管理"></a>协商缓存的管理</h5><p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。</p>
<p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p>
<p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</p>
<h5 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h5><ul>
<li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</li>
</ul>
<h2 id="js监听对象属性的改变"><a href="#js监听对象属性的改变" class="headerlink" title="js监听对象属性的改变"></a>js监听对象属性的改变</h2><h5 id="在ES5中可以通过Object-defineProperty来实现已有属性的监听"><a href="#在ES5中可以通过Object-defineProperty来实现已有属性的监听" class="headerlink" title="在ES5中可以通过Object.defineProperty来实现已有属性的监听"></a>在ES5中可以通过Object.defineProperty来实现已有属性的监听</h5><pre><code class="js">Object.defineProperty(user,&#39;name&#39;,{
    set：function(key,value){
    }
})</code></pre>
<p>缺点：如果属性不在user对象中，则不能监听该属性的变化</p>
<h5 id="在ES6中可以通过Proxy来实现"><a href="#在ES6中可以通过Proxy来实现" class="headerlink" title="在ES6中可以通过Proxy来实现"></a>在ES6中可以通过Proxy来实现</h5><pre><code class="js">var  user = new Proxy({}，{
 set：function(target,key,value,receiver){
  }
})</code></pre>
<p>这样即使有属性在user中不存在，通过user.id来定义也同样可以这样监听这个属性的变化。</p>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h2><pre><code class="js">// 特例
Object.is(0, -0);            // false
Object.is(-0, -0);           // true
Object.is(NaN, 0/0);         // true
if (!Object.is) {
  Object.is = function(x, y) {
    if (x === y) {
      // +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // NaN == NaN
      return x !== x &amp;&amp; y !== y;
    }
  };
}</code></pre>
<h2 id="requestAnimationFrame-与-cancelAnimationFrame"><a href="#requestAnimationFrame-与-cancelAnimationFrame" class="headerlink" title="requestAnimationFrame 与 cancelAnimationFrame"></a>requestAnimationFrame 与 cancelAnimationFrame</h2><p>大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms</p>
<p>而setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。</p>
<p>requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p>
<p>特点</p>
<ul>
<li>requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量</li>
<li>requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销</li>
</ul>
<pre><code class="js">var a = 1;
var cb = function(){
    console.log(a++);
    if (a &gt; 100) {
        cancelAnimationFrame(timer);
    }else{
        requestAnimationFrame(cb)
    }
}
var timer = requestAnimationFrame(cb);</code></pre>
<h2 id="用-setTimeout-模拟-setInterval"><a href="#用-setTimeout-模拟-setInterval" class="headerlink" title="用 setTimeout 模拟 setInterval"></a>用 setTimeout 模拟 setInterval</h2><pre><code class="js">function interval(func, wait, times){
    var interv = function(w, t){
        return function(){
            if(typeof t === &quot;undefined&quot; || t-- &gt; 0){
                setTimeout(interv, w);
                try{
                    func.call(null);
                }
                catch(e){
                    t = 0;
                    throw e.toString();
                }
            }
        };
    }(wait, times);
    setTimeout(interv, wait);
};</code></pre>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><ul>
<li>先主线程，后任务队列；</li>
<li>先微任务（promise,nextTick），后宏任务(setTimeout)；</li>
<li>先nextTick，后promise（then）</li>
</ul>
<h2 id="OPTIONS请求方法"><a href="#OPTIONS请求方法" class="headerlink" title="OPTIONS请求方法"></a>OPTIONS请求方法</h2><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<ul>
<li>获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。</li>
<li>用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。</li>
</ul>
<h2 id="click在ios上有300ms延迟，原因及如何解决？"><a href="#click在ios上有300ms延迟，原因及如何解决？" class="headerlink" title="click在ios上有300ms延迟，原因及如何解决？"></a>click在ios上有300ms延迟，原因及如何解决？</h2><ul>
<li><p>粗暴型，禁用缩放</p>
<pre><code class="css">&lt;meta name=&quot;viewport&quot; content=&quot;wid-th=device-width, user-scalable=no&quot;&gt;</code></pre>
</li>
<li><p>利用FastClick，其原理是检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉(preventDefault)</p>
</li>
</ul>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><h5 id="媒體查詢"><a href="#媒體查詢" class="headerlink" title="媒體查詢"></a>媒體查詢</h5><p>略</p>
<h5 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h5><h6 id="子元素height和width的百分比"><a href="#子元素height和width的百分比" class="headerlink" title="子元素height和width的百分比"></a>子元素height和width的百分比</h6><p>子元素的height或width中使用百分比，是相对于子元素的直接父元素，width相对于父元素的width，height相对于父元素的height。</p>
<h6 id="top和bottom-、left和right"><a href="#top和bottom-、left和right" class="headerlink" title="top和bottom 、left和right"></a>top和bottom 、left和right</h6><p>子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度;</p>
<p>同样子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度。</p>
<h6 id="padding-与-margin"><a href="#padding-与-margin" class="headerlink" title="padding 与 margin"></a>padding 与 margin</h6><p>子元素的padding与margin如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。</p>
<h6 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h6><p>border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度。</p>
<h5 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h5><pre><code class="js">(function () {
    var html = document.documentElement;
    function onWindowResize() {
        html.style.fontSize = html.getBoundingClientRect().width / 10 + &#39;px&#39;;
    }
    window.addEventListener(&#39;resize&#39;, onWindowResize);
    onWindowResize();
})();</code></pre>
<h6 id="px2rem"><a href="#px2rem" class="headerlink" title="px2rem"></a>px2rem</h6><p> webpack loader的形式：</p>
<pre><code class="js"> npm install px2rem-loader</code></pre>
<p> 在webpack的配置文件中：</p>
<pre><code class="js"> module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.css$/,
      use: [{
        loader: &#39;style-loader&#39;
      }, {
        loader: &#39;css-loader&#39;
      }, {
        loader: &#39;px2rem-loader&#39;,
        // options here
        options: {
          remUni: 75,
          remPrecision: 8
        }
      }]
    }]
  }</code></pre>
<h6 id="rem-布局的缺点"><a href="#rem-布局的缺点" class="headerlink" title="rem 布局的缺点"></a>rem 布局的缺点</h6><p>在响应式布局中，必须通过js来动态控制根元素font-size的大小。</p>
<h5 id="vw-与-vh"><a href="#vw-与-vh" class="headerlink" title="vw 与 vh"></a>vw 与 vh</h5><p>css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p>
<p>比如对于iphone6/7 375*667的分辨率，那么px可以通过如下方式换算成vw：</p>
<pre><code class="js">1px = （1/375）*100 vw</code></pre>
<h2 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h2><p>CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型。</p>
<h5 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h5><p>在标准的盒子模型中，width指content部分的宽度。（box-sizing：content-box）</p>
<h5 id="IE盒子模型"><a href="#IE盒子模型" class="headerlink" title="IE盒子模型"></a>IE盒子模型</h5><p>在IE盒子模型中，width表示content+padding+border这三个部分的宽度。（box-sizing：border-box）</p>
<h2 id="画0-5px宽的线"><a href="#画0-5px宽的线" class="headerlink" title="画0.5px宽的线"></a>画0.5px宽的线</h2><h5 id="使用SVG"><a href="#使用SVG" class="headerlink" title="使用SVG"></a>使用SVG</h5><pre><code class="css">.hr.svg {
  background: none;
  height: 1px;
  background: url(&quot;data:image/svg+xml;utf-8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;100%&#39; height=&#39;1px&#39;&gt;&lt;line x1=&#39;0&#39; y1=&#39;0&#39; x2=&#39;100%&#39; y2=&#39;0&#39; stroke=&#39;#000&#39;&gt;&lt;/line&gt;&lt;/svg&gt;&quot;);
}</code></pre>
<h5 id="meta-viewport"><a href="#meta-viewport" class="headerlink" title="meta viewport"></a>meta viewport</h5><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-sacle=1&quot;&gt;</code></pre>
<p>scale改成0.5：</p>
<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-sacle=0.5&quot;&gt;</code></pre>
<h5 id="transform-scale"><a href="#transform-scale" class="headerlink" title="transform: scale"></a>transform: scale</h5><pre><code class="css">.hr.scale-half {
  height: 1px;
  transform: scaleY(0.5);
}</code></pre>
<h2 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h2><h5 id="transition-Transform"><a href="#transition-Transform" class="headerlink" title="transition + Transform"></a>transition + Transform</h5><p>强调过渡，两个关键帧</p>
<ul>
<li>transition需要事件触发，所以没法在网页加载时自动发生。</li>
<li>transition是一次性的，不能重复发生，除非一再触发。</li>
<li>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</li>
<li>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</li>
</ul>
<h5 id="animation-keyframes"><a href="#animation-keyframes" class="headerlink" title="animation + @keyframes"></a>animation + @keyframes</h5><p>强调流程与控制，多个关键帧</p>
<ul>
<li>不需要触发，页面一加载就可以开始</li>
<li>通过keyframes控制动画的多种状态</li>
</ul>
<h2 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC(块级格式化上下文)"></a>BFC(块级格式化上下文)</h2><p>块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。</p>
<ul>
<li>BFC区域不会与float box重叠</li>
<li>BFC是页面上的一个独立容器，子元素不会影响到外面</li>
<li>计算BFC的高度时，浮动元素也会参与计算</li>
</ul>
<p>那些元素会生成BFC：</p>
<ul>
<li>根元素</li>
<li>float不为none的元素</li>
<li>position为fixed和absolute的元素</li>
<li>display为inline-block、table-cell、table-caption，flex，inline-flex的元素</li>
<li>overflow不为hidden|auto|scroll的元素</li>
</ul>
<p>BFC</p>
<ul>
<li>不和浮动元素重叠</li>
<li>清除元素内部浮动</li>
<li>防止垂直 margin 重叠（父子或者兄弟元素）</li>
</ul>
<h2 id="单行与多行省略"><a href="#单行与多行省略" class="headerlink" title="单行与多行省略"></a>单行与多行省略</h2><pre><code class="css">p{
    overflow:hidden;
    white-space:nowrap;
    text-overflow:ellipsis;
}

div{
    display: -webkit-box;
    -webkit-box-orient:vertical;
    -webkit-line-clamp:3;
    overflow:hidden;
}</code></pre>
<h2 id="双边距重叠"><a href="#双边距重叠" class="headerlink" title="双边距重叠"></a>双边距重叠</h2><p>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠。</p>
<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和。</li>
</ul>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h6 id="利用对象的属性不能相同（有漏洞，数组值是引用类型时做键值会先调用toString）"><a href="#利用对象的属性不能相同（有漏洞，数组值是引用类型时做键值会先调用toString）" class="headerlink" title="利用对象的属性不能相同（有漏洞，数组值是引用类型时做键值会先调用toString）"></a>利用对象的属性不能相同（有漏洞，数组值是引用类型时做键值会先调用toString）</h6><pre><code class="js">Array.prototype.distinct = function (){
 var arr = this,
  i,
  obj = {},
  result = [],
  len = arr.length;
 for(i = 0; i&lt; arr.length; i++){
  if(!obj[arr[i]]){ //如果能查找到，证明数组元素重复了
   obj[arr[i]] = 1;
   result.push(arr[i]);
  }
 }
 return result;
};
var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,];
var b = a.distinct();</code></pre>
<h6 id="利用indexOf以及forEach"><a href="#利用indexOf以及forEach" class="headerlink" title="利用indexOf以及forEach"></a>利用indexOf以及forEach</h6><h6 id="利用数组sort方法先排序"><a href="#利用数组sort方法先排序" class="headerlink" title="利用数组sort方法先排序"></a>利用数组sort方法先排序</h6><pre><code class="js">Array.prototype.distinct = function(){
 var len = this.length,res = [];
 if(len &lt; 2){ return this;}
 this.sort(); //先排序
 for(var i = 0; i &lt; len - 1; i++){
  if(this[i] !== this[i+1]){
   res.push(this[i]);
  }
 }
 //最后那位不会重复
 res.push(this[this.length-1])
 return res;
}</code></pre>
<h6 id="利用ES6的set"><a href="#利用ES6的set" class="headerlink" title="利用ES6的set"></a>利用ES6的set</h6><pre><code class="js">//利用Array.from将Set结构转换成数组
function dedupe(array){
 return Array.from(new Set(array));
}
dedupe([1,1,2,3]);

//拓展运算符(...)内部使用for...of循环
let arr = [1,2,3,3];
let resultarr = [...new Set(arr)];
console.log(resultarr); //[1,2,3]</code></pre>
<pre><code class="js">Array.prototype.distinct = function (){
 var arr = this,
  result = [],
  len = arr.length;
 arr.forEach(function(v, i ,arr){  //这里利用map，filter方法也可以实现
  var bool = arr.indexOf(v,i+1);  //从传入参数的下一个索引值开始寻找是否存在重复
  if(bool === -1){
   result.push(v);
  }
 })
 return result;
};
var a = [1,1,1,1,1,1,1,2,3,2,3,2,3];
var b = a.distinct();</code></pre>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><pre><code class="js">function swap(arr,i,j){
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

//冒泡排序
function bubbleSort(arr){
    for (var i = arr.length - 1; i &gt; 0; i--) {
        for (var j = 0; j &lt; i; j++) {
            if (arr[j] &gt; arr[j+1]) {
                swap(arr,j,j+1)
            }
        }
    }
    return arr;
}</code></pre>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><pre><code class="js">//选择排序
function selectionSort(arr){
    for (var i = 0; i &lt; arr.length - 1; i++) {
        var index = i;
        for (var j = i + 1; j &lt; arr.length; j++) {
            if (arr[j] &lt; arr[index]) {
                index = j;
            }
        }
        swap(arr,i,index);
    }
    return arr;
}</code></pre>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><pre><code class="js">//插入排序
function insertionSort(arr){
    for (var i = 1; i &lt; arr.length; i++) {
        var temp = arr[i];
        var j = i;
        while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp){
            swap(arr,j,j-1);
            j--;
        }
    }
    return arr;
}</code></pre>
<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><pre><code class="js">//希尔排序
function shellSort(arr){
    var interval = Math.floor(arr.length/2);
    while(interval &gt; 0){
        for (var i = 0; i &lt; interval; i++) {
            for (var j = i + interval; j &lt; arr.length; j = j + interval) {
                var temp = arr[j];
                var index = j;
                while(index &gt; 0 &amp;&amp; arr[index - interval] &gt; temp){
                    swap(arr,index,index - interval);
                    index = index - interval;
                }
            }
        }
        if (interval == 1) {
            return arr;
        }
        interval = Math.floor(interval/3) + 1;
    }
    return arr;
}</code></pre>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><pre><code class="js">//归并排序
function mergeSort(arr){
    if (arr.length &lt; 2) {return;}
    var step = 1;
    var left,right;
    while(step &lt; arr.length){
        left = 0;
        right = step;
        while(right + step &lt;= arr.length) {
            mergeArr(arr,left,left+step,right,right+step);
            left = right + step;
            right = left + step;
        }
        if (right &lt; arr.length) {
            mergeArr(arr,left,left+step,right,arr.length)
        }
        step *= 2;
    }
    return arr;
}

function mergeArr(arr, startLeft, stopLeft, startRight, stopRight){
    var leftArr = new Array(stopLeft - startLeft + 1);
    var rightArr = new Array(stopRight - startRight + 1);
    var k = startLeft;
    for (var i = 0; i &lt; leftArr.length; i++) {
        leftArr[i] = arr[k++];
    }
    k = startRight;
    for (var i = 0; i &lt; rightArr.length; i++) {
        rightArr[i] = arr[k++];
    }
    rightArr[rightArr.length-1] = Infinity; // 哨兵值
    leftArr[leftArr.length-1] = Infinity; // 哨兵值
    var n = 0,m = 0;
    for (var i = startLeft; i &lt; stopRight; i++) {
        if (leftArr[m] &gt; rightArr[n]) {
            arr[i] = rightArr[n++];
        }else{
            arr[i] = leftArr[m++];
        }
    }
}</code></pre>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><pre><code class="js">//快速排序
function qSort(list) {
    if (list.length == 0) {
        return [];
    }
    var lesser = [];
    var greater = [];
    var pivot = list[0];
    for (var i = 1; i &lt; list.length; i++) {
        if (list[i] &lt; pivot) {
            lesser.push(list[i]);
        } else {
            greater.push(list[i]);
        }
    }
    return qSort(lesser).concat(pivot, qSort(greater));
}

//递归型
function recurQuickSort(arr,startIndex,endIndex){
    if (startIndex &gt;= endIndex) {return;}
    var pivotIndex = partition(arr,startIndex,endIndex);
    recurQuickSort(arr,startIndex,pivotIndex);
    recurQuickSort(arr,pivotIndex + 1,endIndex);
    return arr;
}

//非递归型
function  quickSort(arr){
    var stack = [];
    var param = {
        start:0,
        end:arr.length - 1
    }
    stack.push(param);
    while(stack.length &gt; 0){
        var curParam = stack.pop();
        var pivotIndex = partition(arr,curParam.start,curParam.end);
        if (curParam.start &lt; pivotIndex) {
            stack.push({
                start:curParam.start,
                end:pivotIndex
            })
        }
        if (curParam.end &gt; pivotIndex) {
            stack.push({
                start:pivotIndex + 1,
                end:curParam.end
            })
        }
    }
    return arr;
}

//交换左右位置
function partition(arr,startIndex,endIndex){
    var pivot = arr[startIndex];
    var start = startIndex,end = endIndex;
    while(start &lt; end){
        while(start &lt; end){
            if (arr[end] &lt; pivot) {
                break;
            }else{
                end--;
            }
        }
        while(start &lt; end){
            if (arr[start] &gt; pivot) {
                break;
            }else{
                start++;
            }
        }
        swap(arr,start,end);
    }
    swap(arr,startIndex,start);
    return start;
}</code></pre>
<h2 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h2><p>两者都是外部引用 CSS 的方式，但是存在一定的区别：</p>
<ul>
<li>link是XHTML标签，除了能够加载CSS，还可以定义RSS等其他事务；而@import属于CSS范畴，只可以加载CSS。</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后再加载。</li>
<li>link是XHTML标签，无兼容问题；@import则是在CSS2.1提出的，低版本的浏览器不支持</li>
<li>link支持使用Javascript控制DOM改变样式；而@import不支持。</li>
</ul>
<h2 id="css-动画和-js-动画的差异"><a href="#css-动画和-js-动画的差异" class="headerlink" title="css 动画和 js 动画的差异"></a>css 动画和 js 动画的差异</h2><ul>
<li>代码复杂度，js 动画代码相对复杂一些</li>
<li>动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件</li>
<li>动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好</li>
</ul>
<h2 id="javascript-中常见的内存泄露陷阱"><a href="#javascript-中常见的内存泄露陷阱" class="headerlink" title="javascript 中常见的内存泄露陷阱"></a><a href="http://web.jobbole.com/88463/" target="_blank" rel="noopener">javascript 中常见的内存泄露陷阱</a></h2><ul>
<li>意外的全局变量</li>
<li>被遗漏的定时器和回调函数，回调函数中保持着外部变量的引用</li>
<li>js对DOM 的引用，即使该DOM节点被移除，若依然保持着引用，则该DOM节点依然在内存中</li>
<li>闭包</li>
</ul>
<h2 id="babel把ES6转成ES5或者ES3之类的原理"><a href="#babel把ES6转成ES5或者ES3之类的原理" class="headerlink" title="babel把ES6转成ES5或者ES3之类的原理"></a>babel把ES6转成ES5或者ES3之类的原理</h2><p>它就是个编译器，输入语言是ES6+，编译目标语言是ES5。</p>
<ul>
<li>解析：将代码字符串解析成抽象语法树</li>
<li>变换：对抽象语法树进行变换操作</li>
<li>再建：根据变换后的抽象语法树再生成代码字符串</li>
</ul>
<h2 id="前端工程与性能优化"><a href="#前端工程与性能优化" class="headerlink" title="前端工程与性能优化"></a>前端工程与性能优化</h2><table>
<thead>
<tr>
<th>优化方向</th>
<th>优化手段</th>
</tr>
</thead>
<tbody><tr>
<td>请求数量</td>
<td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</td>
</tr>
<tr>
<td>请求带宽</td>
<td>开启GZip，精简JavaScript，移除重复脚本，图像优化</td>
</tr>
<tr>
<td>缓存利用</td>
<td>使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</td>
</tr>
<tr>
<td>页面结构</td>
<td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td>
</tr>
<tr>
<td>代码校验</td>
<td>避免CSS表达式，避免重定向</td>
</tr>
</tbody></table>
<h2 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h2><ul>
<li>CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用</li>
<li>CommonJS 模块是运行时加载，ES6模块是编译时输出接口</li>
<li>ES6输入的模块变量，只是一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错</li>
</ul>
<p>CommonJs所谓值的拷贝类似于对module.exports对象的一个浅拷贝，基本类型值无法被修改，引用类型值则依然保存着对模块的引用，类似闭包。</p>
<p>ES6模块输出的是值的引用，指的是import的对象保存着对模块的作用域的引用，并且该作用域是可以共享的。换句话说ES6模块export唯一一个实例，被所有import的对象共享。</p>
<h5 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h5><p>Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。</p>
<pre><code class="js">// a.js
module.exports = {
  foo: &#39;hello&#39;,
  bar: &#39;world&#39;
};
// 等同于
export default {
  foo: &#39;hello&#39;,
  bar: &#39;world&#39;
};</code></pre>
<h5 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h5><p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</p>
<pre><code class="js">// es.js
export let foo = { bar:&#39;my-default&#39; };
export { foo as bar };
export function f() {};
export class c {};

// cjs.js
const es_namespace = await import(&#39;./es&#39;);
// es_namespace = {
//   get foo() {return foo;}
//   get bar() {return foo;}
//   get f() {return f;}
//   get c() {return c;}
// }</code></pre>
<h2 id="浅拷贝和深拷贝的问题"><a href="#浅拷贝和深拷贝的问题" class="headerlink" title="浅拷贝和深拷贝的问题"></a>浅拷贝和深拷贝的问题</h2><ul>
<li>深拷贝和浅拷贝是只针对Object和Array这样的复杂类型的</li>
<li>也就是说a和b指向了同一块内存，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</li>
<li>浅拷贝， ”Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象</li>
<li>深拷贝，JSON.parse()和JSON.stringify()给了我们一个基本的解决办法。但是函数不能被正确处理</li>
</ul>
<pre><code class="js">//深拷贝
function clone(Obj) {
    var buf;
    if (Obj instanceof Array) {
        buf = [];  // 创建一个空的数组
        var i = Obj.length;
        while (i--) {
            buf[i] = clone(Obj[i]);
        }
        return buf;
    } else if (Obj instanceof Object){
        buf = {};  // 创建一个空对象
        for (var k in Obj) {  // 为这个对象添加新的属性
            buf[k] = clone(Obj[k]);
        }
        return buf;
    }else{
        return Obj;
    }
}</code></pre>
<h2 id="http-与-https"><a href="#http-与-https" class="headerlink" title="http 与 https"></a>http 与 https</h2><h5 id="http的不足："><a href="#http的不足：" class="headerlink" title="http的不足："></a>http的不足：</h5><ul>
<li>通信使用明文，可能会被窃听</li>
<li>不验证通信方的身份，可能遭遇伪装</li>
<li>无法证明报文的完整性，可能遭遇篡改</li>
</ul>
<h5 id="何为https"><a href="#何为https" class="headerlink" title="何为https?"></a>何为https?</h5><p><strong>http + 加密 + 验证 + 完整性保护 = https</strong></p>
<h5 id="https的原理"><a href="#https的原理" class="headerlink" title="https的原理"></a>https的原理</h5><p>https并非应用层上一种新的协议，而是http通信接口部分用SSL（Secure Socket Layer，安全套接层）和TLS（Transport Layer Security，传输安全协议）协议代替。</p>
<p>通常情况下，http与TCP直接通信，当使用SSL时，就演变层先跟SSL通信，再由SSL与TCP通信。</p>
<p>所谓的https，也就是身披SSL协议外壳的http。</p>
<h5 id="SSL如何加密？"><a href="#SSL如何加密？" class="headerlink" title="SSL如何加密？"></a>SSL如何加密？</h5><p>SSL使用的是一种公开密钥加密（Public-key cryptography）的加密方式。</p>
<p>加密方法中，加密算法是公开的，密钥是保密的，加密跟解密都需要用到密钥。</p>
<h6 id="共享密钥加密（Common-key-cryto-system）"><a href="#共享密钥加密（Common-key-cryto-system）" class="headerlink" title="共享密钥加密（Common key cryto system）"></a>共享密钥加密（Common key cryto system）</h6><p>加密与解密使用同一个密钥，也被称为对称密钥加密。</p>
<p>不足：密钥能够安全发送，信息也能安全发送。</p>
<h6 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h6><p>公开密钥加密使用一对非对称的密钥，一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。</p>
<p>发送密文的一方使用公开密钥加密，对方收到信息之后，再使用私有密钥解密。</p>
<h5 id="https使用混合加密机制"><a href="#https使用混合加密机制" class="headerlink" title="https使用混合加密机制"></a>https使用混合加密机制</h5><p>公开密钥加密与共享密钥加密相比，其处理速度要慢，所以需要利用其各自的优势。</p>
<p>在交换密钥阶段使用公开密钥加密的方式，之后建立通信交换报文阶段则使用共享密钥加密的方式。</p>
<h5 id="公开密钥的可靠性证明"><a href="#公开密钥的可靠性证明" class="headerlink" title="公开密钥的可靠性证明"></a>公开密钥的可靠性证明</h5><p>解决方法是，使用数据证书认证机构（CA,Certificate Authority）和其相关机构颁布的公开密钥证书。</p>
<ul>
<li>提出公开密钥申请</li>
<li>数字证书认证机构对公开密钥做数字签名，颁发公钥证书</li>
<li>服务器发送公钥证书给客户端，进行公开密钥加密通信</li>
<li>客户端使用内置的数据证书认证机构的公开密钥，对公钥证书的数字签名进行认证。</li>
</ul>
<p>数据证书认证机构的公开密钥必须安全的转交给客户端，使用通信方式进行安全转交是一件非常困难的事情，所以，浏览器发布时，一般会事先植入认证机构的公开密钥。</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<ul>
<li>第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN-SEND状态，等待服务器B确认。</li>
<li>第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN-RECV状态。</li>
<li>第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<p>完成三次握手，客户端与服务器开始传送数据。</p>
<p>LISTEN - 侦听来自远方TCP端口的连接请求；<br>SYN-SENT -在发送连接请求后等待匹配的连接请求；<br>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；<br>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<ul>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ul>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>“信道复用技术”实现了，在同一条线路上，单位时间内可供X台计算机同时通信。</p>
<p>一个TCP协议连接其实就是在物理线路上创建的一条“虚拟信道”。这条“虚拟信道”建立后，在TCP协议发出FIN包之前（两个终端都会向对方发送一个FIN包），是不会释放的。正因为这一点，TCP协议被称为面向连接的协议！</p>
<p>UDP协议，一样会在物理线路上创建一条“虚拟信道”，否则UDP协议无法传输数据！但是，当UDP协议传完数据后，这条“虚拟信道”就被立即注销了！因此，称UDP是不面向连接的协议！</p>
<ul>
<li>TCP协议提供了可靠的数据传输,但是其拥塞控制、数据校验、重传机制的网络开销很大,不适合实时通信。</li>
<li>UDP 协议是无连接的数据传输协议并且无重传机制,会发生丢包、收到重复包、乱序等情况。而对于数据精确性要求不高的状态数据以及视频数据,丢包的影响不大。</li>
</ul>
<p>基于TCP的应用层协议有：SMTP、TELNET、HTTP、FTP；</p>
<p>基于UDP的应用层协议：DNS、TFTP（简单文件传输协议）、RIP（路由选择协议）、DHCP、BOOTP（是DHCP的前身）、IGMP（Internet组管理协议）</p>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><pre><code class="js">function curry(fn){
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return fn.apply(null, finalArgs);
    };
}</code></pre>
<h2 id="原生Ajax书写"><a href="#原生Ajax书写" class="headerlink" title="原生Ajax书写"></a>原生Ajax书写</h2><pre><code class="js">function createXHR(){
    if (typeof XMLHttpRequest != &quot;undefined&quot;){
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != &quot;undefined&quot;){
        var versions = [ &quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],
        i, len,xml;
        for (i=0,len=versions.length; i &lt; len; i++){
            try {
                xml = new ActiveXObject(versions[i]);
                break;
            } catch (ex){//跳过
            }
        }
        return xml;
    } else {
        throw new Error(&quot;No XHR object available.&quot;);
    }
}
var xhr = createXHR();
xhr.onreadystatechange = function(){
    // 通信成功时，状态值为4
    if (xhr.readyState === 4){
          if (xhr.status === 200){
              console.log(xhr.responseText);
          } else {
              console.error(xhr.statusText);
          }
    }
};
xhr.onerror = function (e) {
    console.error(xhr.statusText);
};
xhr.open(&#39;GET&#39;, &#39;/endpoint&#39;, true);
xhr.send(null);</code></pre>
<h2 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h2><p>WebSocket protocol 是HTML5一种新的协议。它是实现了浏览器与服务器全双工通信(full-duplex)。HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽并达到实时通讯。</p>
<p>在WebSocket出现之前，一般通过两种方式来实现Web实时用：轮询机制和流技术；其中轮询有不同的轮询，还有一种叫Comet的长轮询。</p>
<ul>
<li>轮询：这是最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的同步。这种同步方案的缺点是，当客户端以固定频率向服务器发起请求的时候，服务器端的数据可能并没有更新，这样会带来很多<strong>无谓的网络传输</strong>，所以这是一种非常低效的实时方案。</li>
<li>长轮询：是对定时轮询的改进和提高，目地是为了降低无效的网络传输。当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互。当然，如果服务端的数据变更非常频繁的话，这种机制和定时轮询比较起来没有本质上的性能的提高。</li>
<li>流：常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个<strong>长连接的请求</strong>。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务 器端的连接不过期。通过这种机制可以将服务器端的信息源源不断地推向客户端。这种机制在用户体验上有一点问题，需要针对不同的浏览器设计不同的方案来改进 用户体验，同时这种机制在并发比较大的情况下，对服务器端的资源是一个极大的考验。</li>
</ul>
<p>WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
<h2 id="浏览器兼容性问题"><a href="#浏览器兼容性问题" class="headerlink" title="浏览器兼容性问题"></a>浏览器兼容性问题</h2><h5 id="CSS常见兼容性问题"><a href="#CSS常见兼容性问题" class="headerlink" title="CSS常见兼容性问题"></a>CSS常见兼容性问题</h5><pre><code class="js">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
//如果当前IE浏览器安装了Google Chrome Frame(GCF)插件，则以chrome内核渲染页面，否则就以当前IE浏览器支持的最高版本模式来渲染</code></pre>
<pre><code class="js">//rgba不支持IE8及以下 解决：用opacity或者filter
background: rgba(255,255,255,0.1);
filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#19ffffff,endColorstr=#19ffffff);</code></pre>
<pre><code class="js">//transition不支持IE10及以下 解决：用js实现过渡动画</code></pre>
<pre><code class="js">//background-size不支持IE8，可以用img
background: url(img/aaa.jpg) no-repeat center center;
background-size: 100% 100%;
/*针对IE8的hack，目的是除掉之前background*/
background: none\9;
/*下一行为关键设置*/
filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#39;img/aaa.jpg&#39;, sizingMethod=&#39;scale&#39;);
/*
原理：
filter : progid:DXImageTransform.Microsoft.AlphaImageLoader ( enabled=bEnabled , sizingMethod=sSize , src=sURL )
enabled：可选项。布尔值(Boolean)。设置或检索滤镜是否激活。 true：默认值。滤镜激活。 false：滤镜被禁止。
sizingMethod：可选项。字符串(String)。设置或检索滤镜作用的对象的图片在对象容器边界内的显示方式。 crop：剪切图片以适应对象尺寸。 image：默认值。增大或减小对象的尺寸边界以适应图片的尺寸。 scale：缩放图片以适应对象的尺寸边界。
src：必选项。字符串(String)。使用绝对或相对 url 地址指定背景图像。假如忽略此参数，滤镜将不会作用。
*/</code></pre>
<pre><code class="js">//使用PIE.htc让IE6/7/8支持CSS3部分属性，像CSS3的border-radius，box-shadow，css backgrounds(-pie-background),Gradients,RGBA属性
div{
    border-radius: 10px;
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    background: #abcdef;
    behavior: url(css/PIE.htc);
}</code></pre>
<pre><code class="js">//用css hack
IE6: _
IE7/7: *
IE7/Firefox: !important
IE7: *+
IE6/7/8: 9
IE8:</code></pre>
<pre><code class="js">//按钮button添加type属性，IE下的默认类型是button，其他浏览器下的默认类型是submit</code></pre>
<pre><code class="js">//识别HTML5元素，IE9以下可能无法识别nav/footer，使用html5shiv
//有一点需要注意，在页面中调用html5shiv.js文件必须添加在页面的head元素内，因为IE浏览器必须在元素解析前知道这个元素
&lt;!--[if lt IE 9]&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/html5shiv.js&quot;&gt;&lt;/script&gt;
&lt;![endif]--&gt;</code></pre>
<h5 id="JS常见兼容性问题"><a href="#JS常见兼容性问题" class="headerlink" title="JS常见兼容性问题"></a>JS常见兼容性问题</h5><pre><code class="js">//解决 IE8 不支持console
window.console = window.console || (function () {
    var c = {}; c.log = c.warn = c.debug = c.info = c.error = c.time = c.dir = c.profile
    = c.clear = c.exception = c.trace = c.assert = function () { };
    return c;
})();</code></pre>
<pre><code class="js">//W3C标准规定，事件对象是作为函数的参数传入的，唯独在IE下是行不通的，IE采用了一种非标准的方式，将事件对象作为window对象的event属性。
document.onclick = function(ev){
    ev = ev || window.event;
}</code></pre>
<pre><code class="js">/*
IE6/7/8：
对于没有doctype声明的页面里可以使用  document.body.scrollTop 来获取 scrollTop高度;
对于有doctype声明的页面则可以使用 document.documentElement.scrollTop；

Safari:
safari 比较特别，有自己获取scrollTop的函数 ： window.pageYOffset ；
*/
var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;</code></pre>
<pre><code class="js">//new date() 注意兼容性问题
//对默认的日期格式进行转换， 基于&#39;/&#39;格式的日期字符串，才是被各个浏览器所广泛支持的，‘-’连接的日期字符串，则是只在chrome下可以正常工作。
var time= new Date(Date.parse(timeStr.replace(/-/g,&quot;/&quot;))).getTime();</code></pre>
<pre><code class="js">//attachEvent与addEventlistener兼容性
var EventUtil = {
    addHandler : function(element,type,handler){
        if(element.addEventListener){
            element.addEventListener(type,handler,false);
        }else if(element.attachEvent){
            element.attachEvent(&#39;on&#39; + type,handler);
        }else{
            element[&#39;on&#39; + type] = handler;
        }
    },
    removeHandler : function(element,type,handler){
        if(element.removeEventListener){
            element.removeEventListener(type,handler,false);
        }else if(element.detachEvent){
            element.detachEvent(&#39;on&#39; + type,handler);
        }else{
            element[&#39;on&#39; + type] = null;
        }
    }
}</code></pre>
<pre><code class="js">//window.getComputedStyle能够获取元素的实际样式，但是低版本的ie8及以下不支持
//获取当前样式
function getStyle(element, attr){
    if(window.getComputedStyle){
        //优先使用W3C规范
        return window.getComputedStyle(element)[attr];
    }else{
        //针对IE9以下兼容
        return element.currentStyle[attr];
    }
}</code></pre>
<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>方法一：</p>
<pre><code class="css">#container{
    position:relative;
}
#center{
    width:100px;
    height:100px;
    position:absolute;
    top:50%;
    left:50%;
    transform: translate(-50%,-50%);
}</code></pre>
<p>方法二：</p>
<pre><code class="css">#container{
    position:relative;
}
#center{
    position:absolute;
    margin:auto;
    top:0;
    bottom:0;
    left:0;
    right:0;
}</code></pre>
<p>方法三：</p>
<pre><code class="css">#container{
    display:flex;
    justify-content:center;
    align-items: center;
}</code></pre>
<h2 id="ES5继承与Class继承的区别"><a href="#ES5继承与Class继承的区别" class="headerlink" title="ES5继承与Class继承的区别"></a>ES5继承与Class继承的区别</h2><p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。</p>
<p>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>在编写 JavaScript 程序时，开发人员无需关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了<strong>自动管理</strong>。</p>
<p>这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），<strong>周期性</strong>地执行这一操作。</p>
<h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p>
<h2 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认,设置合理的行间距。</td>
</tr>
<tr>
<td>number</td>
<td>设置数字，此数字会与当前的字体尺寸相乘来设置行间距。相当于倍数</td>
</tr>
<tr>
<td>length</td>
<td>设置固定的行间距。</td>
</tr>
<tr>
<td>%</td>
<td>基于当前字体尺寸的百分比行间距。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 line-height 属性的值。</td>
</tr>
</tbody></table>
<pre><code class="css">&lt;div style=&quot;border:dashed 1px #0e0;line-height: 150%;font-size:10px;&quot;&gt;
    &lt;p style=&quot;font-size:30px;&quot;&gt;
        1232&lt;br/&gt;
        123
    &lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>如果父元素的line-height<strong>有单位（px、%）</strong>,那么继承的值则是换算后的一个具体的px级别的值；上例p得到的是10px*150%=15px的行高，而P的字体大小为30px，所以发生了重叠。</p>
<p>而如果属性值没有单位，则浏览器会直接继承这个“因子（数值）”，而非计算后的具体值，此时它的line-height会根据本身的font-size值重新计算得到新的line-height 值。</p>
<h2 id="标准盒子模型和IE模型的区别"><a href="#标准盒子模型和IE模型的区别" class="headerlink" title="标准盒子模型和IE模型的区别"></a>标准盒子模型和IE模型的区别</h2><h5 id="标准盒子模型-1"><a href="#标准盒子模型-1" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h5><p>标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。</p>
<p>w3c中的盒子模型的宽:包括margin+border+padding+width;</p>
<pre><code class="css">width:margin*2+border*2+padding*2+width;
height:margin*2+border*2+padding*2+height;</code></pre>
<h5 id="IE-盒子模型"><a href="#IE-盒子模型" class="headerlink" title="IE 盒子模型"></a>IE 盒子模型</h5><p>iE中的盒子模型的width:也包括margin+border+padding+width;</p>
<p>上面的两个宽度相加的属性是一样的。不过在ie中content的宽度包括padding和border这两个属性；</p>
<h2 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><h5 id="新特性："><a href="#新特性：" class="headerlink" title="新特性："></a>新特性：</h5><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<pre><code>1. 拖拽释放(Drag and drop) API
2. 语义化更好的内容标签（header,nav,footer,aside,article,section）
3. 音频、视频API(audio,video)
4. 画布(Canvas) API
5. 地理(Geolocation) API
6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
7. sessionStorage 的数据在浏览器关闭后自动删除
8. 表单控件，calendar、date、time、email、url、search
9. 新的技术webworker, websocket, Geolocation</code></pre><p>移除的元素：</p>
<ol>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ol>
<h5 id="支持HTML5新标签："><a href="#支持HTML5新标签：" class="headerlink" title="支持HTML5新标签："></a>支持HTML5新标签：</h5><p>IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）：</p>
<pre><code class="html">&lt;!--[if lt IE 9]&gt;
&lt;script&gt; src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; 
&lt;![endif]--&gt;</code></pre>
<p>如何区分：<br>DOCTYPE声明新增的结构元素、功能元素</p>
<h2 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h2><pre><code>1. CSS3实现圆角（border-radius），阴影（box-shadow），
2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
3. transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜
4. 增加了更多的CSS选择器  多背景 rgba
5. 在CSS3中唯一引入的伪类是 ::selection.
6. 媒体查询，多栏布局
7. border-image</code></pre><h2 id="iframe的优缺点？"><a href="#iframe的优缺点？" class="headerlink" title="iframe的优缺点？"></a>iframe的优缺点？</h2><p>优点：</p>
<pre><code>1. 解决加载缓慢的第三方内容如图标和广告等的加载问题
2. Security sandbox
3. 并行加载脚本</code></pre><p>缺点：</p>
<pre><code>1. iframe会阻塞主页面的Onload事件
2. 即时内容为空，加载也需要时间
3. 没有语意</code></pre><h2 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><ul>
<li><code>&lt;!DOCTYPE&gt;</code>声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器以何种模式来渲染文档。</li>
<li>严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。</li>
<li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</li>
<li>DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</li>
</ul>
<h2 id="什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h2><p><strong>FOUC - Flash Of Unstyled Content</strong> 文档样式闪烁<style type="text/css" media="all">@import “../fouc.css”;</style> 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</p>
<p>解决方法简单的出奇，只要在<code>&lt;head&gt;</code>之间加入一个<code>&lt;link&gt;</code>或者<code>&lt;script&gt;</code>元素就可以了。</p>
<h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><ol>
<li>当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。</li>
<li>浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</li>
<li>一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。</li>
<li>此时，Web 服务器提供资源服务，客户端开始下载资源。</li>
</ol>
<p>请求返回后，便进入了我们关注的前端模块<br>简单来说，浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM</p>
<h2 id="js-操作获取和设置-cookie"><a href="#js-操作获取和设置-cookie" class="headerlink" title="js 操作获取和设置 cookie"></a>js 操作获取和设置 cookie</h2><pre><code class="js">// 创建cookie
function setCookie(name, value, expires, path, domain, secure) {
    var cookieText = encodeURIComponent(name) + &#39;=&#39; + encodeURIComponent(value);
    if (expires instanceof Date) {
        cookieText += &#39;; expires=&#39; + expires;
    }
    if (path) {
        cookieText += &quot;; path=&quot; + path
    }
    if (domain) {
        cookieText += &#39;; domain=&#39; + domain;
    }
    if (secure) {
        cookieText += &#39;; secure&#39;;
    }
    document.cookie = cookieText;
}
// 获取cookie
function getCookie(name) {
    var cookieName = encodeURIComponent(name) + &#39;=&#39;;
    var cookieStart = document.cookie.indexOf(cookieName);
    var cookieValue = null;
    if (cookieStart &gt; -1) {
        var cookieEnd = document.cookie.indexOf(&#39;;&#39;, cookieStart);
        if (cookieEnd == -1) {
            cookieEnd = document.cookie.length;
        }
        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));
    }
    return cookieValue;
}
// 删除cookie
function unsetCookie(name) {
    document.cookie = name + &quot;= ; expires=&quot; + new Date(0);
}</code></pre>
<h2 id="可继承的CSS属性"><a href="#可继承的CSS属性" class="headerlink" title="可继承的CSS属性"></a>可继承的CSS属性</h2><p>1、字体系列属性<br>font：组合字体<br>font-family：规定元素的字体系列<br>font-weight：设置字体的粗细<br>font-size：设置字体的尺寸<br>font-style：定义字体的风格</p>
<p>2、文本系列属性<br>text-indent：文本缩进<br>text-align：文本水平对齐<br>line-height：行高<br>color：文本颜色</p>
<p>3、元素可见性：visibility</p>
<p>4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout</p>
<p>5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style</p>
<p>6、生成内容属性：quotes</p>
<p>7、光标属性：cursor</p>
<p>8、页面样式属性：page、page-break-inside、windows、orphans</p>
<p>9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation</p>
<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

<p>body .markdown-body<br>{<br>  padding: 45px;<br>}</p>
<p>@font-face {<br>  font-family: fontawesome-mini;<br>  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAABE0AA8AAAAAHWwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY3d1HZY21hcAAAAdgAAACqAAACOvWLi0FjdnQgAAAChAAAABMAAAAgBtX/BGZwZ20AAAKYAAAFkAAAC3CKkZBZZ2FzcAAACCgAAAAIAAAACAAAABBnbHlmAAAIMAAABdQAAAjkYT9TNWhlYWQAAA4EAAAAMwAAADYQ6WvNaGhlYQAADjgAAAAfAAAAJAc6A1pobXR4AAAOWAAAACAAAAA0Kmz/7mxvY2EAAA54AAAAHAAAABwQPBJubWF4cAAADpQAAAAgAAAAIAEHC/NuYW1lAAAOtAAAAYQAAALxhQT4h3Bvc3QAABA4AAAAfgAAAMS3SYh9cHJlcAAAELgAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZHZmnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4Pwz+yMwf9z2KIYg5imAYUZgTJAQDcoQvQAHic7ZHNDYJAFIRnBXf94cDRIiyCKkCpwFCPJ092RcKNDoYKcN4+EmMPvpdvk539zQyAPYBCXEUJhBcCrJ5SQ9YLnLJe4qF5rdb+uWPDngNHTkta101pNyWa8lMhn6xx2dqUnW4q9YOIhAOOeueMSgsR/6ry+P7O5s6xVNg4chBsHUuFnWNJ8uZYwrw7chrsHXkODo7cB0dHOYCTY8kv0VE2WJKD6gOlWjsxAAB4nGNgQAMSEMgc9D8LhAESbAPdAHicrVZpd9NGFB15SZyELCULLWphxMRpsEYmbMGACUGyYyBdnK2VoIsUO+m+8Ynf4F/zZNpz6Dd+Wu8bLySQtOdwmpOjd+fN1czbZRJaktgL65GUmy/F1NYmjew8CemGTctRfCg7eyFlisnfBVEQrZbatx2HREQiULWusEQQ+x5ZmmR86FFGy7akV03KLT3pLlvjQb1V334aOsqxO6GkZjN0aD2yJVUYVaJIpj1S0qZlqPorSSu8v8LMV81QwohOImm8GcbQSN4bZ7TKaDW24yiKbLLcKFIkmuFBFHmU1RLn5IoJDMoHzZDyyqcR5cP8iKzYo5xWsEu20/y+L3mndzk/sV9vUbbkQB/Ijuzg7HQlX4RbW2HctJPtKFQRdtd3QmzZ7FT/Zo/ymkYDtysyvdCMYKl8hRArP6HM/iFZLZxP+ZJHo1qykRNB62VO7Es+gdbjiClxzRhZ0N3RCRHU/ZIzDPaYPh788d4plgsTAngcy3pHJZwIEylhczRJ2jByYCVliyqp9a6YOOV1WsRbwn7t2tGXzmjjUHdiPFsPHVs5UcnxaFKnmUyd2knNoykNopR0JnjMrwMoP6JJXm1jNYmVR9M4ZsaERCICLdxLU0EsO7GkKQTNoxm9uRumuXYtWqTJA/Xco/f05la4udNT2g70s0Z/VqdiOtgL0+lp5C/xadrlIkXp+ukZfkziQdYCMpEtNsOUgwdv/Q7Sy9eWHIXXBtju7fMrqH3WRPCkAfsb0B5P1SkJTIWYVYhWQGKta1mWydWsFqnI1HdDmla+rNMEinIcF8e+jHH9XzMzlpgSvt+J07MjLj1z7UsI0xx8m3U9mtepxXIBcWZ5TqdZlu/rNMfyA53mWZ7X6QhLW6ejLD/UaYHlRzodY3lBC5p038GQizDkAg6QMISlA0NYXoIhLBUMYbkIQ1gWYQjLJRjC8mMYwnIZhrC8rGXV1FNJ49qZWAZsQmBijh65zEXlaiq5VEK7aFRqQ54SbpVUFM+qf2WgXjzyhjmwFkiXyJpfMc6Vj0bl+NYVLW8aO1fAsepvH472OfFS1ouFPwX/1dZUJb1izcOTq/Abhp5sJ6o2qXh0TZfPVT26/l9UVFgL9BtIhVgoyrJscGcihI86nYZqoJVDzGzMPLTrdcuan8P9NzFCFlD9+DcUGgvcg05ZSVnt4KzV19uy3DuDcjgTLEkxN/P6VvgiI7PSfpFZyp6PfB5wBYxKZdhqA60VvNknMQ+Z3iTPBHFbUTZI2tjOBIkNHPOAefOdBCZh6qoN5E7hhg34BWFuwXknXKJ6oyyH7kXs8yik/Fun4kT2qGiMwLPZG2Gv70LKb3EMJDT5pX4MVBWhqRg1FdA0Um6oBl/G2bptQsYO9CMqdsOyrOLDxxb3lZJtGYR8pIjVo6Of1l6iTqrcfmYUl++dvgXBIDUxf3vfdHGQyrtayTJHbQNTtxqVU9eaQ+NVh+rmUfW94+wTOWuabronHnpf06rbwcVcLLD2bQ7SUiYX1PVhhQ2iy8WlUOplNEnvuAcYFhjQ71CKjf+r+th8nitVhdFxJN9O1LfR52AM/A/Yf0f1A9D3Y+hyDS7P95oTn2704WyZrqIX66foNzBrrblZugbc0HQD4iFHrY64yg18pwZxeqS5HOkh4GPdFeIBwCaAxeAT3bWM5lMAo/mMOT7A58xh0GQOgy3mMNhmzhrADnMY7DKHwR5zGHzBnHWAL5nDIGQOg4g5DJ4wJwB4yhwGXzGHwdfMYfANc+4DfMscBjFzGCTMYbCv6dYwzC1e0F2gtkFVoANTT1jcw+JQU2XI/o4Xhv29Qcz+wSCm/qjp9pD6Ey8M9WeDmPqLQUz9VdOdIfU3Xhjq7wYx9Q+DmPpMvxjLZQa/jHyXCgeUXWw+5++J9w/bxUC5AAEAAf//AA94nIVVX2hbZRQ/5/t7893s5ja9f7ouzdZ0TTqz3bRJmogbWya6bG6Cq0VbSV2ddIJjFtfIQHEig80Hda8yUN/0YQz8AyriiyD+xQd92R4HCnaCb3samnpumrpsCsLlfPf7zvedc37nL3CAtc/5W/wQZGA3tOBSY/g+TMjHmwzEoM1Q8+ZjRZY4oJhmBw5/YB6Za0yC5AkhlwA1A1yCBIBOwCII0Cj0U8BAMdUCzq05sKwkP7SlUY6fcJk4Fb/RyE79/6P5hjM/F4aZiXBoeMgzcqQ4Xi1hPqfDLG5FT+lchCVU3lYMyvuwhl1mqndQL0RsuloLywHtthLXI06OblTrhfWVnpSJ5+mwu/JdbtuN3IAnkW0LLMcRwaC7ktrlzridM6kVdyf9uO1UNBByI7JhwtG2sEwab07ORBeilWhqavJCqV0qzZTOl/7ZXQ5TbTcdcFelyGhhRDAQpdqp1FEX3w3cFTc1k9pJQkmm4ySCbSikxRP2QOfN+0tHS5MrpQuTU1Mk5nw0E5Xa0WvrOwDyGax9yB9ma6DAg82wHc43SAGTI4GjBWebOePAERFE8/AHaQpZASSTy8A4WwZiLQMQ82mFKATO0ILicRAoDm9p5P99E5b/fXG+kQYY3TYUuqmERWYoT0u/GNYL2q/4WB3LaVS+VynXsVYIcWw6DkCh3nX1D+VzlYN4LClF5yexSQos8exqZ3KVP+wtrC54u4Nznq6cq+xpMpUUnZ8FUYzE86ud0g28NOIv3Gj5/rmA3ABs7S/ywzFuQ4qyd6QxfNtiQIaEgp3w/entQg4Vcbqa16M5FfpeUB8t1+qeg7mI7cUyOe79wOk86gSxkVec4KPTX69++5x68Yubn5/F+w52z7u08sJX7fZXv8ekT/d2mILJxq6sn+SC6qEJknzLJCxyZEKwWVqYmAPBxBE/9DLeZiWHu7lcr/VytrCRuHojncNuTt9h46tmacmYisnSamdN2bZptcsmSysdVsy1PrOvOzF3xN64Rb937t/og9KHxYdcjIUqFAmIAHGHNzlns+RTPgeUYAQm9DwpNxfxbhhBHPaw3/gfTcXO2L+eJVIx5nsyGkvm9X4/f+bGkH45G0PaSjcMXTjcZyTvi3UdHoCDjQd3IDUVsgwYmUoJK/gp4JJxeRI0MKHZIkgynyIBqBTOUs6rOVCojvjZ4mCQz49ZMlMcp8QoYk6NoBfsxnJtsBohpa8iGJS+ZH7gU7NxME6cmF+t7cO9vB8d3jTWSct0ycW9ranXmolNDwmVkNnxe+8JtoztwS5rKJ0xWS95tQ/1zMYzg69MzUZnNtl1ofNbsml/OJm6f9wjRjpnu2o4MzHzn77IQkRd+1DjwMQ2pqSjGMMhyjrgTbBAKksuUm0iU7hI0aN2wOKOq7WYBSH0HGihj/jkiPxAfmwsEbfYrjMG+j3ij932Db/LV7I/xruNrhnroxjR9HRMb2nTvO0ZXOoHPk8H2ZhDPx93qcE/53sH5np/dkIP7zzhTVKdR/BAY/9ElkkR+A6lJGsqpJ4oQcTxpvBT3Kn58VkaJjgHyPEIws57xkaHh9KuVpDEpJZeMbZ5w/zBHi5NMQ4r5VphsFqID7TyB9eR4pX216c3AHxpdAwoqU9qg0ZJ6yVLKmMSz1iG2z27ifx18NkY0LPx1W/wCc2l5LrznrIsiKsqbmB78A9wIGx4tI8rjihVHJyY9pgMirenVq0yWg7Iw7eogG7ZgYM3qR9959A/fZkg6MnD/exlkmc+jWV4SB15XUR+eqC6l6ZmgPtN9z5JMfik05OV8ljylunJ4J+wA/FUaQSSKotsYsCWqaPBidBLcxkWx7XKFRIb45TGaEhjlF9uUVPqXOtcIwsXbBvfoZXIyRYFdkfnqjExH98xpnPczqzjX/uNdO1Y17Wpi5+6Ts8BXtjVFasp9KZ1mOiNbH65c5w6HgmyF2jFCZywM8mWjRc7T5Pmt0lRy7Y71+jYbpGyvwG4sH0XeJxjYGRgYADiwBB/53h+m68M3MwvgCIM1z5N/g6j///9v5H5BbMnkMvBwAQSBQCIcA9gAHicY2BkYGAO+p8FJF/8//v/F/MLBqAICuAFALYQB5kAeJxjfsHAwLwAiCNB+P9fbJjJmoGBMRUo/wKCAfO2EnQAAAAAANoBXgGcAgICVALaA1IDvAPkBAYEPARyAAEAAAANAF0ABAAAAAAAAgAUACQAcwAAAG4LcAAAAAB4nHWRzWrCQBSFT+pPqUIXLXTTzayKUohGKIibCoLuhbrrYtTRxCYZmYyKyz5Fd32HvlDfoO/QkziIFJtw9bvnnpl7ZwLgBt/wcHieGAf2UGd24Atcou+4RH3kuEweO66QXx1XyaHjGh6ROa7jFp/cwStfMVvhy7GHO+/e8QWuvcBxifqz4zL5xXGF/Oa4Sn53XMPE+3Bcx4P3M9DrvYmWoRWNQVN02kFXTPdCU4pSGQu5saE2meiLhU6timPtz3SSs9ypTCdqrJabWJoT5QQnymSRTkXgt0/UkUqVkVbN807ZdtmxdiEWRidi6HqItdErNbN+aO2612qd9sYAGmvsYRBhyUu0EGhQbfK/gzYCdElTOgSdB1eEFBIxFYkNV4RFJWPeZyyYpVQVHTHZx4y/yVGX2LGWFZri51TccUOn5B7nPefVCSPvGhVVwUl9znveO2KkhV8Wk82PZ8qwZf8OVcu1+fSmWCMw/HMOwXvKaysqM+p+cVuWag8tvv+c+xdd+4+teJxtjUEOwiAURJla24KliQfhUA2g/Sl+CKXx+loNrpzVezOLEY34Ron/0WhwQoszOvQYIKFwwQiNSbSBeO2SZ0tBP4j3zVjKNng32ZmtD1VVXCuOiw/pJ8S3WOU6l+K5UOTaDC4+2TjKMtN9KQf1ezLx/Sg/00FCvABHhjDjAAB4nGPw3sFwIihiIyNjX+QGxp0cDBwMyQUbGVidNjEwMmiBGJu5mBg5ICw+BjCLzWkX0wGgNCeQze60i8EBwmZmcNmowtgRGLHBoSNiI3OKy0Y1EG8XRwMDI4tDR3JIBEhJJBBs5mFi5NHawfi/dQNL70YmBhcADHYj9AAA) format(‘woff’);<br>}</p>
<p>.markdown-body {<br>  font-family: sans-serif;<br>  -ms-text-size-adjust: 100%;<br>  -webkit-text-size-adjust: 100%;<br>  color: #333333;<br>  overflow: hidden;<br>  font-family: “Helvetica Neue”, Helvetica, “Segoe UI”, Arial, freesans, sans-serif;<br>  font-size: 16px;<br>  line-height: 1.6;<br>  word-wrap: break-word;<br>}</p>
<p>.markdown-body a {<br>  background: transparent;<br>}</p>
<p>.markdown-body a:active,<br>.markdown-body a:hover {<br>  outline: 0;<br>}</p>
<p>.markdown-body b,<br>.markdown-body strong {<br>  font-weight: bold;<br>}</p>
<p>.markdown-body mark {<br>  background: #ff0;<br>  color: #000;<br>  font-style: italic;<br>  font-weight: bold;<br>}</p>
<p>.markdown-body sub,<br>.markdown-body sup {<br>  font-size: 75%;<br>  line-height: 0;<br>  position: relative;<br>  vertical-align: baseline;<br>}<br>.markdown-body sup {<br>  top: -0.5em;<br>}<br>.markdown-body sub {<br>  bottom: -0.25em;<br>}</p>
<p>.markdown-body h1 {<br>  font-size: 2em;<br>  margin: 0.67em 0;<br>}</p>
<p>.markdown-body img {<br>  border: 0;<br>}</p>
<p>.markdown-body hr {<br>  -moz-box-sizing: content-box;<br>  box-sizing: content-box;<br>  height: 0;<br>}</p>
<p>.markdown-body pre {<br>  overflow: auto;<br>}</p>
<p>.markdown-body code,<br>.markdown-body kbd,<br>.markdown-body pre,<br>.markdown-body samp {<br>  font-family: monospace, monospace;<br>  font-size: 1em;<br>}</p>
<p>.markdown-body input {<br>  color: inherit;<br>  font: inherit;<br>  margin: 0;<br>}</p>
<p>.markdown-body html input[disabled] {<br>  cursor: default;<br>}</p>
<p>.markdown-body input {<br>  line-height: normal;<br>}</p>
<p>.markdown-body input[type=”checkbox”] {<br>  box-sizing: border-box;<br>  padding: 0;<br>}</p>
<p>.markdown-body table {<br>  border-collapse: collapse;<br>  border-spacing: 0;<br>}</p>
<p>.markdown-body td,<br>.markdown-body th {<br>  padding: 0;<br>}</p>
<p>.markdown-body .codehilitetable {<br>  border: 0;<br>  border-spacing: 0;<br>}</p>
<p>.markdown-body .codehilitetable tr {<br>  border: 0;<br>}</p>
<p>.markdown-body .codehilitetable pre,<br>.markdown-body .codehilitetable div.codehilite {<br>  margin: 0;<br>}</p>
<p>.markdown-body .linenos,<br>.markdown-body .code,<br>.markdown-body .codehilitetable td {<br>  border: 0;<br>  padding: 0;<br>}</p>
<p>.markdown-body td:not(.linenos) .linenodiv {<br>  padding: 0 !important;<br>}</p>
<p>.markdown-body .code {<br>  width: 100%;<br>}</p>
<p>.markdown-body .linenos div pre,<br>.markdown-body .linenodiv pre,<br>.markdown-body .linenodiv {<br>  border: 0;<br>  -webkit-border-radius: 0;<br>  -moz-border-radius: 0;<br>  border-radius: 0;<br>  -webkit-border-top-left-radius: 3px;<br>  -webkit-border-bottom-left-radius: 3px;<br>  -moz-border-radius-topleft: 3px;<br>  -moz-border-radius-bottomleft: 3px;<br>  border-top-left-radius: 3px;<br>  border-bottom-left-radius: 3px;<br>}</p>
<p>.markdown-body .code div pre,<br>.markdown-body .code div {<br>  border: 0;<br>  -webkit-border-radius: 0;<br>  -moz-border-radius: 0;<br>  border-radius: 0;<br>  -webkit-border-top-right-radius: 3px;<br>  -webkit-border-bottom-right-radius: 3px;<br>  -moz-border-radius-topright: 3px;<br>  -moz-border-radius-bottomright: 3px;<br>  border-top-right-radius: 3px;<br>  border-bottom-right-radius: 3px;<br>}</p>
<p>.markdown-body * {<br>  -moz-box-sizing: border-box;<br>  box-sizing: border-box;<br>}</p>
<p>.markdown-body input {<br>  font: 13px Helvetica, arial, freesans, clean, sans-serif, “Segoe UI Emoji”, “Segoe UI Symbol”;<br>  line-height: 1.4;<br>}</p>
<p>.markdown-body a {<br>  color: #4183c4;<br>  text-decoration: none;<br>}</p>
<p>.markdown-body a:hover,<br>.markdown-body a:focus,<br>.markdown-body a:active {<br>  text-decoration: underline;<br>}</p>
<p>.markdown-body hr {<br>  height: 0;<br>  margin: 15px 0;<br>  overflow: hidden;<br>  background: transparent;<br>  border: 0;<br>  border-bottom: 1px solid #ddd;<br>}</p>
<p>.markdown-body hr:before,<br>.markdown-body hr:after {<br>  display: table;<br>  content: “ “;<br>}</p>
<p>.markdown-body hr:after {<br>  clear: both;<br>}</p>
<p>.markdown-body h1,<br>.markdown-body h2,<br>.markdown-body h3,<br>.markdown-body h4,<br>.markdown-body h5,<br>.markdown-body h6 {<br>  margin-top: 15px;<br>  margin-bottom: 15px;<br>  line-height: 1.1;<br>}</p>
<p>.markdown-body h1 {<br>  font-size: 30px;<br>}</p>
<p>.markdown-body h2 {<br>  font-size: 21px;<br>}</p>
<p>.markdown-body h3 {<br>  font-size: 16px;<br>}</p>
<p>.markdown-body h4 {<br>  font-size: 14px;<br>}</p>
<p>.markdown-body h5 {<br>  font-size: 12px;<br>}</p>
<p>.markdown-body h6 {<br>  font-size: 11px;<br>}</p>
<p>.markdown-body blockquote {<br>  margin: 0;<br>}</p>
<p>.markdown-body ul,<br>.markdown-body ol {<br>  padding: 0;<br>  margin-top: 0;<br>  margin-bottom: 0;<br>}</p>
<p>.markdown-body ol ol,<br>.markdown-body ul ol {<br>  list-style-type: lower-roman;<br>}</p>
<p>.markdown-body ul ul ol,<br>.markdown-body ul ol ol,<br>.markdown-body ol ul ol,<br>.markdown-body ol ol ol {<br>  list-style-type: lower-alpha;<br>}</p>
<p>.markdown-body dd {<br>  margin-left: 0;<br>}</p>
<p>.markdown-body code,<br>.markdown-body pre,<br>.markdown-body samp {<br>  font-family: Consolas, “Liberation Mono”, Menlo, Courier, monospace;<br>  font-size: 12px;<br>}</p>
<p>.markdown-body pre {<br>  margin-top: 0;<br>  margin-bottom: 0;<br>}</p>
<p>.markdown-body kbd {<br>  background-color: #e7e7e7;<br>  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);<br>  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);<br>  background-image: linear-gradient(#fefefe, #e7e7e7);<br>  background-repeat: repeat-x;<br>  border-radius: 2px;<br>  border: 1px solid #cfcfcf;<br>  color: #000;<br>  padding: 3px 5px;<br>  line-height: 10px;<br>  font: 11px Consolas, “Liberation Mono”, Menlo, Courier, monospace;<br>  display: inline-block;<br>}</p>
<p>.markdown-body&gt;*:first-child {<br>  margin-top: 0 !important;<br>}</p>
<p>.markdown-body&gt;*:last-child {<br>  margin-bottom: 0 !important;<br>}</p>
<p>.markdown-body .headerlink {<br>  font: normal 400 16px fontawesome-mini;<br>  vertical-align: middle;<br>  margin-left: -16px;<br>  float: left;<br>  display: inline-block;<br>  text-decoration: none;<br>  opacity: 0;<br>  color: #333;<br>}</p>
<p>.markdown-body .headerlink:focus {<br>  outline: none;<br>}</p>
<p>.markdown-body h1 .headerlink {<br>  margin-top: 0.8rem;<br>}</p>
<p>.markdown-body h2 .headerlink,<br>.markdown-body h3 .headerlink {<br>  margin-top: 0.6rem;<br>}</p>
<p>.markdown-body h4 .headerlink {<br>  margin-top: 0.2rem;<br>}</p>
<p>.markdown-body h5 .headerlink,<br>.markdown-body h6 .headerlink {<br>  margin-top: 0;<br>}</p>
<p>.markdown-body .headerlink:hover,<br>.markdown-body h1:hover .headerlink,<br>.markdown-body h2:hover .headerlink,<br>.markdown-body h3:hover .headerlink,<br>.markdown-body h4:hover .headerlink,<br>.markdown-body h5:hover .headerlink,<br>.markdown-body h6:hover .headerlink {<br>  opacity: 1;<br>  text-decoration: none;<br>}</p>
<p>.markdown-body h1 {<br>  padding-bottom: 0.3em;<br>  font-size: 2.25em;<br>  line-height: 1.2;<br>  border-bottom: 1px solid #eee;<br>}</p>
<p>.markdown-body h2 {<br>  padding-bottom: 0.3em;<br>  font-size: 1.75em;<br>  line-height: 1.225;<br>  border-bottom: 1px solid #eee;<br>}</p>
<p>.markdown-body h3 {<br>  font-size: 1.5em;<br>  line-height: 1.43;<br>}</p>
<p>.markdown-body h4 {<br>  font-size: 1.25em;<br>}</p>
<p>.markdown-body h5 {<br>  font-size: 1em;<br>}</p>
<p>.markdown-body h6 {<br>  font-size: 1em;<br>  color: #777;<br>}</p>
<p>.markdown-body p,<br>.markdown-body blockquote,<br>.markdown-body ul,<br>.markdown-body ol,<br>.markdown-body dl,<br>.markdown-body table,<br>.markdown-body pre,<br>.markdown-body .admonition {<br>  margin-top: 0;<br>  margin-bottom: 16px;<br>}</p>
<p>.markdown-body hr {<br>  height: 4px;<br>  padding: 0;<br>  margin: 16px 0;<br>  background-color: #e7e7e7;<br>  border: 0 none;<br>}</p>
<p>.markdown-body ul,<br>.markdown-body ol {<br>  padding-left: 2em;<br>}</p>
<p>.markdown-body ul ul,<br>.markdown-body ul ol,<br>.markdown-body ol ol,<br>.markdown-body ol ul {<br>  margin-top: 0;<br>  margin-bottom: 0;<br>}</p>
<p>.markdown-body li&gt;p {<br>  margin-top: 16px;<br>}</p>
<p>.markdown-body dl {<br>  padding: 0;<br>}</p>
<p>.markdown-body dl dt {<br>  padding: 0;<br>  margin-top: 16px;<br>  font-size: 1em;<br>  font-style: italic;<br>  font-weight: bold;<br>}</p>
<p>.markdown-body dl dd {<br>  padding: 0 16px;<br>  margin-bottom: 16px;<br>}</p>
<p>.markdown-body blockquote {<br>  padding: 0 15px;<br>  color: #777;<br>  border-left: 4px solid #ddd;<br>}</p>
<p>.markdown-body blockquote&gt;:first-child {<br>  margin-top: 0;<br>}</p>
<p>.markdown-body blockquote&gt;:last-child {<br>  margin-bottom: 0;<br>}</p>
<p>.markdown-body table {<br>  display: block;<br>  width: 100%;<br>  overflow: auto;<br>  word-break: normal;<br>  word-break: keep-all;<br>}</p>
<p>.markdown-body table th {<br>  font-weight: bold;<br>}</p>
<p>.markdown-body table th,<br>.markdown-body table td {<br>  padding: 6px 13px;<br>  border: 1px solid #ddd;<br>}</p>
<p>.markdown-body table tr {<br>  background-color: #fff;<br>  border-top: 1px solid #ccc;<br>}</p>
<p>.markdown-body table tr:nth-child(2n) {<br>  background-color: #f8f8f8;<br>}</p>
<p>.markdown-body img {<br>  max-width: 100%;<br>  -moz-box-sizing: border-box;<br>  box-sizing: border-box;<br>}</p>
<p>.markdown-body code,<br>.markdown-body samp {<br>  padding: 0;<br>  padding-top: 0.2em;<br>  padding-bottom: 0.2em;<br>  margin: 0;<br>  font-size: 85%;<br>  background-color: rgba(0,0,0,0.04);<br>  border-radius: 3px;<br>}</p>
<p>.markdown-body code:before,<br>.markdown-body code:after {<br>  letter-spacing: -0.2em;<br>  content: “\00a0”;<br>}</p>
<p>.markdown-body pre&gt;code {<br>  padding: 0;<br>  margin: 0;<br>  font-size: 100%;<br>  word-break: normal;<br>  white-space: pre;<br>  background: transparent;<br>  border: 0;<br>}</p>
<p>.markdown-body .codehilite {<br>  margin-bottom: 16px;<br>}</p>
<p>.markdown-body .codehilite pre,<br>.markdown-body pre {<br>  padding: 16px;<br>  overflow: auto;<br>  font-size: 85%;<br>  line-height: 1.45;<br>  background-color: #f7f7f7;<br>  border-radius: 3px;<br>}</p>
<p>.markdown-body .codehilite pre {<br>  margin-bottom: 0;<br>  word-break: normal;<br>}</p>
<p>.markdown-body pre {<br>  word-wrap: normal;<br>}</p>
<p>.markdown-body pre code {<br>  display: inline;<br>  max-width: initial;<br>  padding: 0;<br>  margin: 0;<br>  overflow: initial;<br>  line-height: inherit;<br>  word-wrap: normal;<br>  background-color: transparent;<br>  border: 0;<br>}</p>
<p>.markdown-body pre code:before,<br>.markdown-body pre code:after {<br>  content: normal;<br>}</p>
<p>/* Admonition */<br>.markdown-body .admonition {<br>  -webkit-border-radius: 3px;<br>  -moz-border-radius: 3px;<br>  position: relative;<br>  border-radius: 3px;<br>  border: 1px solid #e0e0e0;<br>  border-left: 6px solid #333;<br>  padding: 10px 10px 10px 30px;<br>}</p>
<p>.markdown-body .admonition table {<br>  color: #333;<br>}</p>
<p>.markdown-body .admonition p {<br>  padding: 0;<br>}</p>
<p>.markdown-body .admonition-title {<br>  font-weight: bold;<br>  margin: 0;<br>}</p>
<p>.markdown-body .admonition&gt;.admonition-title {<br>  color: #333;<br>}</p>
<p>.markdown-body .attention&gt;.admonition-title {<br>  color: #a6d796;<br>}</p>
<p>.markdown-body .caution&gt;.admonition-title {<br>  color: #d7a796;<br>}</p>
<p>.markdown-body .hint&gt;.admonition-title {<br>  color: #96c6d7;<br>}</p>
<p>.markdown-body .danger&gt;.admonition-title {<br>  color: #c25f77;<br>}</p>
<p>.markdown-body .question&gt;.admonition-title {<br>  color: #96a6d7;<br>}</p>
<p>.markdown-body .note&gt;.admonition-title {<br>  color: #d7c896;<br>}</p>
<p>.markdown-body .admonition:before,<br>.markdown-body .attention:before,<br>.markdown-body .caution:before,<br>.markdown-body .hint:before,<br>.markdown-body .danger:before,<br>.markdown-body .question:before,<br>.markdown-body .note:before {<br>  font: normal normal 16px fontawesome-mini;<br>  -moz-osx-font-smoothing: grayscale;<br>  -webkit-user-select: none;<br>  -moz-user-select: none;<br>  -ms-user-select: none;<br>  user-select: none;<br>  line-height: 1.5;<br>  color: #333;<br>  position: absolute;<br>  left: 0;<br>  top: 0;<br>  padding-top: 10px;<br>  padding-left: 10px;<br>}</p>
<p>.markdown-body .admonition:before {<br>  content: “\f056\00a0”;<br>  color: 333;<br>}</p>
<p>.markdown-body .attention:before {<br>  content: “\f058\00a0”;<br>  color: #a6d796;<br>}</p>
<p>.markdown-body .caution:before {<br>  content: “\f06a\00a0”;<br>  color: #d7a796;<br>}</p>
<p>.markdown-body .hint:before {<br>  content: “\f05a\00a0”;<br>  color: #96c6d7;<br>}</p>
<p>.markdown-body .danger:before {<br>  content: “\f057\00a0”;<br>  color: #c25f77;<br>}</p>
<p>.markdown-body .question:before {<br>  content: “\f059\00a0”;<br>  color: #96a6d7;<br>}</p>
<p>.markdown-body .note:before {<br>  content: “\f040\00a0”;<br>  color: #d7c896;<br>}</p>
<p>.markdown-body .admonition::after {<br>  content: normal;<br>}</p>
<p>.markdown-body .attention {<br>  border-left: 6px solid #a6d796;<br>}</p>
<p>.markdown-body .caution {<br>  border-left: 6px solid #d7a796;<br>}</p>
<p>.markdown-body .hint {<br>  border-left: 6px solid #96c6d7;<br>}</p>
<p>.markdown-body .danger {<br>  border-left: 6px solid #c25f77;<br>}</p>
<p>.markdown-body .question {<br>  border-left: 6px solid #96a6d7;<br>}</p>
<p>.markdown-body .note {<br>  border-left: 6px solid #d7c896;<br>}</p>
<p>.markdown-body .admonition&gt;*:first-child {<br>  margin-top: 0 !important;<br>}</p>
<p>.markdown-body .admonition&gt;*:last-child {<br>  margin-bottom: 0 !important;<br>}</p>
<p>/* progress bar*/<br>.markdown-body .progress {<br>  display: block;<br>  width: 300px;<br>  margin: 10px 0;<br>  height: 24px;<br>  -webkit-border-radius: 3px;<br>  -moz-border-radius: 3px;<br>  border-radius: 3px;<br>  background-color: #ededed;<br>  position: relative;<br>  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);<br>}</p>
<p>.markdown-body .progress-label {<br>  position: absolute;<br>  text-align: center;<br>  font-weight: bold;<br>  width: 100%; margin: 0;<br>  line-height: 24px;<br>  color: #333;<br>  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;<br>  -webkit-font-smoothing: antialiased !important;<br>  white-space: nowrap;<br>  overflow: hidden;<br>}</p>
<p>.markdown-body .progress-bar {<br>  height: 24px;<br>  float: left;<br>  -webkit-border-radius: 3px;<br>  -moz-border-radius: 3px;<br>  border-radius: 3px;<br>  background-color: #96c6d7;<br>  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);<br>  background-size: 30px 30px;<br>  background-image: -webkit-linear-gradient(<br>    135deg, rgba(255, 255, 255, .4) 27%,<br>    transparent 27%,<br>    transparent 52%, rgba(255, 255, 255, .4) 52%,<br>    rgba(255, 255, 255, .4) 77%,<br>    transparent 77%, transparent<br>  );<br>  background-image: -moz-linear-gradient(<br>    135deg,<br>    rgba(255, 255, 255, .4) 27%, transparent 27%,<br>    transparent 52%, rgba(255, 255, 255, .4) 52%,<br>    rgba(255, 255, 255, .4) 77%, transparent 77%,<br>    transparent<br>  );<br>  background-image: -ms-linear-gradient(<br>    135deg,<br>    rgba(255, 255, 255, .4) 27%, transparent 27%,<br>    transparent 52%, rgba(255, 255, 255, .4) 52%,<br>    rgba(255, 255, 255, .4) 77%, transparent 77%,<br>    transparent<br>  );<br>  background-image: -o-linear-gradient(<br>    135deg,<br>    rgba(255, 255, 255, .4) 27%, transparent 27%,<br>    transparent 52%, rgba(255, 255, 255, .4) 52%,<br>    rgba(255, 255, 255, .4) 77%, transparent 77%,<br>    transparent<br>  );<br>  background-image: linear-gradient(<br>    135deg,<br>    rgba(255, 255, 255, .4) 27%, transparent 27%,<br>    transparent 52%, rgba(255, 255, 255, .4) 52%,<br>    rgba(255, 255, 255, .4) 77%, transparent 77%,<br>    transparent<br>  );<br>}</p>
<p>.markdown-body .progress-100plus .progress-bar {<br>  background-color: #a6d796;<br>}</p>
<p>.markdown-body .progress-80plus .progress-bar {<br>  background-color: #c6d796;<br>}</p>
<p>.markdown-body .progress-60plus .progress-bar {<br>  background-color: #d7c896;<br>}</p>
<p>.markdown-body .progress-40plus .progress-bar {<br>  background-color: #d7a796;<br>}</p>
<p>.markdown-body .progress-20plus .progress-bar {<br>  background-color: #d796a6;<br>}</p>
<p>.markdown-body .progress-0plus .progress-bar {<br>  background-color: #c25f77;<br>}</p>
<p>.markdown-body .candystripe-animate .progress-bar{<br>  -webkit-animation: animate-stripes 3s linear infinite;<br>  -moz-animation: animate-stripes 3s linear infinite;<br>  animation: animate-stripes 3s linear infinite;<br>}</p>
<p>@-webkit-keyframes animate-stripes {<br>  0% {<br>    background-position: 0 0;<br>  }</p>
<p>  100% {<br>    background-position: 60px 0;<br>  }<br>}</p>
<p>@-moz-keyframes animate-stripes {<br>  0% {<br>    background-position: 0 0;<br>  }</p>
<p>  100% {<br>    background-position: 60px 0;<br>  }<br>}</p>
<p>@keyframes animate-stripes {<br>  0% {<br>    background-position: 0 0;<br>  }</p>
<p>  100% {<br>    background-position: 60px 0;<br>  }<br>}</p>
<p>.markdown-body .gloss .progress-bar {<br>  box-shadow:<br>    inset 0 4px 12px rgba(255, 255, 255, .7),<br>    inset 0 -12px 0 rgba(0, 0, 0, .05);<br>}</p>
<p>/* Multimarkdown Critic Blocks */<br>.markdown-body .critic_mark {<br>  background: #ff0;<br>}</p>
<p>.markdown-body .critic_delete {<br>  color: #c82829;<br>  text-decoration: line-through;<br>}</p>
<p>.markdown-body .critic_insert {<br>  color: #718c00 ;<br>  text-decoration: underline;<br>}</p>
<p>.markdown-body .critic_comment {<br>  color: #8e908c;<br>  font-style: italic;<br>}</p>
<p>.markdown-body .headeranchor {<br>  font: normal normal 16px fontawesome-mini;<br>  line-height: 1;<br>  display: inline-block;<br>  text-decoration: none;<br>  -webkit-font-smoothing: antialiased;<br>  -moz-osx-font-smoothing: grayscale;<br>  -webkit-user-select: none;<br>  -moz-user-select: none;<br>  -ms-user-select: none;<br>  user-select: none;<br>}</p>
<p>.headeranchor:before {<br>  content: ‘\e157’;<br>}</p>
<p>.markdown-body .task-list-item {<br>  list-style-type: none;<br>}</p>
<p>.markdown-body .task-list-item+.task-list-item {<br>  margin-top: 3px;<br>}</p>
<p>.markdown-body .task-list-item input {<br>  margin: 0 4px 0.25em -20px;<br>  vertical-align: middle;<br>}</p>
<p>/* Media */<br>@media only screen and (min-width: 480px) {<br>  .markdown-body {<br>    font-size:14px;<br>  }<br>}</p>
<p>@media only screen and (min-width: 768px) {<br>  .markdown-body {<br>    font-size:16px;<br>  }<br>}</p>
<p>@media print {<br>  .markdown-body * {<br>    background: transparent !important;<br>    color: black !important;<br>    filter:none !important;<br>    -ms-filter: none !important;<br>  }</p>
<p>  .markdown-body {<br>    font-size:12pt;<br>    max-width:100%;<br>    outline:none;<br>    border: 0;<br>  }</p>
<p>  .markdown-body a,<br>  .markdown-body a:visited {<br>    text-decoration: underline;<br>  }</p>
<p>  .markdown-body .headeranchor-link {<br>    display: none;<br>  }</p>
<p>  .markdown-body a[href]:after {<br>    content: “ (“ attr(href) “)”;<br>  }</p>
<p>  .markdown-body abbr[title]:after {<br>    content: “ (“ attr(title) “)”;<br>  }</p>
<p>  .markdown-body .ir a:after,<br>  .markdown-body a[href^=”javascript:”]:after,<br>  .markdown-body a[href^=”#”]:after {<br>    content: “”;<br>  }</p>
<p>  .markdown-body pre {<br>    white-space: pre;<br>    white-space: pre-wrap;<br>    word-wrap: break-word;<br>  }</p>
<p>  .markdown-body pre,<br>  .markdown-body blockquote {<br>    border: 1px solid #999;<br>    padding-right: 1em;<br>    page-break-inside: avoid;<br>  }</p>
<p>  .markdown-body .progress,<br>  .markdown-body .progress-bar {<br>    -moz-box-shadow: none;<br>    -webkit-box-shadow: none;<br>    box-shadow: none;<br>  }</p>
<p>  .markdown-body .progress {<br>    border: 1px solid #ddd;<br>  }</p>
<p>  .markdown-body .progress-bar {<br>    height: 22px;<br>    border-right: 1px solid #ddd;<br>  }</p>
<p>  .markdown-body tr,<br>  .markdown-body img {<br>    page-break-inside: avoid;<br>  }</p>
<p>  .markdown-body img {<br>    max-width: 100% !important;<br>  }</p>
<p>  .markdown-body p,<br>  .markdown-body h2,<br>  .markdown-body h3 {<br>    orphans: 3;<br>    widows: 3;<br>  }</p>
<p>  .markdown-body h2,<br>  .markdown-body h3 {<br>    page-break-after: avoid;<br>  }<br>}<br></style><style>/<em>github</em>/<br>.codehilite {background-color:#fff;color:#333333;}<br>.codehilite .hll {background-color:#ffffcc;}<br>.codehilite .c{color:#999988;font-style:italic}<br>.codehilite .err{color:#a61717;background-color:#e3d2d2}<br>.codehilite .k{font-weight:bold}<br>.codehilite .o{font-weight:bold}<br>.codehilite .cm{color:#999988;font-style:italic}<br>.codehilite .cp{color:#999999;font-weight:bold}<br>.codehilite .c1{color:#999988;font-style:italic}<br>.codehilite .cs{color:#999999;font-weight:bold;font-style:italic}<br>.codehilite .gd{color:#000000;background-color:#ffdddd}<br>.codehilite .ge{font-style:italic}<br>.codehilite .gr{color:#aa0000}<br>.codehilite .gh{color:#999999}<br>.codehilite .gi{color:#000000;background-color:#ddffdd}<br>.codehilite .go{color:#888888}<br>.codehilite .gp{color:#555555}<br>.codehilite .gs{font-weight:bold}<br>.codehilite .gu{color:#800080;font-weight:bold}<br>.codehilite .gt{color:#aa0000}<br>.codehilite .kc{font-weight:bold}<br>.codehilite .kd{font-weight:bold}<br>.codehilite .kn{font-weight:bold}<br>.codehilite .kp{font-weight:bold}<br>.codehilite .kr{font-weight:bold}<br>.codehilite .kt{color:#445588;font-weight:bold}<br>.codehilite .m{color:#009999}<br>.codehilite .s{color:#dd1144}<br>.codehilite .n{color:#333333}<br>.codehilite .na{color:teal}<br>.codehilite .nb{color:#0086b3}<br>.codehilite .nc{color:#445588;font-weight:bold}<br>.codehilite .no{color:teal}<br>.codehilite .ni{color:purple}<br>.codehilite .ne{color:#990000;font-weight:bold}<br>.codehilite .nf{color:#990000;font-weight:bold}<br>.codehilite .nn{color:#555555}<br>.codehilite .nt{color:navy}<br>.codehilite .nv{color:teal}<br>.codehilite .ow{font-weight:bold}<br>.codehilite .w{color:#bbbbbb}<br>.codehilite .mf{color:#009999}<br>.codehilite .mh{color:#009999}<br>.codehilite .mi{color:#009999}<br>.codehilite .mo{color:#009999}<br>.codehilite .sb{color:#dd1144}<br>.codehilite .sc{color:#dd1144}<br>.codehilite .sd{color:#dd1144}<br>.codehilite .s2{color:#dd1144}<br>.codehilite .se{color:#dd1144}<br>.codehilite .sh{color:#dd1144}<br>.codehilite .si{color:#dd1144}<br>.codehilite .sx{color:#dd1144}<br>.codehilite .sr{color:#009926}<br>.codehilite .s1{color:#dd1144}<br>.codehilite .ss{color:#990073}<br>.codehilite .bp{color:#999999}<br>.codehilite .vc{color:teal}<br>.codehilite .vg{color:teal}<br>.codehilite .vi{color:teal}<br>.codehilite .il{color:#009999}<br>.codehilite .gc{color:#999;background-color:#EAF2F5}<br></style><title>面试经典问题汇总</title><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="早起不吃虫" type="application/atom+xml">
</head><body><article class="markdown-body"><h2 id="getpost">GET与POST请求的区别<a class="headerlink" href="#getpost" title="Permanent link"></a></h2></p>
<p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p>
<p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP连接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p>
<p>为什么GET与POST请求还有这么多差异呢？根源在于浏览器与服务器的限制。</p>
<h5 id="_1"><strong>缓存上的区别</strong><a class="headerlink" href="#_1" title="Permanent link"></a></h5>
<ul>
<li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li>
<li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li>
</ul>
<h5 id="_2"><strong>安全上的区别</strong><a class="headerlink" href="#_2" title="Permanent link"></a></h5>
<ul>
<li>查询字符串（名称/值对）是在 GET 请求的 URL 中发送的，有安全问题。</li>
<li>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的，因此安全性较get高</li>
</ul>
<p><strong>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。</strong></p>
<p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p>
<ul>
<li>HTTP 协议 未规定 GET 和POST的长度限制</li>
<li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li>
<li>不同的浏览器和WEB服务器，限制的最大长度不一样</li>
<li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li>
</ul>
<h5 id="_3"><strong>总结</strong><a class="headerlink" href="#_3" title="Permanent link"></a></h5>
<p>有关 GET 请求的其他一些注释：</p>
<ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据</li>
</ul>
<p>有关 POST 请求的其他一些注释：</p>
<ul>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求</li>
</ul>
<h2 id="_4">对象的属性<a class="headerlink" href="#_4" title="Permanent link"></a></h2>
<p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<p>描述符可同时具有的键值</p>
<table>
<thead>
<tr>
<th></th>
<th>configurable</th>
<th>enumerable</th>
<th>value</th>
<th>writable</th>
<th>get</th>
<th>set</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据描述符</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>存取描述符</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<h5 id="_5">数据属性：<a class="headerlink" href="#_5" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">configurable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">value</span><span class="o">:</span> <span class="s2">&quot;static&quot;</span>
<span class="p">});</span>
</pre></div>

<h5 id="_6">访问器属性：<a class="headerlink" href="#_6" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">_year</span><span class="o">:</span><span class="mi">2001</span><span class="p">,</span>
  <span class="nx">get</span> <span class="nx">year</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_year</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="nx">set</span> <span class="nx">year</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_year</span> <span class="o">=</span> <span class="nx">val</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">_year</span><span class="p">);</span> <span class="c1">//2001</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">year</span><span class="p">);</span> <span class="c1">//2001</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">year</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">_year</span><span class="p">);</span> <span class="c1">// hello</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">year</span><span class="p">);</span> <span class="c1">// hello</span>
</pre></div>

<h2 id="_7">事件委托<a class="headerlink" href="#_7" title="Permanent link"></a></h2>
<h5 id="_8">为什么要事件委托：<a class="headerlink" href="#_8" title="Permanent link"></a></h5>
<ul>
<li>绑定事件越多，浏览器内存占用越大，严重影响性能。</li>
<li>ajax的出现，局部刷新的盛行，导致每次加载完，都要重新绑定事件</li>
<li>部分浏览器移除元素时，绑定的事件并没有被及时移除，导致的内存泄漏，严重影响性能</li>
<li>大部分ajax局部刷新的，只是显示的数据，而操作却是大部分相同的，重复绑定，会导致代码的耦合性过大，严重影响后期的维护。</li>
</ul>
<h5 id="_9">事件委托的简单实现：<a class="headerlink" href="#_9" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">_addEvent</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">type</span><span class="p">,</span><span class="nx">fn</span><span class="p">){</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span><span class="nx">fn</span><span class="p">,</span><span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">_delegate</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">tag</span><span class="p">,</span><span class="nx">fn</span><span class="p">){</span>
    <span class="kd">function</span> <span class="nx">cb</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span> <span class="o">||</span> <span class="nx">e</span><span class="p">.</span><span class="nx">srcElement</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">tags</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="nx">tag</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">tags</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span><span class="k">return</span><span class="p">;}</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">nodeName</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()</span> <span class="o">!==</span> <span class="nx">tag</span><span class="p">){</span>
            <span class="nx">target</span> <span class="o">=</span> <span class="nx">target</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">tags</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">tags</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">target</span><span class="p">){</span>
                <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">_addEvent</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="s2">&quot;click&quot;</span><span class="p">,</span><span class="nx">cb</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h5 id="_10">事件委托的缺点：<a class="headerlink" href="#_10" title="Permanent link"></a></h5>
<p>通过jQuery的源码可以获知，事件委托的性能受下面三个因素所影响：</p>
<ul>
<li>DOM遍历的次数</li>
<li>DOM结构的层数</li>
<li>事件委托绑定的个数</li>
</ul>
<h5 id="_11">提高事件委托性能的解决方案：<a class="headerlink" href="#_11" title="Permanent link"></a></h5>
<ul>
<li>降低层级，尽量在父级绑定</li>
<li>减少绑定的次数</li>
</ul>
<h2 id="_12">图片预加载与懒加载<a class="headerlink" href="#_12" title="Permanent link"></a></h2>
<h5 id="_13">预加载<a class="headerlink" href="#_13" title="Permanent link"></a></h5>
<h6 id="cssjavascript">方法一：用CSS和JavaScript实现预加载<a class="headerlink" href="#cssjavascript" title="Permanent link"></a></h6>
<p>使用纯CSS:</p>
<div class="codehilite"><pre><span class="nt">background</span><span class="o">:</span> <span class="nt">url</span><span class="o">(</span><span class="nt">http</span><span class="o">://</span><span class="nt">domain</span><span class="nc">.tld</span><span class="o">/</span><span class="nt">image-01</span><span class="nc">.png</span><span class="o">)</span> <span class="nt">no-repeat</span> <span class="nt">-9999px</span> <span class="nt">-9999px</span><span class="o">;</span> <span class="err">}</span>  
</pre></div>

<p>使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。</p>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">preloader</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;preload-01&quot;</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="s2">&quot;url(http://domain.tld/image-01.png) no-repeat -9999px -9999px&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<p><span class="kd">function</span> <span class="nx">addLoadEvent</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">{</span><br>    <span class="kd">var</span> <span class="nx">oldonload</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span><span class="p">;</span><br>    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">!=</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span><br>        <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">func</span><span class="p">;</span><br>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><br>        <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span><br>            <span class="k">if</span> <span class="p">(</span><span class="nx">oldonload</span><span class="p">)</span> <span class="p">{</span><br>                <span class="nx">oldonload</span><span class="p">();</span><br>            <span class="p">}</span><br>            <span class="nx">func</span><span class="p">();</span><br>        <span class="p">}</span><br>    <span class="p">}</span><br><span class="p">}</span><br><span class="nx">addLoadEvent</span><span class="p">(</span><span class="nx">preloader</span><span class="p">);</span><br></pre></div></p>
<h6 id="javascript">方法二：仅使用JavaScript实现预加载<a class="headerlink" href="#javascript" title="Permanent link"></a></h6>
<p>上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">images</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">()</span>
<span class="kd">function</span> <span class="nx">preload</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">preload</span><span class="p">.</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">images</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">()</span>
        <span class="nx">images</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">preload</span><span class="p">.</span><span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">preload</span><span class="p">(</span>
    <span class="s2">&quot;http://domain.tld/gallery/image-001.jpg&quot;</span><span class="p">,</span>
    <span class="s2">&quot;http://domain.tld/gallery/image-002.jpg&quot;</span><span class="p">,</span>
    <span class="s2">&quot;http://domain.tld/gallery/image-003.jpg&quot;</span><span class="p">)</span>
</pre></div>

<h6 id="ajax">方法三：使用Ajax实现预加载<a class="headerlink" href="#ajax" title="Permanent link"></a></h6>
<div class="codehilite"><pre><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// XHR to request a JS and a CSS</span>
    <span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;http://domain.tld/preload.js&#39;</span><span class="p">);</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
    <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;http://domain.tld/preload.css&#39;</span><span class="p">);</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
    <span class="c1">// preload image</span>
    <span class="k">new</span> <span class="nx">Image</span><span class="p">().</span><span class="nx">src</span> <span class="o">=</span> <span class="s2">&quot;http://domain.tld/preload.png&quot;</span><span class="p">;</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>

<h5 id="_14">懒加载<a class="headerlink" href="#_14" title="Permanent link"></a></h5>
<ul>
<li>第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟。</li>
<li>第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。</li>
<li>第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现。</li>
</ul>
<div class="codehilite"><pre><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">fn</span><span class="p">.</span><span class="nx">scrollLoading</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">defaults</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">attr</span><span class="o">:</span> <span class="s2">&quot;data-url&quot;</span><span class="p">,</span>
            <span class="nx">container</span><span class="o">:</span> <span class="nx">$</span><span class="p">(</span><span class="nb">window</span><span class="p">),</span>
            <span class="nx">callback</span><span class="o">:</span> <span class="nx">$</span><span class="p">.</span><span class="nx">noop</span>
        <span class="p">};</span>
        <span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">extend</span><span class="p">({},</span> <span class="nx">defaults</span><span class="p">,</span> <span class="nx">options</span> <span class="o">||</span> <span class="p">{});</span>
        <span class="nx">params</span><span class="p">.</span><span class="nx">cache</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">each</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">nodeName</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">(),</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="nx">params</span><span class="p">[</span><span class="s2">&quot;attr&quot;</span><span class="p">]);</span>
            <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nx">obj</span><span class="o">:</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
                <span class="nx">tag</span><span class="o">:</span> <span class="nx">node</span><span class="p">,</span>
                <span class="nx">url</span><span class="o">:</span> <span class="nx">url</span>
            <span class="p">};</span>
            <span class="nx">params</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>

<pre><code>    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;loading&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;contHeight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;contop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;contop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;posb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;contop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;:visible&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;contHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;posb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;posb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;contHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;img&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;src&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                                &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                            &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;loading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;scroll&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;loading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;</code></pre><p><span class="p">})(</span><span class="nx">jQuery</span><span class="p">);</span><br></pre></div></p>
<h2 id="mouseovermouseenter">mouseover和mouseenter的区别<a class="headerlink" href="#mouseovermouseenter" title="Permanent link"></a></h2>
<ul>
<li>mouseover 事件具有冒泡特性，也就是说无论鼠标是从别的元素移动到element或者是从element的子元素移动到element都会触发mouseover事件。</li>
<li>mouseenter 事件，该事件没有冒泡特性，也就是说只有鼠标穿过该事件的时候才会触发mouseenter</li>
</ul>
<h6 id="mouseover-mouseenter">mouseover 模拟 mouseenter<a class="headerlink" href="#mouseover-mouseenter" title="Permanent link"></a></h6>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">selector</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">);</span>
  <span class="nx">selector</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;mouseover&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span>
        <span class="nx">related</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">relatedTarget</span><span class="p">,</span><span class="c1">//触发事件前所在的节点</span>
        <span class="nx">match</span><span class="p">;</span>
    <span class="c1">// 通过触发事件节点找到绑定事件节点</span>
    <span class="k">while</span> <span class="p">(</span> <span class="nx">target</span> <span class="o">&amp;&amp;</span> <span class="nx">target</span> <span class="o">!==</span> <span class="nb">document</span> <span class="o">&amp;&amp;</span> <span class="nx">target</span><span class="o">!==</span> <span class="k">this</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">target</span> <span class="o">=</span> <span class="nx">target</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">target</span> <span class="o">===</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span><span class="nx">match</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;}</span>
    <span class="p">}</span>
    <span class="c1">// 没找到绑定事件的节点</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">match</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 判断是不是冒泡触发的节点，如果是则related置为target</span>
    <span class="k">while</span> <span class="p">(</span> <span class="nx">related</span> <span class="o">&amp;&amp;</span> <span class="nx">related</span> <span class="o">!=</span> <span class="nx">target</span> <span class="o">&amp;&amp;</span> <span class="nx">related</span> <span class="o">!=</span> <span class="nb">document</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">related</span> <span class="o">=</span> <span class="nx">related</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 冒泡触发，也就是子节点触发</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nx">related</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">//......mouseenter事件代码</span>
  <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</pre></div>

<h2 id="_15">闭包<a class="headerlink" href="#_15" title="Permanent link"></a></h2>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">f1</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
    <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">n</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">f2</span><span class="p">(){</span>
        <span class="nx">n</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">f2</span><span class="p">;</span>
<span class="p">}</span>

<p><span class="kd">var</span> <span class="nx">result1</span> <span class="o">=</span> <span class="nx">f1</span><span class="p">();</span><span class="c1">//拷贝一份</span><br><span class="kd">var</span> <span class="nx">result2</span> <span class="o">=</span> <span class="nx">f1</span><span class="p">();</span><span class="c1">//拷贝一份</span><br><span class="kd">var</span> <span class="nx">result3</span> <span class="o">=</span> <span class="nx">f1</span><span class="p">();</span><span class="c1">//拷贝一份</span><br><span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="nx">result1</span><span class="p">();</span><span class="nx">add</span><span class="p">();</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a1</span><span class="p">);</span><span class="c1">//[1, 2, 3]</span><br><span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="nx">result2</span><span class="p">();</span><span class="nx">add</span><span class="p">();</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a2</span><span class="p">);</span><span class="c1">//[1, 2, 3]</span><br><span class="kd">var</span> <span class="nx">a3</span> <span class="o">=</span> <span class="nx">result3</span><span class="p">();</span><span class="nx">add</span><span class="p">();</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a3</span><span class="p">);</span><span class="c1">//[0, 0, 0, 1, 2, 3]</span><br><span class="kd">var</span> <span class="nx">a4</span> <span class="o">=</span> <span class="nx">add</span><span class="p">();</span><br><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a1</span> <span class="o">===</span> <span class="nx">a2</span><span class="p">);</span><span class="c1">//false</span><br><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a2</span> <span class="o">===</span> <span class="nx">a3</span><span class="p">);</span><span class="c1">//false</span><br><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a3</span> <span class="o">===</span> <span class="nx">a4</span><span class="p">);</span><span class="c1">//true</span><br></pre></div></p>
<h2 id="new">new 命令的原理<a class="headerlink" href="#new" title="Permanent link"></a></h2>
<h5 id="_16">原理<a class="headerlink" href="#_16" title="Permanent link"></a></h5>
<p>使用new命令时，它后面的函数依次执行下面的步骤。</p>
<ul>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的prototype属性。</li>
<li>将这个空对象赋值给函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ul>
<p>实现代码：</p>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">_new</span><span class="p">(</span><span class="cm">/* 构造函数 */</span> <span class="nx">constructor</span><span class="p">,</span> <span class="cm">/* 构造函数参数 */</span> <span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 将 arguments 对象转为数组</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
  <span class="c1">// 取出构造函数</span>
  <span class="kd">var</span> <span class="nx">constructor</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
  <span class="c1">// 创建一个空对象，继承构造函数的 prototype 属性</span>
  <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="c1">// 执行构造函数</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">constructor</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
  <span class="c1">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span>
  <span class="k">return</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">result</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="o">?</span> <span class="nx">result</span> <span class="o">:</span> <span class="nx">context</span><span class="p">;</span>
<span class="p">}</span>

<p><span class="c1">// 实例</span><br><span class="kd">var</span> <span class="nx">actor</span> <span class="o">=</span> <span class="nx">_new</span><span class="p">(</span><span class="nx">Person</span><span class="p">,</span> <span class="s1">&#39;张三&#39;</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span><br></pre></div></p>
<h5 id="new_1">保证构造函数使用new<a class="headerlink" href="#new_1" title="Permanent link"></a></h5>
<h6 id="_17">方法一，严格模式<a class="headerlink" href="#_17" title="Permanent link"></a></h6>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">){</span>
  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Fubar</span><span class="p">()</span>
<span class="c1">// TypeError: Cannot set property &#39;_foo&#39; of undefined</span>
</pre></div>

<h6 id="newtarget">方法二，new.target<a class="headerlink" href="#newtarget" title="Permanent link"></a></h6>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;请使用 new 命令调用！&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">()</span> <span class="c1">// Uncaught Error: 请使用 new 命令调用！</span>
</pre></div>

<h2 id="call-apply-bind">call 、 apply 、bind 的实现<a class="headerlink" href="#call-apply-bind" title="Permanent link"></a></h2>
<h5 id="call">call 的实现<a class="headerlink" href="#call" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span><span class="p">){</span>
    <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">args</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">this</span> <span class="o">!==</span> <span class="s2">&quot;function&quot;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;函数才能调用call方法&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//this绑定的指向</span>
        <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="c1">//调用call的函数</span>
        <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="c1">//call调用时的传参</span>
        <span class="kd">var</span> <span class="nx">param</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">//创建一个唯一key;</span>
        <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="s1">&#39;fn&#39;</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">context</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//return eval(&quot;fn(&quot; + param + &quot;)&quot;);</span>
            <span class="k">return</span> <span class="nx">fn</span><span class="p">(...</span><span class="nx">param</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="c1">//保证是对象</span>
            <span class="nx">context</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>
            <span class="c1">//将函数变为context的方法</span>
            <span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">;</span>
            <span class="c1">//通过对象方法的形式调用</span>
            <span class="c1">//return eval(&quot;context[key](&quot; + param + &quot;)&quot;);</span>
            <span class="k">return</span> <span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">](...</span><span class="nx">param</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h5 id="apply">apply 的实现<a class="headerlink" href="#apply" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">apply</span><span class="p">){</span>
    <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myapply</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">args</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">this</span> <span class="o">!==</span> <span class="s2">&quot;function&quot;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;函数才能调用appy方法&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//this绑定的指向</span>
        <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="c1">//调用apply的函数</span>
        <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="c1">//apply调用时的传参</span>
        <span class="kd">var</span> <span class="nx">param</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="o">?</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="p">[];</span>
        <span class="c1">//创建一个唯一key;</span>
        <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="s1">&#39;fn&#39;</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">context</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//return eval(&quot;fn(&quot; + param + &quot;)&quot;);</span>
            <span class="k">return</span> <span class="nx">fn</span><span class="p">(...</span><span class="nx">param</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="c1">//保证是对象</span>
            <span class="nx">context</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>
            <span class="c1">//将函数变为context的方法</span>
            <span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">;</span>
            <span class="c1">//通过对象方法的形式调用</span>
            <span class="c1">//return eval(&quot;context[key](&quot; + param + &quot;)&quot;);</span>
            <span class="k">return</span> <span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">](...</span><span class="nx">param</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h5 id="bind">bind 的实现<a class="headerlink" href="#bind" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">mybind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">args</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">this</span> <span class="o">!==</span> <span class="s2">&quot;function&quot;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;函数才能调用bind方法&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//this绑定的指向</span>
        <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="c1">//调用bind的函数</span>
        <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="c1">//bind调用时的传参</span>
        <span class="kd">var</span> <span class="nx">param</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">//返回的函数，等待下一步调用</span>
        <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="c1">//判断callback是直接调用还是new调用</span>
            <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">callback</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="nx">context</span><span class="p">,</span>
                <span class="c1">//合并参数</span>
                <span class="nx">param</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">))</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//维护原型关系</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">callback</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//返回待调用的函数</span>
        <span class="k">return</span> <span class="nx">callback</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="js">异步加载js的方法<a class="headerlink" href="#js" title="Permanent link"></a></h2>
<p>defer属性和async属性到底应该使用哪一个？</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。</p>
<p>如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。</p>
<h5 id="defer">defer：<a class="headerlink" href="#defer" title="Permanent link"></a></h5>
<p>有了defer属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在DOMContentLoaded事件触发前执行（即刚刚读取完</html>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>
<p>对于内置而不是加载外部脚本的script标签，以及动态生成的script标签，defer属性不起作用。</p>
<ul>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有defer属性的script元素。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载script元素加载的外部脚本。</li>
<li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li>
</ul>
<h5 id="async">async:<a class="headerlink" href="#async" title="Permanent link"></a></h5>
<p>async属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。</p>
<ul>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有async属性的script标签。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载script标签中的外部脚本。</li>
<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li>
<li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li>
</ul>
<h5 id="es6-typemodule">ES6 模块(type=&rdquo;module&rdquo;)<a class="headerlink" href="#es6-typemodule" title="Permanent link"></a></h5>
<p>浏览器对于带有type=&rdquo;module&rdquo;的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。</p>
<p><code>&lt;script&gt;</code>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<h5 id="script">动态创建script标签<a class="headerlink" href="#script" title="Permanent link"></a></h5>
<h2 id="ajax_1">Ajax解决浏览器的缓存问题<a class="headerlink" href="#ajax_1" title="Permanent link"></a></h2>
<p>Ajax能提高页面载入速度的主要原因是通过Ajax减少了重复数据的载入，也即在载入数据的同时将数据缓存到内存中，一旦数据被加载，只要没有刷新页面，这些数据就会一直被缓存在内存中，当提交的URL与历史的URL一致时，就不需要提交给服务器，也即不需要从服务器获取数据，虽然降低了服务器的负载，提高了用户体验，但不能获取最新的数据。为了保证读取的信息都是最新的，需要禁止其缓存功能。</p>
<ul>
<li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&ldquo;If-Modified-Since&rdquo;,&rdquo;0&rdquo;)。</li>
<li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&ldquo;Cache-Control&rdquo;,&rdquo;no-cache&rdquo;)。</li>
<li>在URL后面加上一个随机数： &ldquo;fresh=&rdquo; + Math.random()。</li>
<li>在URL后面加上时间搓：&rdquo;nowtime=&rdquo; + new Date().getTime()。</li>
<li>如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</li>
</ul>
<h2 id="_18">防抖与节流<a class="headerlink" href="#_18" title="Permanent link"></a></h2>
<h5 id="_19">防抖<a class="headerlink" href="#_19" title="Permanent link"></a></h5>
<p>根据用户输入信息发请求的时候，为了防止频繁触发请求，需要等待用户最后输入的时候再发送请求，也就是防抖：</p>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span><span class="nx">delay</span><span class="p">){</span>
    <span class="c1">//利用闭包，保留定时器的指引</span>
    <span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">//每调用一次就取消上一次回调。</span>
        <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
        <span class="c1">//重新开启定时器，过一段时间后若无操作，则执行回调</span>
        <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span><span class="nx">delay</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">scroll</span> <span class="o">=</span> <span class="nx">debounce</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;do something!!!&#39;</span><span class="p">)</span>
<span class="p">},</span><span class="mi">500</span><span class="p">)</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onscroll</span> <span class="o">=</span> <span class="nx">scroll</span><span class="p">;</span>
</pre></div>

<h5 id="_20">节流<a class="headerlink" href="#_20" title="Permanent link"></a></h5>
<p>当滚动鼠标时，因为滚动事件触发间隔极短，需要限制其在某个时间段内，只执行一次。</p>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span><span class="nx">interval</span><span class="p">){</span>
    <span class="c1">//设定初始时间</span>
    <span class="kd">var</span> <span class="nx">begin</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
    <span class="c1">//定时器指引</span>
    <span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">//总是清除上一次回调</span>
        <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
        <span class="c1">//获取当前时间</span>
        <span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
        <span class="c1">//当时间间隔大于设定，执行回调</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">begin</span> <span class="o">&gt;</span> <span class="nx">interval</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//重置开始时间</span>
            <span class="nx">begin</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>
            <span class="nx">fn</span><span class="p">();</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
                <span class="c1">//若距离上一次触发大于时间间隔，执行一次回调</span>
                <span class="nx">begin</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>
                <span class="nx">fn</span><span class="p">();</span>
            <span class="p">},</span><span class="nx">interval</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">scroll</span> <span class="o">=</span> <span class="nx">throttle</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;do something!!!&#39;</span><span class="p">)</span>
<span class="p">},</span><span class="mi">500</span><span class="p">)</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onscroll</span> <span class="o">=</span> <span class="nx">scroll</span><span class="p">;</span>
</pre></div>

<h2 id="_21"><a href="http://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">浏览器缓存</a><a class="headerlink" href="#_21" title="Permanent link"></a></h2>
<p>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；</p>
<p>区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>
<h5 id="_22">强缓存<a class="headerlink" href="#_22" title="Permanent link"></a></h5>
<h6 id="expires">Expires<a class="headerlink" href="#expires" title="Permanent link"></a></h6>
<p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。</p>
<ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</li>
</ul>
<h6 id="cache-control">Cache-Control<a class="headerlink" href="#cache-control" title="Permanent link"></a></h6>
<p>在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</li>
</ul>
<p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p>
<p>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。</p>
<h5 id="_23">强缓存的管理<a class="headerlink" href="#_23" title="Permanent link"></a></h5>
<p>通常有2种方式来设置是否启用强缓存：</p>
<ul>
<li>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li>
<li>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</li>
</ul>
<h5 id="_24">协商缓存<a class="headerlink" href="#_24" title="Permanent link"></a></h5>
<p>Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。</p>
<h6 id="last-modifiedif-modified-since">Last-Modified，If-Modified-Since<a class="headerlink" href="#last-modifiedif-modified-since" title="Permanent link"></a></h6>
<ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间；</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值；</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</li>
</ul>
<h6 id="etagif-none-match">ETag、If-None-Match<a class="headerlink" href="#etagif-none-match" title="Permanent link"></a></h6>
<ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系；</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值；</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化；</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
</ul>
<h5 id="_25">协商缓存的管理<a class="headerlink" href="#_25" title="Permanent link"></a></h5>
<p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。</p>
<p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p>
<p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</p>
<h5 id="_26">浏览器行为对缓存的影响<a class="headerlink" href="#_26" title="Permanent link"></a></h5>
<ul>
<li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</li>
</ul>
<h2 id="js_1">js监听对象属性的改变<a class="headerlink" href="#js_1" title="Permanent link"></a></h2>
<h5 id="es5objectdefineproperty">在ES5中可以通过Object.defineProperty来实现已有属性的监听<a class="headerlink" href="#es5objectdefineproperty" title="Permanent link"></a></h5>
<p><div class="codehilite"><pre><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span><span class="s1">&#39;name&#39;</span><span class="p">,{</span>
    <span class="nx">set</span><span class="err">：</span><span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span><span class="nx">value</span><span class="p">){</span>
    <span class="p">}</span>
<span class="p">})</span>
</pre></div>
缺点：如果属性不在user对象中，则不能监听该属性的变化</p>
<h5 id="es6proxy">在ES6中可以通过Proxy来实现<a class="headerlink" href="#es6proxy" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="kd">var</span>  <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Proxy</span><span class="p">({}</span><span class="err">，</span><span class="p">{</span>
 <span class="nx">set</span><span class="err">：</span><span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="nx">key</span><span class="p">,</span><span class="nx">value</span><span class="p">,</span><span class="nx">receiver</span><span class="p">){</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></div>

<p>这样即使有属性在user中不存在，通过user.id来定义也同样可以这样监听这个属性的变化。</p>
<h2 id="objectis">Object.is<a class="headerlink" href="#objectis" title="Permanent link"></a></h2>
<div class="codehilite"><pre><span class="c1">// 特例</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">);</span>            <span class="c1">// false</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">);</span>           <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span class="p">);</span>         <span class="c1">// true</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">is</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// +0 != -0</span>
      <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// NaN == NaN</span>
      <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">!==</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>

<h2 id="requestanimationframe-cancelanimationframe">requestAnimationFrame 与 cancelAnimationFrame<a class="headerlink" href="#requestanimationframe-cancelanimationframe" title="Permanent link"></a></h2>
<p>大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms</p>
<p>而setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。</p>
<p>requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p>
<p>特点</p>
<ul>
<li>requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量</li>
<li>requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销</li>
</ul>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">cb</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="o">++</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cancelAnimationFrame</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="nx">requestAnimationFrame</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">requestAnimationFrame</span><span class="p">(</span><span class="nx">cb</span><span class="p">);</span>
</pre></div>

<h2 id="settimeout-setinterval">用 setTimeout 模拟 setInterval<a class="headerlink" href="#settimeout-setinterval" title="Permanent link"></a></h2>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">interval</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">wait</span><span class="p">,</span> <span class="nx">times</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">interv</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">t</span><span class="p">){</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">t</span> <span class="o">===</span> <span class="s2">&quot;undefined&quot;</span> <span class="o">||</span> <span class="nx">t</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
                <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">interv</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span>
                <span class="k">try</span><span class="p">{</span>
                    <span class="nx">func</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
                    <span class="nx">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="k">throw</span> <span class="nx">e</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}(</span><span class="nx">wait</span><span class="p">,</span> <span class="nx">times</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">interv</span><span class="p">,</span> <span class="nx">wait</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>

<h2 id="_27">任务队列<a class="headerlink" href="#_27" title="Permanent link"></a></h2>
<ul>
<li>先主线程，后任务队列；</li>
<li>先微任务（promise,nextTick），后宏任务(setTimeout)；</li>
<li>先nextTick，后promise（then）</li>
</ul>
<h2 id="options">OPTIONS请求方法<a class="headerlink" href="#options" title="Permanent link"></a></h2>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&rdquo;预检&rdquo;请求（preflight）。</p>
<ul>
<li>获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。</li>
<li>用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。</li>
</ul>
<h2 id="clickios300ms">click在ios上有300ms延迟，原因及如何解决？<a class="headerlink" href="#clickios300ms" title="Permanent link"></a></h2>
<ul>
<li>
<p>粗暴型，禁用缩放
 <div class="codehilite"><pre><span class="o">&lt;</span><span class="nt">meta</span> <span class="nt">name</span><span class="o">=</span><span class="s2">&quot;viewport&quot;</span> <span class="nt">content</span><span class="o">=</span><span class="s2">&quot;wid-th=device-width, user-scalable=no&quot;</span><span class="o">&gt;</span>
</pre></div></p>
</li>
<li>
<p>利用FastClick，其原理是检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉(preventDefault)</p>
</li>
</ul>
<h2 id="_28">响应式布局<a class="headerlink" href="#_28" title="Permanent link"></a></h2>
<h5 id="_29">媒體查詢<a class="headerlink" href="#_29" title="Permanent link"></a></h5>
<p>略</p>
<h5 id="_30">百分比<a class="headerlink" href="#_30" title="Permanent link"></a></h5>
<h6 id="heightwidth">子元素height和width的百分比<a class="headerlink" href="#heightwidth" title="Permanent link"></a></h6>
<p>子元素的height或width中使用百分比，是相对于子元素的直接父元素，width相对于父元素的width，height相对于父元素的height。</p>
<h6 id="topbottom-leftright">top和bottom 、left和right<a class="headerlink" href="#topbottom-leftright" title="Permanent link"></a></h6>
<p>子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度;</p>
<p>同样子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度。</p>
<h6 id="padding-margin">padding 与 margin<a class="headerlink" href="#padding-margin" title="Permanent link"></a></h6>
<p>子元素的padding与margin如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。</p>
<h6 id="border-radius">border-radius<a class="headerlink" href="#border-radius" title="Permanent link"></a></h6>
<p>border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度。</p>
<h5 id="rem">rem<a class="headerlink" href="#rem" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">html</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">onWindowResize</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">html</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">fontSize</span> <span class="o">=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">getBoundingClientRect</span><span class="p">().</span><span class="nx">width</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">+</span> <span class="s1">&#39;px&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;resize&#39;</span><span class="p">,</span> <span class="nx">onWindowResize</span><span class="p">);</span>
    <span class="nx">onWindowResize</span><span class="p">();</span>
<span class="p">})();</span>
</pre></div>

<h6 id="px2rem">px2rem<a class="headerlink" href="#px2rem" title="Permanent link"></a></h6>
<p>webpack loader的形式：</p>
<div class="codehilite"><pre><span class="nx">npm</span> <span class="nx">install</span> <span class="nx">px2rem</span><span class="o">-</span><span class="nx">loader</span>
</pre></div>

<p>在webpack的配置文件中：</p>
<div class="codehilite"><pre><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
 <span class="c1">// ...</span>
 <span class="nx">module</span><span class="o">:</span> <span class="p">{</span>
   <span class="nx">rules</span><span class="o">:</span> <span class="p">[{</span>
     <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.css$/</span><span class="p">,</span>
     <span class="nx">use</span><span class="o">:</span> <span class="p">[{</span>
       <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;style-loader&#39;</span>
     <span class="p">},</span> <span class="p">{</span>
       <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;css-loader&#39;</span>
     <span class="p">},</span> <span class="p">{</span>
       <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;px2rem-loader&#39;</span><span class="p">,</span>
       <span class="c1">// options here</span>
       <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
         <span class="nx">remUni</span><span class="o">:</span> <span class="mi">75</span><span class="p">,</span>
         <span class="nx">remPrecision</span><span class="o">:</span> <span class="mi">8</span>
       <span class="p">}</span>
     <span class="p">}]</span>
   <span class="p">}]</span>
 <span class="p">}</span>
</pre></div>

<h6 id="rem_1">rem 布局的缺点<a class="headerlink" href="#rem_1" title="Permanent link"></a></h6>
<p>在响应式布局中，必须通过js来动态控制根元素font-size的大小。</p>
<h5 id="vw-vh">vw 与 vh<a class="headerlink" href="#vw-vh" title="Permanent link"></a></h5>
<p>css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p>
<p>比如对于iphone6/7 375*667的分辨率，那么px可以通过如下方式换算成vw：</p>
<div class="codehilite"><pre><span class="mi">1</span><span class="nx">px</span> <span class="o">=</span> <span class="err">（</span><span class="mi">1</span><span class="o">/</span><span class="mi">375</span><span class="err">）</span><span class="o">*</span><span class="mi">100</span> <span class="nx">vw</span>
</pre></div>

<h2 id="css">css盒模型<a class="headerlink" href="#css" title="Permanent link"></a></h2>
<p>CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型。</p>
<h5 id="_31">标准盒子模型<a class="headerlink" href="#_31" title="Permanent link"></a></h5>
<p>在标准的盒子模型中，width指content部分的宽度。（box-sizing：content-box）</p>
<h5 id="ie">IE盒子模型<a class="headerlink" href="#ie" title="Permanent link"></a></h5>
<p>在IE盒子模型中，width表示content+padding+border这三个部分的宽度。（box-sizing：border-box）</p>
<h2 id="05px">画0.5px宽的线<a class="headerlink" href="#05px" title="Permanent link"></a></h2>
<h5 id="svg">使用SVG<a class="headerlink" href="#svg" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="nc">.hr.svg</span> <span class="p">{</span>
  <span class="k">background</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
  <span class="k">height</span><span class="o">:</span> <span class="m">1px</span><span class="p">;</span>
  <span class="k">background</span><span class="o">:</span> <span class="sx">url(&quot;data:image/svg+xml;utf-8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;100%&#39; height=&#39;1px&#39;&gt;&lt;line x1=&#39;0&#39; y1=&#39;0&#39; x2=&#39;100%&#39; y2=&#39;0&#39; stroke=&#39;#000&#39;&gt;&lt;/line&gt;&lt;/svg&gt;&quot;)</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h5 id="meta-viewport">meta viewport<a class="headerlink" href="#meta-viewport" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;viewport&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;width=device-width,initial-sacle=1&quot;</span><span class="p">&gt;</span>
</pre></div>

<p>scale改成0.5：</p>
<div class="codehilite"><pre><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;viewport&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;width=device-width,initial-sacle=0.5&quot;</span><span class="p">&gt;</span>
</pre></div>

<h5 id="transform-scale">transform: scale<a class="headerlink" href="#transform-scale" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="nc">.hr.scale-half</span> <span class="p">{</span>
  <span class="k">height</span><span class="o">:</span> <span class="m">1px</span><span class="p">;</span>
  <span class="n">transform</span><span class="o">:</span> <span class="n">scaleY</span><span class="p">(</span><span class="m">0</span><span class="o">.</span><span class="m">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h2 id="transitionanimation">transition和animation的区别<a class="headerlink" href="#transitionanimation" title="Permanent link"></a></h2>
<h5 id="transition-transform">transition + Transform<a class="headerlink" href="#transition-transform" title="Permanent link"></a></h5>
<p>强调过渡，两个关键帧</p>
<ul>
<li>transition需要事件触发，所以没法在网页加载时自动发生。</li>
<li>transition是一次性的，不能重复发生，除非一再触发。</li>
<li>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</li>
<li>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</li>
</ul>
<h5 id="animation-keyframes">animation + <a class="magiclink magiclink-github magiclink-mention" href="https://github.com/keyframes" target="_blank" rel="noopener" title="GitHub User: keyframes">@keyframes</a><a class="headerlink" href="#animation-keyframes" title="Permanent link"></a></h5>
<p>强调流程与控制，多个关键帧</p>
<ul>
<li>不需要触发，页面一加载就可以开始</li>
<li>通过keyframes控制动画的多种状态</li>
</ul>
<h2 id="bfc">BFC(块级格式化上下文)<a class="headerlink" href="#bfc" title="Permanent link"></a></h2>
<p>块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。</p>
<ul>
<li>BFC区域不会与float box重叠</li>
<li>BFC是页面上的一个独立容器，子元素不会影响到外面</li>
<li>计算BFC的高度时，浮动元素也会参与计算</li>
</ul>
<p>那些元素会生成BFC：</p>
<ul>
<li>根元素</li>
<li>float不为none的元素</li>
<li>position为fixed和absolute的元素</li>
<li>display为inline-block、table-cell、table-caption，flex，inline-flex的元素</li>
<li>overflow不为hidden|auto|scroll的元素</li>
</ul>
<p>BFC</p>
<ul>
<li>不和浮动元素重叠</li>
<li>清除元素内部浮动</li>
<li>防止垂直 margin 重叠（父子或者兄弟元素）</li>
</ul>
<h2 id="_32">单行与多行省略<a class="headerlink" href="#_32" title="Permanent link"></a></h2>
<div class="codehilite"><pre><span class="nt">p</span><span class="p">{</span>
    <span class="k">overflow</span><span class="o">:</span><span class="k">hidden</span><span class="p">;</span>
    <span class="k">white-space</span><span class="o">:</span><span class="k">nowrap</span><span class="p">;</span>
    <span class="k">text</span><span class="o">-</span><span class="k">overflow</span><span class="o">:</span><span class="n">ellipsis</span><span class="p">;</span>
<span class="p">}</span>

<p><span class="nt">div</span><span class="p">{</span><br>    <span class="k">display</span><span class="o">:</span> <span class="o">-</span><span class="n">webkit</span><span class="o">-</span><span class="n">box</span><span class="p">;</span><br>    <span class="o">-</span><span class="n">webkit</span><span class="o">-</span><span class="n">box</span><span class="o">-</span><span class="n">orient</span><span class="o">:</span><span class="n">vertical</span><span class="p">;</span><br>    <span class="o">-</span><span class="n">webkit</span><span class="o">-</span><span class="n">line</span><span class="o">-</span><span class="n">clamp</span><span class="o">:</span><span class="m">3</span><span class="p">;</span><br>    <span class="k">overflow</span><span class="o">:</span><span class="k">hidden</span><span class="p">;</span><br><span class="p">}</span><br></pre></div></p>
<h2 id="_33">双边距重叠<a class="headerlink" href="#_33" title="Permanent link"></a></h2>
<p>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠。</p>
<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和。</li>
</ul>
<h2 id="_34">数组去重<a class="headerlink" href="#_34" title="Permanent link"></a></h2>
<h6 id="tostring">利用对象的属性不能相同（有漏洞，数组值是引用类型时做键值会先调用toString）<a class="headerlink" href="#tostring" title="Permanent link"></a></h6>
<div class="codehilite"><pre><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">distinct</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
 <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
  <span class="nx">i</span><span class="p">,</span>
  <span class="nx">obj</span> <span class="o">=</span> <span class="p">{},</span>
  <span class="nx">result</span> <span class="o">=</span> <span class="p">[],</span>
  <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
 <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">obj</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]){</span> <span class="c1">//如果能查找到，证明数组元素重复了</span>
   <span class="nx">obj</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">56</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,];</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">distinct</span><span class="p">();</span>
</pre></div>

<h6 id="indexofforeach">利用indexOf以及forEach<a class="headerlink" href="#indexofforeach" title="Permanent link"></a></h6>
<h6 id="sort">利用数组sort方法先排序<a class="headerlink" href="#sort" title="Permanent link"></a></h6>
<div class="codehilite"><pre><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">distinct</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
 <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span><span class="nx">res</span> <span class="o">=</span> <span class="p">[];</span>
 <span class="k">if</span><span class="p">(</span><span class="nx">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">){</span> <span class="k">return</span> <span class="k">this</span><span class="p">;}</span>
 <span class="k">this</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span> <span class="c1">//先排序</span>
 <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]){</span>
   <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="c1">//最后那位不会重复</span>
 <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
 <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h6 id="es6set">利用ES6的set<a class="headerlink" href="#es6set" title="Permanent link"></a></h6>
<div class="codehilite"><pre><span class="c1">//利用Array.from将Set结构转换成数组</span>
<span class="kd">function</span> <span class="nx">dedupe</span><span class="p">(</span><span class="nx">array</span><span class="p">){</span>
 <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">array</span><span class="p">));</span>
<span class="p">}</span>
<span class="nx">dedupe</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>

<p><span class="c1">//拓展运算符(…)内部使用for…of循环</span><br><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span><br><span class="kd">let</span> <span class="nx">resultarr</span> <span class="o">=</span> <span class="p">[…</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">arr</span><span class="p">)];</span><br><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">resultarr</span><span class="p">);</span> <span class="c1">//[1,2,3]</span><br></pre></div></p>
<div class="codehilite"><pre><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">distinct</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
 <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
  <span class="nx">result</span> <span class="o">=</span> <span class="p">[],</span>
  <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
 <span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">i</span> <span class="p">,</span><span class="nx">arr</span><span class="p">){</span>  <span class="c1">//这里利用map，filter方法也可以实现</span>
  <span class="kd">var</span> <span class="nx">bool</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">//从传入参数的下一个索引值开始寻找是否存在重复</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">bool</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
   <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
 <span class="p">})</span>
 <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">distinct</span><span class="p">();</span>
</pre></div>

<h2 id="_35">排序算法<a class="headerlink" href="#_35" title="Permanent link"></a></h2>
<h5 id="_36">冒泡排序<a class="headerlink" href="#_36" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
<span class="p">}</span>

<p><span class="c1">//冒泡排序</span><br><span class="kd">function</span> <span class="nx">bubbleSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span><br>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">–</span><span class="p">)</span> <span class="p">{</span><br>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><br>            <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span><br>                <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><br>            <span class="p">}</span><br>        <span class="p">}</span><br>    <span class="p">}</span><br>    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span><br><span class="p">}</span><br></pre></div></p>
<h5 id="_37">选择排序<a class="headerlink" href="#_37" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="c1">//选择排序</span>
<span class="kd">function</span> <span class="nx">selectionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">index</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">index</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h5 id="_38">插入排序<a class="headerlink" href="#_38" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="c1">//插入排序</span>
<span class="kd">function</span> <span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">temp</span><span class="p">){</span>
            <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h5 id="_39">希尔排序<a class="headerlink" href="#_39" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="c1">//希尔排序</span>
<span class="kd">function</span> <span class="nx">shellSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">interval</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">interval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">interval</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">interval</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="nx">interval</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
                <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
                <span class="k">while</span><span class="p">(</span><span class="nx">index</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span> <span class="o">-</span> <span class="nx">interval</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">temp</span><span class="p">){</span>
                    <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">index</span><span class="p">,</span><span class="nx">index</span> <span class="o">-</span> <span class="nx">interval</span><span class="p">);</span>
                    <span class="nx">index</span> <span class="o">=</span> <span class="nx">index</span> <span class="o">-</span> <span class="nx">interval</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">interval</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">interval</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">interval</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h5 id="_40">归并排序<a class="headerlink" href="#_40" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="c1">//归并排序</span>
<span class="kd">function</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span><span class="p">;}</span>
    <span class="kd">var</span> <span class="nx">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">left</span><span class="p">,</span><span class="nx">right</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">step</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
        <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nx">right</span> <span class="o">=</span> <span class="nx">step</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">right</span> <span class="o">+</span> <span class="nx">step</span> <span class="o">&lt;=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">mergeArr</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">left</span><span class="p">,</span><span class="nx">left</span><span class="o">+</span><span class="nx">step</span><span class="p">,</span><span class="nx">right</span><span class="p">,</span><span class="nx">right</span><span class="o">+</span><span class="nx">step</span><span class="p">);</span>
            <span class="nx">left</span> <span class="o">=</span> <span class="nx">right</span> <span class="o">+</span> <span class="nx">step</span><span class="p">;</span>
            <span class="nx">right</span> <span class="o">=</span> <span class="nx">left</span> <span class="o">+</span> <span class="nx">step</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">right</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">mergeArr</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">left</span><span class="p">,</span><span class="nx">left</span><span class="o">+</span><span class="nx">step</span><span class="p">,</span><span class="nx">right</span><span class="p">,</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">step</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>

<p><span class="kd">function</span> <span class="nx">mergeArr</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">startLeft</span><span class="p">,</span> <span class="nx">stopLeft</span><span class="p">,</span> <span class="nx">startRight</span><span class="p">,</span> <span class="nx">stopRight</span><span class="p">){</span><br>    <span class="kd">var</span> <span class="nx">leftArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">stopLeft</span> <span class="o">-</span> <span class="nx">startLeft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><br>    <span class="kd">var</span> <span class="nx">rightArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">stopRight</span> <span class="o">-</span> <span class="nx">startRight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><br>    <span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="nx">startLeft</span><span class="p">;</span><br>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">leftArr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><br>        <span class="nx">leftArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">];</span><br>    <span class="p">}</span><br>    <span class="nx">k</span> <span class="o">=</span> <span class="nx">startRight</span><span class="p">;</span><br>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">rightArr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><br>        <span class="nx">rightArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">];</span><br>    <span class="p">}</span><br>    <span class="nx">rightArr</span><span class="p">[</span><span class="nx">rightArr</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span> <span class="c1">// 哨兵值</span><br>    <span class="nx">leftArr</span><span class="p">[</span><span class="nx">leftArr</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span> <span class="c1">// 哨兵值</span><br>    <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="nx">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><br>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">startLeft</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">stopRight</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><br>        <span class="k">if</span> <span class="p">(</span><span class="nx">leftArr</span><span class="p">[</span><span class="nx">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">rightArr</span><span class="p">[</span><span class="nx">n</span><span class="p">])</span> <span class="p">{</span><br>            <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rightArr</span><span class="p">[</span><span class="nx">n</span><span class="o">++</span><span class="p">];</span><br>        <span class="p">}</span><span class="k">else</span><span class="p">{</span><br>            <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">leftArr</span><span class="p">[</span><span class="nx">m</span><span class="o">++</span><span class="p">];</span><br>        <span class="p">}</span><br>    <span class="p">}</span><br><span class="p">}</span><br></pre></div></p>
<h5 id="_41">快速排序<a class="headerlink" href="#_41" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="c1">//快速排序</span>
<span class="kd">function</span> <span class="nx">qSort</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">lesser</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">greater</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">pivot</span> <span class="o">=</span> <span class="nx">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">pivot</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">lesser</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">greater</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">qSort</span><span class="p">(</span><span class="nx">lesser</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">pivot</span><span class="p">,</span> <span class="nx">qSort</span><span class="p">(</span><span class="nx">greater</span><span class="p">));</span>
<span class="p">}</span>

<p><span class="c1">//递归型</span><br><span class="kd">function</span> <span class="nx">recurQuickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">endIndex</span><span class="p">){</span><br>    <span class="k">if</span> <span class="p">(</span><span class="nx">startIndex</span> <span class="o">&gt;=</span> <span class="nx">endIndex</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span><span class="p">;}</span><br>    <span class="kd">var</span> <span class="nx">pivotIndex</span> <span class="o">=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">endIndex</span><span class="p">);</span><br>    <span class="nx">recurQuickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">pivotIndex</span><span class="p">);</span><br>    <span class="nx">recurQuickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">pivotIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="nx">endIndex</span><span class="p">);</span><br>    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span><br><span class="p">}</span></p>
<p><span class="c1">//非递归型</span><br><span class="kd">function</span>  <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span><br>    <span class="kd">var</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span><br>    <span class="kd">var</span> <span class="nx">param</span> <span class="o">=</span> <span class="p">{</span><br>        <span class="nx">start</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><br>        <span class="nx">end</span><span class="o">:</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><br>    <span class="p">}</span><br>    <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">param</span><span class="p">);</span><br>    <span class="k">while</span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span><br>        <span class="kd">var</span> <span class="nx">curParam</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span><br>        <span class="kd">var</span> <span class="nx">pivotIndex</span> <span class="o">=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">curParam</span><span class="p">.</span><span class="nx">start</span><span class="p">,</span><span class="nx">curParam</span><span class="p">.</span><span class="nx">end</span><span class="p">);</span><br>        <span class="k">if</span> <span class="p">(</span><span class="nx">curParam</span><span class="p">.</span><span class="nx">start</span> <span class="o">&lt;</span> <span class="nx">pivotIndex</span><span class="p">)</span> <span class="p">{</span><br>            <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><br>                <span class="nx">start</span><span class="o">:</span><span class="nx">curParam</span><span class="p">.</span><span class="nx">start</span><span class="p">,</span><br>                <span class="nx">end</span><span class="o">:</span><span class="nx">pivotIndex</span><br>            <span class="p">})</span><br>        <span class="p">}</span><br>        <span class="k">if</span> <span class="p">(</span><span class="nx">curParam</span><span class="p">.</span><span class="nx">end</span> <span class="o">&gt;</span> <span class="nx">pivotIndex</span><span class="p">)</span> <span class="p">{</span><br>            <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><br>                <span class="nx">start</span><span class="o">:</span><span class="nx">pivotIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><br>                <span class="nx">end</span><span class="o">:</span><span class="nx">curParam</span><span class="p">.</span><span class="nx">end</span><br>            <span class="p">})</span><br>        <span class="p">}</span><br>    <span class="p">}</span><br>    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span><br><span class="p">}</span></p>
<p><span class="c1">//交换左右位置</span><br><span class="kd">function</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">endIndex</span><span class="p">){</span><br>    <span class="kd">var</span> <span class="nx">pivot</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">];</span><br>    <span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="nx">startIndex</span><span class="p">,</span><span class="nx">end</span> <span class="o">=</span> <span class="nx">endIndex</span><span class="p">;</span><br>    <span class="k">while</span><span class="p">(</span><span class="nx">start</span> <span class="o">&lt;</span> <span class="nx">end</span><span class="p">){</span><br>        <span class="k">while</span><span class="p">(</span><span class="nx">start</span> <span class="o">&lt;</span> <span class="nx">end</span><span class="p">){</span><br>            <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">end</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">pivot</span><span class="p">)</span> <span class="p">{</span><br>                <span class="k">break</span><span class="p">;</span><br>            <span class="p">}</span><span class="k">else</span><span class="p">{</span><br>                <span class="nx">end</span><span class="o">–</span><span class="p">;</span><br>            <span class="p">}</span><br>        <span class="p">}</span><br>        <span class="k">while</span><span class="p">(</span><span class="nx">start</span> <span class="o">&lt;</span> <span class="nx">end</span><span class="p">){</span><br>            <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">pivot</span><span class="p">)</span> <span class="p">{</span><br>                <span class="k">break</span><span class="p">;</span><br>            <span class="p">}</span><span class="k">else</span><span class="p">{</span><br>                <span class="nx">start</span><span class="o">++</span><span class="p">;</span><br>            <span class="p">}</span><br>        <span class="p">}</span><br>        <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">start</span><span class="p">,</span><span class="nx">end</span><span class="p">);</span><br>    <span class="p">}</span><br>    <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">start</span><span class="p">);</span><br>    <span class="k">return</span> <span class="nx">start</span><span class="p">;</span><br><span class="p">}</span><br></pre></div></p>
<h2 id="linkimport">link和@import的区别<a class="headerlink" href="#linkimport" title="Permanent link"></a></h2>
<p>两者都是外部引用 CSS 的方式，但是存在一定的区别：</p>
<ul>
<li>link是XHTML标签，除了能够加载CSS，还可以定义RSS等其他事务；而@import属于CSS范畴，只可以加载CSS。</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后再加载。</li>
<li>link是XHTML标签，无兼容问题；@import则是在CSS2.1提出的，低版本的浏览器不支持</li>
<li>link支持使用Javascript控制DOM改变样式；而@import不支持。</li>
</ul>
<h2 id="css-js">css 动画和 js 动画的差异<a class="headerlink" href="#css-js" title="Permanent link"></a></h2>
<ul>
<li>代码复杂度，js 动画代码相对复杂一些</li>
<li>动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件</li>
<li>动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好</li>
</ul>
<h2 id="javascript_1"><a href="http://web.jobbole.com/88463/" target="_blank" rel="noopener">javascript 中常见的内存泄露陷阱</a><a class="headerlink" href="#javascript_1" title="Permanent link"></a></h2>
<ul>
<li>意外的全局变量</li>
<li>被遗漏的定时器和回调函数，回调函数中保持着外部变量的引用</li>
<li>js对DOM 的引用，即使该DOM节点被移除，若依然保持着引用，则该DOM节点依然在内存中</li>
<li>闭包</li>
</ul>
<h2 id="babeles6es5es3">babel把ES6转成ES5或者ES3之类的原理<a class="headerlink" href="#babeles6es5es3" title="Permanent link"></a></h2>
<p>它就是个编译器，输入语言是ES6+，编译目标语言是ES5。</p>
<ul>
<li>解析：将代码字符串解析成抽象语法树</li>
<li>变换：对抽象语法树进行变换操作</li>
<li>再建：根据变换后的抽象语法树再生成代码字符串</li>
</ul>
<h2 id="_42">前端工程与性能优化<a class="headerlink" href="#_42" title="Permanent link"></a></h2>
<table>
<thead>
<tr>
<th>优化方向</th>
<th>优化手段</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求数量</td>
<td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</td>
</tr>
<tr>
<td>请求带宽</td>
<td>开启GZip，精简JavaScript，移除重复脚本，图像优化</td>
</tr>
<tr>
<td>缓存利用</td>
<td>使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</td>
</tr>
<tr>
<td>页面结构</td>
<td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td>
</tr>
<tr>
<td>代码校验</td>
<td>避免CSS表达式，避免重定向</td>
</tr>
</tbody>
</table>
<h2 id="es6commonjs">ES6模块与CommonJS模块的差异<a class="headerlink" href="#es6commonjs" title="Permanent link"></a></h2>
<ul>
<li>CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用</li>
<li>CommonJS 模块是运行时加载，ES6模块是编译时输出接口</li>
<li>ES6输入的模块变量，只是一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错</li>
</ul>
<p>CommonJs所谓值的拷贝类似于对module.exports对象的一个浅拷贝，基本类型值无法被修改，引用类型值则依然保存着对模块的引用，类似闭包。</p>
<p>ES6模块输出的是值的引用，指的是import的对象保存着对模块的作用域的引用，并且该作用域是可以共享的。换句话说ES6模块export唯一一个实例，被所有import的对象共享。</p>
<h5 id="es6-commonjs">ES6 模块加载 CommonJS 模块<a class="headerlink" href="#es6-commonjs" title="Permanent link"></a></h5>
<p>Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。</p>
<div class="codehilite"><pre><span class="c1">// a.js</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span>
  <span class="nx">bar</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span>
<span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span>
  <span class="nx">bar</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span>
<span class="p">};</span>
</pre></div>

<h5 id="commonjs-es6">CommonJS 模块加载 ES6 模块<a class="headerlink" href="#commonjs-es6" title="Permanent link"></a></h5>
<p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</p>
<div class="codehilite"><pre><span class="c1">// es.js</span>
<span class="kr">export</span> <span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">bar</span><span class="o">:</span><span class="s1">&#39;my-default&#39;</span> <span class="p">};</span>
<span class="kr">export</span> <span class="p">{</span> <span class="nx">foo</span> <span class="nx">as</span> <span class="nx">bar</span> <span class="p">};</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{};</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">c</span> <span class="p">{};</span>

<p><span class="c1">// cjs.js</span><br><span class="kr">const</span> <span class="nx">es_namespace</span> <span class="o">=</span> <span class="nx">await</span> <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./es&#39;</span><span class="p">);</span><br><span class="c1">// es_namespace = {</span><br><span class="c1">//   get foo() {return foo;}</span><br><span class="c1">//   get bar() {return foo;}</span><br><span class="c1">//   get f() {return f;}</span><br><span class="c1">//   get c() {return c;}</span><br><span class="c1">// }</span><br></pre></div></p>
<h2 id="_43">浅拷贝和深拷贝的问题<a class="headerlink" href="#_43" title="Permanent link"></a></h2>
<ul>
<li>深拷贝和浅拷贝是只针对Object和Array这样的复杂类型的</li>
<li>也就是说a和b指向了同一块内存，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</li>
<li>浅拷贝， ”Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象</li>
<li>深拷贝，JSON.parse()和JSON.stringify()给了我们一个基本的解决办法。但是函数不能被正确处理</li>
</ul>
<div class="codehilite"><pre><span class="c1">//深拷贝</span>
<span class="kd">function</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">Obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">Obj</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">buf</span> <span class="o">=</span> <span class="p">[];</span>  <span class="c1">// 创建一个空的数组</span>
        <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">Obj</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">buf</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">Obj</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">buf</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">Obj</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">){</span>
        <span class="nx">buf</span> <span class="o">=</span> <span class="p">{};</span>  <span class="c1">// 创建一个空对象</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="k">in</span> <span class="nx">Obj</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 为这个对象添加新的属性</span>
            <span class="nx">buf</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">Obj</span><span class="p">[</span><span class="nx">k</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">buf</span><span class="p">;</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">Obj</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="http-https">http 与 https<a class="headerlink" href="#http-https" title="Permanent link"></a></h2>
<h5 id="http">http的不足：<a class="headerlink" href="#http" title="Permanent link"></a></h5>
<ul>
<li>通信使用明文，可能会被窃听</li>
<li>不验证通信方的身份，可能遭遇伪装</li>
<li>无法证明报文的完整性，可能遭遇篡改</li>
</ul>
<h5 id="https">何为https?<a class="headerlink" href="#https" title="Permanent link"></a></h5>
<p><strong>http + 加密 + 验证 + 完整性保护 = https</strong></p>
<h5 id="https_1">https的原理<a class="headerlink" href="#https_1" title="Permanent link"></a></h5>
<p>https并非应用层上一种新的协议，而是http通信接口部分用SSL（Secure Socket Layer，安全套接层）和TLS（Transport Layer Security，传输安全协议）协议代替。</p>
<p>通常情况下，http与TCP直接通信，当使用SSL时，就演变层先跟SSL通信，再由SSL与TCP通信。</p>
<p>所谓的https，也就是身披SSL协议外壳的http。</p>
<h5 id="ssl">SSL如何加密？<a class="headerlink" href="#ssl" title="Permanent link"></a></h5>
<p>SSL使用的是一种公开密钥加密（Public-key cryptography）的加密方式。</p>
<p>加密方法中，加密算法是公开的，密钥是保密的，加密跟解密都需要用到密钥。</p>
<h6 id="common-key-cryto-system">共享密钥加密（Common key cryto system）<a class="headerlink" href="#common-key-cryto-system" title="Permanent link"></a></h6>
<p>加密与解密使用同一个密钥，也被称为对称密钥加密。</p>
<p>不足：密钥能够安全发送，信息也能安全发送。</p>
<h6 id="_44">公开密钥加密<a class="headerlink" href="#_44" title="Permanent link"></a></h6>
<p>公开密钥加密使用一对非对称的密钥，一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。</p>
<p>发送密文的一方使用公开密钥加密，对方收到信息之后，再使用私有密钥解密。</p>
<h5 id="https_2">https使用混合加密机制<a class="headerlink" href="#https_2" title="Permanent link"></a></h5>
<p>公开密钥加密与共享密钥加密相比，其处理速度要慢，所以需要利用其各自的优势。</p>
<p>在交换密钥阶段使用公开密钥加密的方式，之后建立通信交换报文阶段则使用共享密钥加密的方式。</p>
<h5 id="_45">公开密钥的可靠性证明<a class="headerlink" href="#_45" title="Permanent link"></a></h5>
<p>解决方法是，使用数据证书认证机构（CA,Certificate Authority）和其相关机构颁布的公开密钥证书。</p>
<ul>
<li>提出公开密钥申请</li>
<li>数字证书认证机构对公开密钥做数字签名，颁发公钥证书</li>
<li>服务器发送公钥证书给客户端，进行公开密钥加密通信</li>
<li>客户端使用内置的数据证书认证机构的公开密钥，对公钥证书的数字签名进行认证。</li>
</ul>
<p>数据证书认证机构的公开密钥必须安全的转交给客户端，使用通信方式进行安全转交是一件非常困难的事情，所以，浏览器发布时，一般会事先植入认证机构的公开密钥。</p>
<h2 id="tcp">TCP三次握手<a class="headerlink" href="#tcp" title="Permanent link"></a></h2>
<p>TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<ul>
<li>第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN-SEND状态，等待服务器B确认。</li>
<li>第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN-RECV状态。</li>
<li>第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<p>完成三次握手，客户端与服务器开始传送数据。</p>
<p>LISTEN - 侦听来自远方TCP端口的连接请求；
SYN-SENT -在发送连接请求后等待匹配的连接请求；
SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；
ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p>
<h2 id="tcp_1">TCP四次挥手<a class="headerlink" href="#tcp_1" title="Permanent link"></a></h2>
<p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<ul>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ul>
<h2 id="tcpudp">TCP和UDP的区别<a class="headerlink" href="#tcpudp" title="Permanent link"></a></h2>
<p>“信道复用技术”实现了，在同一条线路上，单位时间内可供X台计算机同时通信。</p>
<p>一个TCP协议连接其实就是在物理线路上创建的一条“虚拟信道”。这条“虚拟信道”建立后，在TCP协议发出FIN包之前（两个终端都会向对方发送一个FIN包），是不会释放的。正因为这一点，TCP协议被称为面向连接的协议！</p>
<p>UDP协议，一样会在物理线路上创建一条“虚拟信道”，否则UDP协议无法传输数据！但是，当UDP协议传完数据后，这条“虚拟信道”就被立即注销了！因此，称UDP是不面向连接的协议！</p>
<ul>
<li>TCP协议提供了可靠的数据传输,但是其拥塞控制、数据校验、重传机制的网络开销很大,不适合实时通信。</li>
<li>UDP 协议是无连接的数据传输协议并且无重传机制,会发生丢包、收到重复包、乱序等情况。而对于数据精确性要求不高的状态数据以及视频数据,丢包的影响不大。</li>
</ul>
<p>基于TCP的应用层协议有：SMTP、TELNET、HTTP、FTP；</p>
<p>基于UDP的应用层协议：DNS、TFTP（简单文件传输协议）、RIP（路由选择协议）、DHCP、BOOTP（是DHCP的前身）、IGMP（Internet组管理协议）</p>
<h2 id="_46">函数柯里化<a class="headerlink" href="#_46" title="Permanent link"></a></h2>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">innerArgs</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">finalArgs</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">innerArgs</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">finalArgs</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>

<h2 id="ajax_2">原生Ajax书写<a class="headerlink" href="#ajax_2" title="Permanent link"></a></h2>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">createXHR</span><span class="p">(){</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">XMLHttpRequest</span> <span class="o">!=</span> <span class="s2">&quot;undefined&quot;</span><span class="p">){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">ActiveXObject</span> <span class="o">!=</span> <span class="s2">&quot;undefined&quot;</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">versions</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;MSXML2.XMLHttp.6.0&quot;</span><span class="p">,</span> <span class="s2">&quot;MSXML2.XMLHttp.3.0&quot;</span><span class="p">,</span> <span class="s2">&quot;MSXML2.XMLHttp&quot;</span><span class="p">],</span>
        <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span><span class="nx">xml</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="nx">len</span><span class="o">=</span><span class="nx">versions</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="nx">xml</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ActiveXObject</span><span class="p">(</span><span class="nx">versions</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">ex</span><span class="p">){</span><span class="c1">//跳过</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">xml</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;No XHR object available.&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="nx">createXHR</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">// 通信成功时，状态值为4</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="mi">4</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">200</span><span class="p">){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">responseText</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;/endpoint&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</pre></div>

<h2 id="websocket">webSocket<a class="headerlink" href="#websocket" title="Permanent link"></a></h2>
<p>WebSocket protocol 是HTML5一种新的协议。它是实现了浏览器与服务器全双工通信(full-duplex)。HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽并达到实时通讯。</p>
<p>在WebSocket出现之前，一般通过两种方式来实现Web实时用：轮询机制和流技术；其中轮询有不同的轮询，还有一种叫Comet的长轮询。</p>
<ul>
<li>轮询：这是最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的同步。这种同步方案的缺点是，当客户端以固定频率向服务器发起请求的时候，服务器端的数据可能并没有更新，这样会带来很多<strong>无谓的网络传输</strong>，所以这是一种非常低效的实时方案。</li>
<li>长轮询：是对定时轮询的改进和提高，目地是为了降低无效的网络传输。当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互。当然，如果服务端的数据变更非常频繁的话，这种机制和定时轮询比较起来没有本质上的性能的提高。</li>
<li>流：常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个<strong>长连接的请求</strong>。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务 器端的连接不过期。通过这种机制可以将服务器端的信息源源不断地推向客户端。这种机制在用户体验上有一点问题，需要针对不同的浏览器设计不同的方案来改进 用户体验，同时这种机制在并发比较大的情况下，对服务器端的资源是一个极大的考验。</li>
</ul>
<p>WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
<h2 id="_47">浏览器兼容性问题<a class="headerlink" href="#_47" title="Permanent link"></a></h2>
<h5 id="css_1">CSS常见兼容性问题<a class="headerlink" href="#css_1" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="o">&lt;</span><span class="nx">meta</span> <span class="nx">http</span><span class="o">-</span><span class="nx">equiv</span><span class="o">=</span><span class="s2">&quot;X-UA-Compatible&quot;</span> <span class="nx">content</span><span class="o">=</span><span class="s2">&quot;IE=edge,chrome=1&quot;</span> <span class="o">/&gt;</span>
<span class="c1">//如果当前IE浏览器安装了Google Chrome Frame(GCF)插件，则以chrome内核渲染页面，否则就以当前IE浏览器支持的最高版本模式来渲染</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//rgba不支持IE8及以下 解决：用opacity或者filter</span>
<span class="nx">background</span><span class="o">:</span> <span class="nx">rgba</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mf">0.1</span><span class="p">);</span>
<span class="nx">filter</span><span class="o">:</span><span class="nx">progid</span><span class="o">:</span><span class="nx">DXImageTransform</span><span class="p">.</span><span class="nx">Microsoft</span><span class="p">.</span><span class="nx">gradient</span><span class="p">(</span><span class="nx">startColorstr</span><span class="o">=</span><span class="err">#</span><span class="mi">19</span><span class="nx">ffffff</span><span class="p">,</span><span class="nx">endColorstr</span><span class="o">=</span><span class="err">#</span><span class="mi">19</span><span class="nx">ffffff</span><span class="p">);</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//transition不支持IE10及以下 解决：用js实现过渡动画</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//background-size不支持IE8，可以用img</span>
<span class="nx">background</span><span class="o">:</span> <span class="nx">url</span><span class="p">(</span><span class="nx">img</span><span class="o">/</span><span class="nx">aaa</span><span class="p">.</span><span class="nx">jpg</span><span class="p">)</span> <span class="nx">no</span><span class="o">-</span><span class="nx">repeat</span> <span class="nx">center</span> <span class="nx">center</span><span class="p">;</span>
<span class="nx">background</span><span class="o">-</span><span class="nx">size</span><span class="o">:</span> <span class="mi">100</span><span class="o">%</span> <span class="mi">100</span><span class="o">%</span><span class="p">;</span>
<span class="cm">/*针对IE8的hack，目的是除掉之前background*/</span>
<span class="nx">background</span><span class="o">:</span> <span class="nx">none</span><span class="err">\</span><span class="mi">9</span><span class="p">;</span>
<span class="cm">/*下一行为关键设置*/</span>
<span class="nx">filter</span><span class="o">:</span><span class="nx">progid</span><span class="o">:</span><span class="nx">DXImageTransform</span><span class="p">.</span><span class="nx">Microsoft</span><span class="p">.</span><span class="nx">AlphaImageLoader</span><span class="p">(</span><span class="nx">src</span><span class="o">=</span><span class="s1">&#39;img/aaa.jpg&#39;</span><span class="p">,</span> <span class="nx">sizingMethod</span><span class="o">=</span><span class="s1">&#39;scale&#39;</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">原理：</span>
<span class="cm">filter : progid:DXImageTransform.Microsoft.AlphaImageLoader ( enabled=bEnabled , sizingMethod=sSize , src=sURL )</span>
<span class="cm">enabled：可选项。布尔值(Boolean)。设置或检索滤镜是否激活。 true：默认值。滤镜激活。 false：滤镜被禁止。</span>
<span class="cm">sizingMethod：可选项。字符串(String)。设置或检索滤镜作用的对象的图片在对象容器边界内的显示方式。 crop：剪切图片以适应对象尺寸。 image：默认值。增大或减小对象的尺寸边界以适应图片的尺寸。 scale：缩放图片以适应对象的尺寸边界。</span>
<span class="cm">src：必选项。字符串(String)。使用绝对或相对 url 地址指定背景图像。假如忽略此参数，滤镜将不会作用。</span>
<span class="cm">*/</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//使用PIE.htc让IE6/7/8支持CSS3部分属性，像CSS3的border-radius，box-shadow，css backgrounds(-pie-background),Gradients,RGBA属性</span>
<span class="nx">div</span><span class="p">{</span>
    <span class="nx">border</span><span class="o">-</span><span class="nx">radius</span><span class="o">:</span> <span class="mi">10</span><span class="nx">px</span><span class="p">;</span>
    <span class="o">-</span><span class="nx">webkit</span><span class="o">-</span><span class="nx">border</span><span class="o">-</span><span class="nx">radius</span><span class="o">:</span> <span class="mi">10</span><span class="nx">px</span><span class="p">;</span>
    <span class="o">-</span><span class="nx">moz</span><span class="o">-</span><span class="nx">border</span><span class="o">-</span><span class="nx">radius</span><span class="o">:</span> <span class="mi">10</span><span class="nx">px</span><span class="p">;</span>
    <span class="nx">background</span><span class="o">:</span> <span class="err">#</span><span class="nx">abcdef</span><span class="p">;</span>
    <span class="nx">behavior</span><span class="o">:</span> <span class="nx">url</span><span class="p">(</span><span class="nx">css</span><span class="o">/</span><span class="nx">PIE</span><span class="p">.</span><span class="nx">htc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//用css hack</span>
<span class="nx">IE6</span><span class="o">:</span> <span class="nx">_</span>
<span class="nx">IE7</span><span class="o">/</span><span class="mi">7</span><span class="o">:</span> <span class="o">*</span>
<span class="nx">IE7</span><span class="o">/</span><span class="nx">Firefox</span><span class="o">:</span> <span class="o">!</span><span class="nx">important</span>
<span class="nx">IE7</span><span class="o">:</span> <span class="o">*+</span>
<span class="nx">IE6</span><span class="o">/</span><span class="mi">7</span><span class="o">/</span><span class="mi">8</span><span class="o">:</span> <span class="mi">9</span>
<span class="nx">IE8</span><span class="o">:</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//按钮button添加type属性，IE下的默认类型是button，其他浏览器下的默认类型是submit</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//识别HTML5元素，IE9以下可能无法识别nav/footer，使用html5shiv</span>
<span class="c1">//有一点需要注意，在页面中调用html5shiv.js文件必须添加在页面的head元素内，因为IE浏览器必须在元素解析前知道这个元素</span>
<span class="c">&lt;!--</span><span class="p">[</span><span class="k">if</span> <span class="nx">lt</span> <span class="nx">IE</span> <span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&quot;text/javascript&quot;</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;js/html5shiv.js&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span>
<span class="o">&lt;!</span><span class="p">[</span><span class="nx">endif</span><span class="p">]</span><span class="o">--&gt;</span>
</pre></div>

<h5 id="js_2">JS常见兼容性问题<a class="headerlink" href="#js_2" title="Permanent link"></a></h5>
<div class="codehilite"><pre><span class="c1">//解决 IE8 不支持console</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">console</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">console</span> <span class="o">||</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{};</span> <span class="nx">c</span><span class="p">.</span><span class="nx">log</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">warn</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">debug</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">info</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">error</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">time</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dir</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">profile</span>
    <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">clear</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">exception</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">trace</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">assert</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
    <span class="k">return</span> <span class="nx">c</span><span class="p">;</span>
<span class="p">})();</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//W3C标准规定，事件对象是作为函数的参数传入的，唯独在IE下是行不通的，IE采用了一种非标准的方式，将事件对象作为window对象的event属性。</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">ev</span><span class="p">){</span>
    <span class="nx">ev</span> <span class="o">=</span> <span class="nx">ev</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">event</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<div class="codehilite"><pre><span class="cm">/*</span>
<span class="cm">IE6/7/8：</span>
<span class="cm">对于没有doctype声明的页面里可以使用  document.body.scrollTop 来获取 scrollTop高度;</span>
<span class="cm">对于有doctype声明的页面则可以使用 document.documentElement.scrollTop；</span>

<p><span class="cm">Safari:</span><br><span class="cm">safari 比较特别，有自己获取scrollTop的函数 ： window.pageYOffset ；</span><br><span class="cm">*/</span><br><span class="kd">var</span> <span class="nx">scrollTop</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">pageYOffset</span> <span class="o">||</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">scrollTop</span><span class="p">;</span><br></pre></div></p>
<div class="codehilite"><pre><span class="c1">//new date() 注意兼容性问题</span>
<span class="c1">//对默认的日期格式进行转换， 基于&#39;/&#39;格式的日期字符串，才是被各个浏览器所广泛支持的，‘-’连接的日期字符串，则是只在chrome下可以正常工作。</span>
<span class="kd">var</span> <span class="nx">time</span><span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">timeStr</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/-/g</span><span class="p">,</span><span class="s2">&quot;/&quot;</span><span class="p">))).</span><span class="nx">getTime</span><span class="p">();</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//attachEvent与addEventlistener兼容性</span>
<span class="kd">var</span> <span class="nx">EventUtil</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">addHandler</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span><span class="nx">type</span><span class="p">,</span><span class="nx">handler</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">){</span>
            <span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span><span class="nx">handler</span><span class="p">,</span><span class="kc">false</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">){</span>
            <span class="nx">element</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">(</span><span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">,</span><span class="nx">handler</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">element</span><span class="p">[</span><span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">]</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">removeHandler</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span><span class="nx">type</span><span class="p">,</span><span class="nx">handler</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">){</span>
            <span class="nx">element</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span><span class="nx">handler</span><span class="p">,</span><span class="kc">false</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">detachEvent</span><span class="p">){</span>
            <span class="nx">element</span><span class="p">.</span><span class="nx">detachEvent</span><span class="p">(</span><span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">,</span><span class="nx">handler</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">element</span><span class="p">[</span><span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//window.getComputedStyle能够获取元素的实际样式，但是低版本的ie8及以下不支持</span>
<span class="c1">//获取当前样式</span>
<span class="kd">function</span> <span class="nx">getStyle</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">attr</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">getComputedStyle</span><span class="p">){</span>
        <span class="c1">//优先使用W3C规范</span>
        <span class="k">return</span> <span class="nb">window</span><span class="p">.</span><span class="nx">getComputedStyle</span><span class="p">(</span><span class="nx">element</span><span class="p">)[</span><span class="nx">attr</span><span class="p">];</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="c1">//针对IE9以下兼容</span>
        <span class="k">return</span> <span class="nx">element</span><span class="p">.</span><span class="nx">currentStyle</span><span class="p">[</span><span class="nx">attr</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="_48">水平垂直居中<a class="headerlink" href="#_48" title="Permanent link"></a></h2>
<p>方法一：</p>
<div class="codehilite"><pre><span class="nf">#container</span><span class="p">{</span>
    <span class="k">position</span><span class="o">:</span><span class="k">relative</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">#center</span><span class="p">{</span>
    <span class="k">width</span><span class="o">:</span><span class="m">100px</span><span class="p">;</span>
    <span class="k">height</span><span class="o">:</span><span class="m">100px</span><span class="p">;</span>
    <span class="k">position</span><span class="o">:</span><span class="k">absolute</span><span class="p">;</span>
    <span class="k">top</span><span class="o">:</span><span class="m">50%</span><span class="p">;</span>
    <span class="k">left</span><span class="o">:</span><span class="m">50%</span><span class="p">;</span>
    <span class="n">transform</span><span class="o">:</span> <span class="n">translate</span><span class="p">(</span><span class="m">-50%</span><span class="o">,-</span><span class="m">50%</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>方法二：</p>
<div class="codehilite"><pre><span class="nf">#container</span><span class="p">{</span>
    <span class="k">position</span><span class="o">:</span><span class="k">relative</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">#center</span><span class="p">{</span>
    <span class="k">position</span><span class="o">:</span><span class="k">absolute</span><span class="p">;</span>
    <span class="k">margin</span><span class="o">:</span><span class="k">auto</span><span class="p">;</span>
    <span class="k">top</span><span class="o">:</span><span class="m">0</span><span class="p">;</span>
    <span class="k">bottom</span><span class="o">:</span><span class="m">0</span><span class="p">;</span>
    <span class="k">left</span><span class="o">:</span><span class="m">0</span><span class="p">;</span>
    <span class="k">right</span><span class="o">:</span><span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>方法三：</p>
<div class="codehilite"><pre><span class="nf">#container</span><span class="p">{</span>
    <span class="k">display</span><span class="o">:</span><span class="n">flex</span><span class="p">;</span>
    <span class="k">justify</span><span class="o">-</span><span class="k">content</span><span class="o">:</span><span class="k">center</span><span class="p">;</span>
    <span class="n">align</span><span class="o">-</span><span class="n">items</span><span class="o">:</span> <span class="k">center</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h2 id="es5class">ES5继承与Class继承的区别<a class="headerlink" href="#es5class" title="Permanent link"></a></h2>
<p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。</p>
<p>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<h2 id="_49">垃圾回收机制<a class="headerlink" href="#_49" title="Permanent link"></a></h2>
<p>在编写 JavaScript 程序时，开发人员无需关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了<strong>自动管理</strong>。</p>
<p>这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），<strong>周期性</strong>地执行这一操作。</p>
<h5 id="_50">标记清除<a class="headerlink" href="#_50" title="Permanent link"></a></h5>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<h5 id="_51">引用计数<a class="headerlink" href="#_51" title="Permanent link"></a></h5>
<p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p>
<h2 id="line-height">line-height<a class="headerlink" href="#line-height" title="Permanent link"></a></h2>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td>默认,设置合理的行间距。</td>
</tr>
<tr>
<td>number</td>
<td>设置数字，此数字会与当前的字体尺寸相乘来设置行间距。相当于倍数</td>
</tr>
<tr>
<td>length</td>
<td>设置固定的行间距。</td>
</tr>
<tr>
<td>%</td>
<td>基于当前字体尺寸的百分比行间距。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 line-height 属性的值。</td>
</tr>
</tbody>
</table>
<div class="codehilite"><pre><span class="o">&lt;</span><span class="nt">div</span> <span class="nt">style</span><span class="o">=</span><span class="s2">&quot;border:dashed 1px #0e0;line-height: 150%;font-size:10px;&quot;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nt">p</span> <span class="nt">style</span><span class="o">=</span><span class="s2">&quot;font-size:30px;&quot;</span><span class="o">&gt;</span>
        <span class="nt">1232</span><span class="o">&lt;</span><span class="nt">br</span><span class="o">/&gt;</span>
        <span class="nt">123</span>
    <span class="o">&lt;/</span><span class="nt">p</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="nt">div</span><span class="o">&gt;</span>
</pre></div>

<p>如果父元素的line-height<strong>有单位（px、%）</strong>,那么继承的值则是换算后的一个具体的px级别的值；上例p得到的是10px*150%=15px的行高，而P的字体大小为30px，所以发生了重叠。</p>
<p>而如果属性值没有单位，则浏览器会直接继承这个“因子（数值）”，而非计算后的具体值，此时它的line-height会根据本身的font-size值重新计算得到新的line-height 值。</p>
<h2 id="ie_1">标准盒子模型和IE模型的区别<a class="headerlink" href="#ie_1" title="Permanent link"></a></h2>
<h5 id="_52">标准盒子模型<a class="headerlink" href="#_52" title="Permanent link"></a></h5>
<p>标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。</p>
<p>w3c中的盒子模型的宽:包括margin+border+padding+width;
<div class="codehilite"><pre><span class="nt">width</span><span class="nd">:margin</span><span class="o">*</span><span class="nt">2</span><span class="o">+</span><span class="nt">border</span><span class="o">*</span><span class="nt">2</span><span class="o">+</span><span class="nt">padding</span><span class="o">*</span><span class="nt">2</span><span class="o">+</span><span class="nt">width</span><span class="o">;</span>
<span class="nt">height</span><span class="nd">:margin</span><span class="o">*</span><span class="nt">2</span><span class="o">+</span><span class="nt">border</span><span class="o">*</span><span class="nt">2</span><span class="o">+</span><span class="nt">padding</span><span class="o">*</span><span class="nt">2</span><span class="o">+</span><span class="nt">height</span><span class="o">;</span>
</pre></div></p>
<h5 id="ie_2">IE 盒子模型<a class="headerlink" href="#ie_2" title="Permanent link"></a></h5>
<p>iE中的盒子模型的width:也包括margin+border+padding+width;</p>
<p>上面的两个宽度相加的属性是一样的。不过在ie中content的宽度包括padding和border这两个属性；</p>
<h2 id="html5html5-html-html5">html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？<a class="headerlink" href="#html5html5-html-html5" title="Permanent link"></a></h2>
<h5 id="_53">新特性：<a class="headerlink" href="#_53" title="Permanent link"></a></h5>
<p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<div class="codehilite"><pre>1. 拖拽释放(Drag and drop) API
2. 语义化更好的内容标签（header,nav,footer,aside,article,section）
3. 音频、视频API(audio,video)
4. 画布(Canvas) API
5. 地理(Geolocation) API
6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
7. sessionStorage 的数据在浏览器关闭后自动删除
8. 表单控件，calendar、date、time、email、url、search
9. 新的技术webworker, websocket, Geolocation
</pre></div>


<p>移除的元素：
1. 纯表现的元素：basefont，big，center，font, s，strike，tt，u；
2. 对可用性产生负面影响的元素：frame，frameset，noframes；</p>
<h5 id="html5">支持HTML5新标签：<a class="headerlink" href="#html5" title="Permanent link"></a></h5>
<p>IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）：</p>
<p><div class="codehilite"><pre><span class="c">&lt;!--[if lt IE 9]&gt;</span>
<span class="c">&lt;script&gt; src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; </span>
<span class="c">&lt;![endif]--&gt;</span>
</pre></div>
如何区分：
DOCTYPE声明新增的结构元素、功能元素</p>
<h2 id="css3">CSS3有哪些新特性？<a class="headerlink" href="#css3" title="Permanent link"></a></h2>
<div class="codehilite"><pre>1. CSS3实现圆角（border-radius），阴影（box-shadow），
2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
3. transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜
4. 增加了更多的CSS选择器  多背景 rgba
5. 在CSS3中唯一引入的伪类是 ::selection.
6. 媒体查询，多栏布局
7. border-image
</pre></div>


<h2 id="iframe">iframe的优缺点？<a class="headerlink" href="#iframe" title="Permanent link"></a></h2>
<p>优点：</p>
<div class="codehilite"><pre>1. 解决加载缓慢的第三方内容如图标和广告等的加载问题
2. Security sandbox
3. 并行加载脚本
</pre></div>


<p>缺点：</p>
<div class="codehilite"><pre>1. iframe会阻塞主页面的Onload事件
2. 即时内容为空，加载也需要时间
3. 没有语意
</pre></div>


<h2 id="doctype">Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?<a class="headerlink" href="#doctype" title="Permanent link"></a></h2>
<ul>
<li><code>&lt;!DOCTYPE&gt;</code>声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器以何种模式来渲染文档。</li>
<li>严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。</li>
<li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</li>
<li>DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</li>
</ul>
<h2 id="fouc-fouc">什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？<a class="headerlink" href="#fouc-fouc" title="Permanent link"></a></h2>
<p><strong>FOUC - Flash Of Unstyled Content</strong> 文档样式闪烁<style type="text/css" media="all"><a class="magiclink magiclink-github magiclink-mention" href="https://github.com/import" target="_blank" rel="noopener" title="GitHub User: import">@import</a> &ldquo;../fouc.css&rdquo;;</style> 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</p>
<p>解决方法简单的出奇，只要在<code>&lt;head&gt;</code>之间加入一个<code>&lt;link&gt;</code>或者<code>&lt;script&gt;</code>元素就可以了。</p>
<h2 id="url">一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？<a class="headerlink" href="#url" title="Permanent link"></a></h2>
<ol>
<li>当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。</li>
<li>浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</li>
<li>一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。</li>
<li>此时，Web 服务器提供资源服务，客户端开始下载资源。</li>
</ol>
<p>请求返回后，便进入了我们关注的前端模块
简单来说，浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM</p>
<h2 id="js-cookie">js 操作获取和设置 cookie<a class="headerlink" href="#js-cookie" title="Permanent link"></a></h2>
<div class="codehilite"><pre><span class="c1">// 创建cookie</span>
<span class="kd">function</span> <span class="nx">setCookie</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">expires</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">secure</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">cookieText</span> <span class="o">=</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">expires</span> <span class="k">instanceof</span> <span class="nb">Date</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s1">&#39;; expires=&#39;</span> <span class="o">+</span> <span class="nx">expires</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">&quot;; path=&quot;</span> <span class="o">+</span> <span class="nx">path</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s1">&#39;; domain=&#39;</span> <span class="o">+</span> <span class="nx">domain</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">secure</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s1">&#39;; secure&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="nx">cookieText</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 获取cookie</span>
<span class="kd">function</span> <span class="nx">getCookie</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">cookieName</span> <span class="o">=</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">cookieStart</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">cookieName</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">cookieValue</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">cookieStart</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">cookieEnd</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="nx">cookieStart</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">cookieEnd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">cookieEnd</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">cookieValue</span> <span class="o">=</span> <span class="nb">decodeURIComponent</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">cookieStart</span> <span class="o">+</span> <span class="nx">cookieName</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">cookieEnd</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cookieValue</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 删除cookie</span>
<span class="kd">function</span> <span class="nx">unsetCookie</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;= ; expires=&quot;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></article></body></html>]]></content>
  </entry>
  <entry>
    <title>菜鸟解读jQuery源码系列-四-遍地黄金的工具函数</title>
    <url>/article/2020/01/28/%E8%8F%9C%E9%B8%9F%E8%A7%A3%E8%AF%BBjQuery%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-%E5%9B%9B-%E9%81%8D%E5%9C%B0%E9%BB%84%E9%87%91%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>平时写代码是，一些公共的代码是必不可少的，这个时候，每一个成熟的开发者相信都会选择把这类代码抽离出来，成为一个公共的工具函数。这样的好处不言自明，不仅仅显著减少了代码量，还便于管理与优化，避免牵一发而动全身。jQuery库开发版本长达8000多行，里面封装了各种各样的工具函数，今天就让我们来挖掘这块宝藏吧！</p>
<h2 id="先睹为快"><a href="#先睹为快" class="headerlink" title="先睹为快"></a>先睹为快</h2><p>先看几个常用的小栗子（自行引入jQuery）：</p>
<pre><code class="js">//判断类型
$.type({a:1}); // &quot;object&quot;
$.type($); // &quot;function&quot;
//判断是否是window
$.isWindow(window); // true
//判断是否是纯粹的对象
$.isPlainObject({a:1}); // true
$.isPlainObject([]); // false</code></pre>
<p>小伙伴们有没有感到一丝小激动？这些都是开发中常用到的工具函数啊，要是能收为己有，该是一件多么美妙的事情啊！</p>
<h2 id="黄金宝藏"><a href="#黄金宝藏" class="headerlink" title="黄金宝藏"></a>黄金宝藏</h2><h4 id="判断类型（-type）"><a href="#判断类型（-type）" class="headerlink" title="判断类型（$.type）"></a>判断类型（$.type）</h4><p>判断一个值或者对象的类型，应该算是开发中最常见的操作之一了，为什么呢？最简单的一个原因是，我们拿到一个对象，肯定不仅仅只是为了拥有它，正所谓爱她就请给她自由；同样的道理，拿到一个对象，更多是要利用它来创造价值啊！</p>
<p>但是，很多时候，我们拿到一个对象时，就像拿着一个潘多拉的盒子，因为我们并不确定它是什么对象，数组？正则？还是仅仅是一个纯对象，这个时候，如果贸然调用某种类型的API，当并不是这个类型的对象时，程序报错也就不可避免了。</p>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>在说到如何判断类型之前，我们应该先了解一下js的数据类型；最新的 ECMAScript 标准定义了 7 种数据类型:</p>
<ul>
<li><p><strong>原始类型（基本类型）</strong>:<br>  Boolean<br>  Null<br>  Undefined<br>  Number<br>  String<br>  Symbol (ECMAScript 6 新定义)</p>
</li>
<li><p><strong>Object</strong>（引用类型 - - Function Array Date RegExp Object Error Map Set 内置对象）</p>
</li>
</ul>
<h5 id="循规蹈矩的-typeof"><a href="#循规蹈矩的-typeof" class="headerlink" title="循规蹈矩的 typeof"></a>循规蹈矩的 typeof</h5><p>typeof 应该是最先想到的方法，而且也确实很好用，先看对<strong>基本类型</strong>值的判断：</p>
<pre><code class="js">typeof true; //&quot;boolean&quot;
typeof 111; // &quot;number&quot;
typeof &quot;a&quot;; // &quot;string&quot;
typeof undefined; // &quot;undefined&quot;
typeof Symbol.for(&quot;name&quot;); //&quot;symbol&quot;
//判断基本类型唯一的例外
typeof null; &quot;object&quot;</code></pre>
<p>再看typeof对<strong>引用类型</strong>的判断：</p>
<pre><code class="js">typeof [1,2,3]; // &quot;object&quot;
typeof /aa/g ; // &quot;object&quot;
typeof Math ; // &quot;object&quot;
typeof document ; // &quot;object&quot;
//判断引用类型唯一的例外
typeof setTimeout; // &quot;function&quot;</code></pre>
<p>从上可以看出，typeof的判断存在许多的问题：</p>
<ul>
<li>基本类型无法判断出<code>null</code>；</li>
<li>引用类型只能判断出<code>Function</code>对象，其他引用类型全部判断为<code>object</code>;</li>
</ul>
<h5 id="另辟蹊径的-instanceof"><a href="#另辟蹊径的-instanceof" class="headerlink" title="另辟蹊径的 instanceof"></a>另辟蹊径的 instanceof</h5><p>我们先看<code>instanceof</code>的含义，<code>a instanceof A</code> === “对象a是构造函数A的实例吗”；换一种文明的写法即是： <code>object instanceof constructor</code>;</p>
<p>从中可见，当我们想要判断基本类型数据的类型的时候，第一个不需要考虑的就是instanceof方法了，因为它只能用来判断对象的类型。当然，你硬是要用也没关系，只是没啥意义：</p>
<pre><code class="js">1 instanceof Number; // &quot;false&quot;
&quot;aaa&quot; instanceof String; // &quot;false&quot;
true instanceof Boolean; // &quot;false&quot;
//此时报错，因为 undefined 根本不是构造函数
undefined instanceof undefined; // &quot;Uncaught TypeError: Right-hand side of &#39;instanceof&#39; is not an object&quot;
undefined instanceof {}; //&quot;Right-hand side of &#39;instanceof&#39; is not callable&quot;
undefined instanceof function(){}; // false
// null 与 undefined 情形类似，请自行测试</code></pre>
<p>接下来看 <code>instanceof</code> 具体的用法：</p>
<pre><code class="js">({}) instanceof Object; // true, 注意括号；
[] instanceof Array; // true
/aa/g instanceof RegExp; // true
document.getElementsByTagName(&quot;body&quot;) instanceof HTMLCollection; // true
// ...</code></pre>
<p>从上可以了解到，<code>instanceof</code> 一般是用来判断某个引用类型对象的类型的。</p>
<blockquote>
<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链</p>
</blockquote>
<h5 id="无所不能-Object-prototype-toString"><a href="#无所不能-Object-prototype-toString" class="headerlink" title="无所不能 Object.prototype.toString"></a>无所不能 Object.prototype.toString</h5><p>每一个数据类型都有自己实现的<code>toString</code>方法:</p>
<pre><code class="js">[1,2,3].toString(); // &quot;1,2,3&quot;
/aa/g.toString(); // &quot;/aa/g&quot;
Symbol.for(&quot;name&quot;).toString(); // &quot;Symbol(name)&quot;
(1).toString(); // &quot;1&quot;</code></pre>
<p>从上可看出，基本数据类型与引用数据类型都有自己的一套<code>toString</code>方法（当然要排除<code>undefined</code>,<code>null</code>，因为两者身上根本没有方法），因此我们不能直接通过toString方法得出该数据的类型，那还有没有方法呢？</p>
<p>答案已经在上头啦！正所谓万物皆对象（仅仅口头禅），了解原型链的小伙伴应该都知道，每一个引用类型对象，其实都继承了<code>Object</code>构造函数上的原型方法，即使是基本数据类型，也可以通过<strong>包装类型对象</strong>调用相关的方法；换句话说，任何类型数据，都可以调用<code>Object</code>构造函数上的原型方法，也就是可以调用<code>toString</code>方法；(其实这一段是废话，只是想说明不同原型上的toString方法是不一样的而已)</p>
<p>这个时候，有小伙伴就急了，那<code>undefined</code>跟<code>null</code>呢？</p>
<p>问得好，这个时候，我们就要注意调用方法的形式了：</p>
<pre><code class="js"> Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;
 Object.prototype.toString.call(null) // &quot;[object Null]&quot;
 Object.prototype.toString.call([1,2,3]); // &quot;[object Array]&quot;
 Object.prototype.toString.call(/aa/g); // &quot;[object RegExp]&quot;
 Object.prototype.toString.call(document.getElementsByTagName(&quot;body&quot;)); // &quot;[object HTMLCollection]&quot;</code></pre>
<p>熟悉<code>call</code>方法的小伙伴们都知道，<code>a.call(b)</code> === “a方法调用啦，不过a方法内的this记得换成b哦！” 这就是为什么说上一段话是废话，因为通过call调用的话，跟是不是原型继承是没一点关系的。这也就是为什么<code>undefined</code>跟<code>null</code>也能调用了，因为这两者是没有所谓的原型链的。</p>
<h5 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h5><p>废话说了这么多，有些小伙伴已经急了，“这些别人都写过啦，快说jQuery源码是怎么实现的！”</p>
<pre><code class="js">//代码有稍微的整理
var class2type = {};
//小伙伴可以自行加上Set Map
(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;).split(&quot; &quot;).forEach(function(item) {
    class2type[ &quot;[object &quot; + item + &quot;]&quot; ] = item.toLowerCase();
});
function type( obj ) {
    if ( obj == null ) {//如果是null，直接返回&quot;null&quot;
        return String( obj );
    }
    //判断是否是引用类型，是则用toString;基本类型则用typeof判断即可
    return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
        class2type[ Object.prototype.toString.call(obj) ] || &quot;object&quot; :
        typeof obj;
}
//测试
type([1,2,3]); // &quot;array&quot;</code></pre>
<h4 id="判断是否是window对象（isWindow）"><a href="#判断是否是window对象（isWindow）" class="headerlink" title="判断是否是window对象（isWindow）"></a>判断是否是window对象（isWindow）</h4><p>jQuery里面判断是否是window对象的源码非常简单：</p>
<pre><code class="js">function isWindow( obj ) {
    //window对象有一个window属性等于自身
    return obj != null &amp;&amp; obj === obj.window;
}</code></pre>
<h4 id="判断是否是类数组"><a href="#判断是否是类数组" class="headerlink" title="判断是否是类数组"></a>判断是否是类数组</h4><p>js中判断数组是非常方便的，jQuery源码判断数组，直接是调用了原生的<code>isArray</code>方法：</p>
<pre><code class="js">isArray: Array.isArray,</code></pre>
<p>不过在js中还有一种常见的对象- -<strong>类数组</strong>，譬如<code>arguments</code>，<code>HTMLCollection</code>实例都是类数组对象。下面是jQuery源码的实现：</p>
<pre><code class="js">function isArraylike( obj ) {
    var length = obj.length,
        type = jQuery.type( obj );//即上文的判断类型方法
     //判断是不是window对象，是则返回false
    if ( jQuery.isWindow( obj ) ) {
        return false;
    }
    //判断是否是节点，节点必是类数组；
    if ( obj.nodeType === 1 &amp;&amp; length ) {
        return true;
    }
    //数组肯定属于类数组；
    //当不是函数时，length === 0 或者 length &gt; 0 且有邻近数字属性，也可归为类数组
    return type === &quot;array&quot; || type !== &quot;function&quot; &amp;&amp;
        ( length === 0 ||
        typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj );
}</code></pre>
<p>类数组并没有固定的定义，所以jQuery里面的实现并非唯一的标准。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>不知不觉，才写了三个工具方法已经这么长了，像<code>each</code>,<code>map</code>等常用的工具方法看来只能是另起一章啦。文章篇幅个人感觉短小精悍是最合适的，写的不累，看的各位小伙伴也轻松，就酱先！</p>
]]></content>
  </entry>
  <entry>
    <title>菜鸟解读jQuery源码系列-六-函数管理专家Callback</title>
    <url>/article/2020/01/28/%E8%8F%9C%E9%B8%9F%E8%A7%A3%E8%AF%BBjQuery%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-%E5%85%AD-%E5%87%BD%E6%95%B0%E7%AE%A1%E7%90%86%E4%B8%93%E5%AE%B6Callback.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从这一篇开始，我们就要真正进入jQuery的奥秘大陆了！之前的五个系列虽然略显拖沓，但毕竟是打开新世界的钥匙，详细一点是很有必要的。相信仔细看过一遍的小伙伴也会感同身受。</p>
<p>那有的小伙伴就担心了，我前面都没看，这一篇能不能看呢？额，我有说过不能看吗？有说过吗？ 唉，显然是没有的事嘛！正所谓即使你不知道你是如何来到这世界的，也不影响你在这片土地快乐的生活呀。</p>
<p>好啦，废话到此为止，进入正题。</p>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>先看一个jQuery的API，也就是今天的主题 <code>Callback</code> (自行引入库测试)：</p>
<pre><code class="js">function fn1( value ) {
  console.log( &quot;新书发行啦&quot; );
}
function fn2( value ) {
  console.log( &quot;新电影上映啦&quot; );
}
//创建一个callback对象
var cb = $.Callbacks();
//添加回调函数
cb.add( fn1,fn2 );
//触发回调函数
cb.fire();// &quot;新书发行啦&quot; &quot;新电影上映啦&quot;</code></pre>
<p>这时有的小伙伴就郁闷了，不是上一篇才讲的异步回调么，怎么这次又是回调？</p>
<p>好吧，事实上，回调在JavaScript中是一个比较广泛的概念，就比如现实生活中的美食一样，上次讲的是“中华美食上下五千年”，并不妨碍这次讲“满汉全席”对不对？至于其中区别，本人也懒得厘清了，各位自行体会就好。</p>
<h2 id="简单的实现"><a href="#简单的实现" class="headerlink" title="简单的实现"></a>简单的实现</h2><p>按照惯例，我们目的并不是学习这个API，这对我们并没有什么太大的意义。模拟源码的实现，才是我们所追求的。继续看代码：</p>
<pre><code class="js">function Callbacks(){
    // 每次调用Callbacks函数都要返回一个实例，很容易想到这样的实现。
    return {
        //用一个数组装回调函数
        list:[],
        //添加回调函数
        add: function(){
            //把回调函数存到list数组中
            Array.prototype.push.apply(this.list,arguments);
        },
        //触发回调函数
        fire:function(){
            // 逐一调用回调函数
            this.list.forEach((item) =&gt; {
                item();
            })
        }
    }
}
var cb = Callbacks();
cb.add(fn1,fn2);
cb.fire(); //新书发行啦 新电影上映啦</code></pre>
<p>好啦，jQuery中的Callbacks就实现啦，收工！！</p>
<p>小伙伴们顿时兴奋了起来，这么简单呀，John Resig不过如此嘛！！</p>
<h4 id="做人还是要谦虚一点"><a href="#做人还是要谦虚一点" class="headerlink" title="做人还是要谦虚一点"></a>做人还是要谦虚一点</h4><p>好吧，这句话其实是对我自己说的，我可不是在说你们啊，别瞎猜啊（否认三连）。</p>
<p>其实呢，原理就是这么简单，不过，复杂的是需求。接下来我们就尝试着给它提需求吧。</p>
<h2 id="回调函数的唯一性（unique）"><a href="#回调函数的唯一性（unique）" class="headerlink" title="回调函数的唯一性（unique）"></a>回调函数的唯一性（unique）</h2><p>上面的实现，如果我们这样调用：</p>
<pre><code class="js">//重复添加fn1
cb.add(fn1,fn1,fn2);
cb.fire();//新书发行啦 新书发行啦 新电影上映啦</code></pre>
<p>显然，这不是我们想要的，但是无意中重复添加回调函数是常有的情况，这要如何避免呢？这个需求对很多小伙伴来说还是很简单的：</p>
<pre><code class="js">function Callbacks(option){
    // 设置默认配置
    option = option || {unique: false};
    return {
        //用一个数组装回调函数
        list:[],
        //添加回调函数
        add: function(){
            // 收集回调函数
            var fns = Array.prototype.slice.call(arguments);
            if(option.unique){
                fns.forEach( item =&gt; {
                    //判断回调函数是否已经存在，不存在则添加
                    if(!this.list.includes(item)){
                        this.list.push(item)
                    }
                })
            }else{
                Array.prototype.push.apply(this.list,fns);
            }
        },
        //触发回调函数
        fire:function(){
            // 逐一调用回调函数
            this.list.forEach((item) =&gt; {
                item();
            })
        }
    }
}
var cb = Callbacks({unique:true});
cb.add(fn1,fn2,fn1,fn2);
cb.fire(); //新书发行啦 新电影上映啦</code></pre>
<h2 id="回调函数的记忆功能（memory）"><a href="#回调函数的记忆功能（memory）" class="headerlink" title="回调函数的记忆功能（memory）"></a>回调函数的记忆功能（memory）</h2><p>真正的开发中，比较头疼的一个问题就是，我们不得不注意函数的调用先后顺序，比如上面的栗子：</p>
<pre><code class="js">var cb = Callbacks({unique:true});
cb.add(fn1);
cb.fire();//新书发行啦
cb.add(fn2); // fn2没有触发</code></pre>
<p>能不能实现一个功能，无论<code>add(fn2)</code>在前还是在后，都能够触发所有的回调函数呢？</p>
<pre><code class="js">function Callbacks(option){
    // 设置默认配置
    option = option || {unique: false,memory:false};
    //触发回调函数的起点
    var firingStart = 0;
    // 有没有触发过回调函数
    var fired = false;
    return {
        //用一个数组装回调函数
        list:[],
        //添加回调函数
        add: function(){
            //添加回调函数前，记住原数组的长度；
            firingStart = this.list.length;
            // 收集回调函数
            var fns = Array.prototype.slice.call(arguments);
            if(option.unique){
                fns.forEach( item =&gt; {
                    //判断回调函数是否已经存在，不存在则添加
                    if(!this.list.includes(item)){
                        this.list.push(item)
                    }
                })
            }else{
                Array.prototype.push.apply(this.list,fns);
            }
            //若开启记忆功能
            if(option.memory &amp;&amp; fired){
                // 手动触发回调
                this.fire();
            }else{
                firingStart = 0; //没有记忆功能跟还没触发，则永远是0；
            }
        },
        //触发回调函数
        fire:function(manual){
            //表示函数已经触发过
            fired = true;
            // 逐一调用回调函数
            for(var i = firingStart || 0; i &lt; this.list.length; i++ ){
                (this.list[i])();
            }
        }
    }
}
var cb = Callbacks({memory:true});
cb.add(fn1);
cb.fire();//新书发行啦 新电影上映啦
cb.add(fn2);</code></pre>
<h2 id="修复重复调用功能"><a href="#修复重复调用功能" class="headerlink" title="修复重复调用功能"></a>修复重复调用功能</h2><p>实现了回调函数的记忆功能之后，我们又面临了一个全新的问题（修不完的bug）,就是此时重复调用功能失效了！</p>
<pre><code class="js">var cb = Callbacks({memory:true});
cb.add(fn1);
cb.fire();//新书发行啦 新电影上映啦
cb.add(fn2);
//firingStart不是0了，所以不再从头开始调用了
cb.fire(); // 新电影上映啦</code></pre>
<p>所以这个时候需要重构一下，把<code>fire</code>方法抽离出来，这样就能轻易的控制其调用的初始状态了：</p>
<pre><code class="js">function Callbacks(option){
    // 设置默认配置
    option = option || {unique: false,memory:false};
    //触发回调函数的起点
    var firingStart = 0;
    // 有没有触发过回调函数
    var fired = false;
    //抽离成一个公共函数
    function fire(data){
        //表示函数已经触发过
        fired = true;
        for(var i = firingStart || 0; i &lt; data.length; i++ ){
            (data[i])();
        }
    }
    return {
        //用一个数组装回调函数
        list:[],
        //添加回调函数
        add: function(){
            //添加回调函数前，记住原数组的长度；
            firingStart = this.list.length;
            // 收集回调函数
            var fns = Array.prototype.slice.call(arguments);
            if(option.unique){
                fns.forEach( item =&gt; {
                    //判断回调函数是否已经存在，不存在则添加
                    if(!this.list.includes(item)){
                        this.list.push(item)
                    }
                })
            }else{
                Array.prototype.push.apply(this.list,fns);
            }
            //若开启记忆功能
            if(option.memory &amp;&amp; fired){
                // 手动触发回调,调用公共fire
                fire(this.list);
            }else{
                firingStart = 0; //没有记忆功能跟还没触发，则永远是0；
            }
        },
        //触发回调函数
        fire:function(){
            //从0开始
            firingStart = 0;
            fire(this.list);
        }
    }
}
var cb = Callbacks({memory:true});
cb.add(fn1);
cb.fire();//新书发行啦 新电影上映啦
cb.add(fn2);
cb.fire();//新书发行啦 新电影上映啦</code></pre>
<h2 id="回调函数跳出（stopOnFalse）"><a href="#回调函数跳出（stopOnFalse）" class="headerlink" title="回调函数跳出（stopOnFalse）"></a>回调函数跳出（stopOnFalse）</h2><p>我们经常看到一种场景，就是回调返回 <code>false</code> 的时候，接下来的一系列函数将不再继续执行，这也很简单：</p>
<pre><code class="js">function Callbacks(option){
    //省略代码
    function fire(data){
        //表示函数已经触发过
        fired = true;
        for(var i = firingStart || 0; i &lt; data.length; i++ ){
            if ((data[i])() === false){//等于false时跳出循环
                break;
            }
        }
    }
    //省略代码
}</code></pre>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>总的来说，jQuery里面的回调还是有些复杂，上面的只是主要思路的重现，并不代表源码也是这样实现：</p>
<pre><code class="js">jQuery.Callbacks = function( options ) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === &quot;string&quot; ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery.extend( {}, options );

    var // Last fire value (for non-forgettable lists)
        memory,
        // Flag to know if list was already fired
        fired,
        // Flag to know if list is currently firing
        firing,
        // First callback to fire (used internally by add and fireWith)
        firingStart,
        // End of the loop when firing
        firingLength,
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,
        // Actual callback list
        list = [],
        // Stack of fire calls for repeatable lists
        stack = !options.once &amp;&amp; [],
        // Fire callbacks
        fire = function( data ) {
            memory = options.memory &amp;&amp; data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {
                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {
                    memory = false; // To prevent further calls using add
                    break;
                }
            }
            firing = false;
            if ( list ) {
                if ( stack ) {
                    if ( stack.length ) {
                        fire( stack.shift() );
                    }
                } else if ( memory ) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        },
        // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if ( list ) {
                    // First, we save the current length
                    var start = list.length;
                    (function add( args ) {
                        jQuery.each( args, function( _, arg ) {
                            var type = jQuery.type( arg );
                            if ( type === &quot;function&quot; ) {
                                if ( !options.unique || !self.has( arg ) ) {
                                    list.push( arg );
                                }
                            } else if ( arg &amp;&amp; arg.length &amp;&amp; type !== &quot;string&quot; ) {
                                // Inspect recursively
                                add( arg );
                            }
                        });
                    })( arguments );
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if ( firing ) {
                        firingLength = list.length;
                    // With memory, if we&#39;re not firing then
                    // we should call right away
                    } else if ( memory ) {
                        firingStart = start;
                        fire( memory );
                    }
                }
                return this;
            },
            // ... 省略部分代码
            // Call all callbacks with the given context and arguments
            fireWith: function( context, args ) {
                if ( list &amp;&amp; ( !fired || stack ) ) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if ( firing ) {
                        stack.push( args );
                    } else {
                        fire( args );
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith( this, arguments );
                return this;
            }
        };

    return self;
};</code></pre>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>jQuery源码通过闭包形式返回一个callback对象，可以通过该对象对一系列函数进行管理控制。在动画运动，事件绑定，延迟对象等功能中，都是以回调对象为基础进行实现，所以，理解该API源码的实现对于接下来源码的阅读都有着重要的作用。</p>
<p>好啦，先这样吧。因为这一篇代码贴的有点长，所以大家看得可能并不是太爽，不过没有关系，代码的实现是有多种方式的，这里主要是重现了一下思路吧，大伙提纲挈领的看看即可，若要深究，去看看源码就好啦。</p>
]]></content>
  </entry>
  <entry>
    <title>菜鸟解读jQuery源码系列-五-海纳百川的extend</title>
    <url>/article/2020/01/28/%E8%8F%9C%E9%B8%9F%E8%A7%A3%E8%AF%BBjQuery%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-%E4%BA%94-%E6%B5%B7%E7%BA%B3%E7%99%BE%E5%B7%9D%E7%9A%84extend.html</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>看过前几章的小伙伴看到这里时，应该都有些火大了，不是说源码吗，讲了大半天了，怎么还是那一点东西！！！提起这一茬，不说你们了，其实我都有点火大！想当年啊，我也幻想从源码中获取到那么一丝丝不为人知，独步天下的武林秘籍，可是呢？！可是呢？！好啦好啦，吹水到此为止，其实吧，我一开始就说了，我这个系列是新瓶装旧酒，说是读jQuery源码，本质还是为了从中学习JavaScript的，而且呢，到底要写多少，我自己也没个数，写到哪算哪这种（想通过这个系列熟读jQuery源码的小伙伴别打我！！！）其中到底有多少干货，大伙心里自有一杆秤，我呢，不求普度众生，只求问心无愧，尽一点微薄之力，让各位小伙伴看个乐呵就可以了。</p>
<p>废话少说，进入今天正题。</p>
<h2 id="一些栗子"><a href="#一些栗子" class="headerlink" title="一些栗子"></a>一些栗子</h2><p>在平时的开发中，我们面对最多的就是对象了，正如一句口头禅，处处皆对象，是一点也不夸张。针对对象的操作也是经常要面对的，下面就看看jQuery提供的一个针对对象的API：</p>
<pre><code class="js">var object1 = {
  apple: 0,
  banana: { weight: 52, price: 100 },
  cherry: [1,2,3]
};
var object2 = {
  banana: { price: 200 },
   cherry: [4,5]
};
$.extend( object1, object2 );
//{&quot;apple&quot;:0,&quot;banana&quot;:{&quot;price&quot;:200},&quot;cherry&quot;:[4, 5]}
$.extend( true, object1, object2 );
//{&quot;apple&quot;:0,&quot;banana&quot;:{&quot;weight&quot;:52,&quot;price&quot;:200},&quot;cherry&quot;:[4, 5, 3]}</code></pre>
<p>有些小伙伴肯定觉得很眼熟，没错，其实这就是传说中的浅拷贝与深拷贝。显而易见，浅拷贝只是针对对象的第一层属性做拷贝，后面对象的属性值完全覆盖掉前面对象的属性值，深拷贝则表现得更为宽容一些，它会层层递归，把每一层的非对象属性值覆盖掉。</p>
<h2 id="班门弄斧"><a href="#班门弄斧" class="headerlink" title="班门弄斧"></a>班门弄斧</h2><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>按照惯例，在看源码之前，我们先思考一下，看看能不能自己实现一个啦：</p>
<pre><code class="js">//浅拷贝
function simpleExtend(){
    //arguments是类数组，所以即使无参数也不会报错，undefined,null调用则报错，其他非类数组类型值则返回空数组；
    var arr = Array.prototype.slice.call(arguments);
    //当参数小于两个时,直接返回；
    if(arr.length &lt; 2){ return arr[0]; }
    //获取目标对象
    var target = arr[0];
    //从第二个参数开始，for-in遍历每个参数的每一个属性，把它赋值到目标对象;
    for(var i = 1; i &lt; arr.length; i++){
        for(var key in arr[i]){
            target[key] = arr[i][key]; //赋值到目标对象
        }
    }
    return target;
}
simpleExtend( object1, object2 );
//{&quot;apple&quot;:0,&quot;banana&quot;:{&quot;price&quot;:200},&quot;cherry&quot;:[4, 5]}</code></pre>
<p>从上面可以看出，浅拷贝还是很简单的，双重循环即可。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>在贴出代码之前，我们先思考一下，深拷贝跟浅拷贝的区别究竟在哪里呢？</p>
<p>其实不难看出，只有当目标对象与被拷贝对象的属性都是对象（或数组）时，才会考虑要不要深拷贝，如果两个属性的类型不一致或者都是基本类型值，肯定就直接覆盖了。</p>
<p>而且属性肯定是会多层嵌套的，所以使用递归是自然而然的思路：</p>
<pre><code class="js">//判断是否是全对象或者全数组
function isObjectOrArray(a,b){
    //排除掉null后，只有非函数的引用类型才进入if;
    if(a &amp;&amp; b &amp;&amp; typeof a === &quot;object&quot; &amp;&amp; typeof b === &quot;object&quot;){
        var aType = Object.prototype.toString.call(a);
        var bType = Object.prototype.toString.call(b);
        if(aType === bType){//保证类型一致，且是数组或者对象
            return aType === &quot;[object Object]&quot; || aType === &quot;[object Array]&quot;
        }else{
            return false;
        }
    }else{
        return false;
    }
}
//深拷贝
function deepExtend(){
    //arguments是类数组，所以即使无参数也不会报错，undefined,null调用则报错，其他非类数组类型值则返回空数组；
    var arr = Array.prototype.slice.call(arguments);
    //当参数小于两个时,直接返回；
    if(arr.length &lt; 2){ return arr[0]; }
    //获取目标对象
    var target = arr[0];
    //从第二个参数开始，for-in遍历每个参数的每一个属性，把它赋值到目标对象;
    for(var i = 1; i &lt; arr.length; i++){
        for(var key in arr[i]){
            //判断是不是都是对象（或者数组）
            if(isObjectOrArray(target[key],arr[i][key])){
                //把目标对象与拷贝对象的属性值都取出来，递归操作；因为属性值都是对象，也就是都只是保留内存地址引用，递归赋值时，修改的也还是原对象
                deepExtend(target[key],arr[i][key]);
            }else{
                target[key] = arr[i][key]; //赋值到目标对象
            }
        }
    }
    return target;
}
deepExtend( object1, object2 );
//{&quot;apple&quot;:0,&quot;banana&quot;:{&quot;weight&quot;:52,&quot;price&quot;:200},&quot;cherry&quot;:[4, 5, 3]}</code></pre>
<p>好吧，这段代码显得长了一点点，主要是为了方便大家自己测试，也加上了类型判断的函数，类型判断不熟悉的小伙伴，可以参考<a href="http://codedoges.com/article/1535984499369" target="_blank" rel="noopener" title="遍地黄金的工具函数">系列四</a>的文章。</p>
<p>下面来分析一下该段代码：对照一下浅拷贝，深拷贝其实只做了一处的修改，就是在赋值之前，先判断该属性值是否同时是对象或者数组，如果是，就递归拷贝操作；</p>
<p>基础不是太好的小伙伴可能就有疑问了，为什么递归调用时传的是 <code>target[key]</code> 跟 <code>arr[i][key]</code> 呢？下面看个小例子：</p>
<pre><code class="js">var obj = {
    a: {name: &quot;李四&quot;}
};
function ex(x){
     x.name = &quot;张三&quot;;
}
ex(obj.a);
console.log(obj.a.name); //&quot;张三&quot;</code></pre>
<p>看到这里，小伙伴们应该明白了，因为 <code>ex</code> 函数调用时，传的实参是 <code>obj.a</code> ，而 <code>obj.a</code> 是一个对象，既然是对象，那意味着传进去的只是一个对象引用而已，函数里面修改该对象时，其实实质还是修改外面的 <code>obj</code>；</p>
<p>同理，<code>deepExtend(target[key],arr[i][key])</code> 这两个参数也都是对象（或数组），对它们递归赋值修改时，其实修改的还是最开始传进去的目标对象。</p>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>好啦，说了这么多，相信有些小伙伴已经急不可耐想知道jQuery源码里面是如何实现了，现在就让我们来看看John Resig大佬的实现吧：</p>
<pre><code class="js">function extend() {
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},//获取目标对象，默认为第一个参数
        i = 1, // 被拷贝对象下标，默认从第二个开始
        length = arguments.length,
        deep = false; // 默认浅拷贝

    // 当第一参数为布尔值时
    if ( typeof target === &quot;boolean&quot; ) {
        deep = target; // 调整默认拷贝的状态
        target = arguments[1] || {}; // 目标对象变为第二个参数
        i = 2; // 被拷贝对象改从第三个参数开始
    }

    // 当目标对象为非 null 的基本类型值时，为了防止报错，给它一个空数组
    if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) {
        target = {};
    }

    // 此时没有被拷贝对象
    if ( length === i ) {
        target = this; // 目标对象指向调用extend方法的对象
        --i; // 此操作意味着被拷贝对象在参数位置前移一位，即无布尔值时，被拷贝对象是第一个参数，有布尔值时，为参数第二位；
    }

    /*上面都是非核心代码，主要是为了对多种情况的参数传入进行处理，提高代码健壮性 */

    //开始遍历被拷贝参数
    for ( ; i &lt; length; i++ ) {
        // 被拷贝参数不为 null 与 undefined 时，进入；
        if ( (options = arguments[ i ]) != null ) {
            // 遍历被拷贝对象的属性值
            for ( name in options ) {
                src = target[ name ]; //目标对象的属性值
                copy = options[ name ]; //被拷贝对象的属性值

                // 一个重要的处理，当被拷贝对象的属性值指向目标对象时，跳出本次遍历，避免陷入死循环
                if ( target === copy ) {
                    continue;
                }

                // 当被拷贝对象属性值为对象或者数组时，进行递归操作
                if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    if ( copyIsArray ) { //被拷贝对象属性值为数组时
                        copyIsArray = false; //置否，等待下次遍历
                        clone = src &amp;&amp; jQuery.isArray(src) ? src : []; //目标对象属性值不是数组时，给个空数组，保持类型一致
                    } else {//被拷贝对象属性值为对象时
                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};//目标对象属性值不为对象时，给个空对象，保持类型一致
                    }

                    // 传入目标对象属性值与被拷贝对象属性值，递归操作
                    target[ name ] = extend( deep, clone, copy );

                // 当被拷贝对象属性值不为为对象或者数组时，直接拷贝覆盖
                } else if ( copy !== undefined ) {
                    target[ name ] = copy;
                }
            }
        }
    }

    // 返回被拷贝完成的目标对象
    return target;
};</code></pre>
<p>看完源码的注释的小伙伴可以先坐下来缓口气了。我们趁热打铁，对比一下源码跟上面深拷贝代码的区别。</p>
<p>有没有区别呢？啥区别？</p>
<ul>
<li>对多种参数情况的处理，譬如兼容布尔值参数，对基本类型参数的处理，可能出现的报错的情况的处理。</li>
<li>最关键的一点，对潜在对象互相引用导致死循环的处理，虽然这种情况较少出现。</li>
</ul>
<p>哈哈，总的来说，思路是一致的，实现源码更胜一筹。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>通过这一篇文章，认真思考过的小伙伴应该可以逐步体会到，大神写的代码跟凡人写的代码的一丝区别了。同样的代码，同一个实现思路下，John Resig大佬的实现显得更具健壮性，防止了各种可能出现的报错，甚至考虑到了潜在的死循环情况，虽然仅仅加了一句代码。</p>
<p>看来，我们跟大佬的差距不小啊，不过至少已经看到前方的方向了不是吗，让我们继续前进吧！</p>
]]></content>
  </entry>
  <entry>
    <title>菜鸟解读jQuery源码系列-二-疯狂的链式调用</title>
    <url>/article/2020/01/28/%E8%8F%9C%E9%B8%9F%E8%A7%A3%E8%AF%BBjQuery%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-%E4%BA%8C-%E7%96%AF%E7%8B%82%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8.html</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&emsp;&emsp;熟悉jQuery的小伙伴应该都知道，链式调用是其特色之一。我们创建了一个jQuery对象之后，就可以链式调用其对象上的方法，从而大大方便了我们的代码书写。这特色写法的背后是怎么实现的呢？本篇就让我们一起来探索其背后的奥秘吧！</p>
<h2 id="一点疑问"><a href="#一点疑问" class="headerlink" title="一点疑问"></a>一点疑问</h2><p>按照惯例，我们先来看几个常用的场景：</p>
<pre><code class="js">$(&quot;#id&quot;).find(&quot;li&quot;).css(&quot;background&quot;,&quot;red&quot;);
$(&quot;&lt;li&gt;&lt;/li&gt;&quot;).appendTo(&quot;body&quot;).css(&quot;background&quot;,&quot;red&quot;);
//...</code></pre>
<p>上例每个例子都可以继续调用jQuery的方法，无穷无尽的调用下去，正所谓海阔凭鱼跃，天高任鸟飞啊！阅读过系列（一）的小伙伴都知道，<code>$()</code>方法返回的是一个jQuery构造函数生成的实例，也就是说我们可以接着调用其原型链上的各类方法，甚至<code>$()</code>返回的实例都是其原型上的<code>init</code>方法生成的。</p>
<p>这到底是如何实现的呢？这时，旁边智商高达150的小伙伴大佬冷笑一声，沉默了几秒钟后，突然额头青筋暴起，粗着脖子朝我怒吼：通过返回<code>this</code>啊啊啊！！！你到底懂不懂javaScript！！！方法内的<code>this</code>不就是指向调用该方法的对象么！这不是so easy么？？！！额。。。我侧头看了看另一旁也在冷笑的John Resig（jQuery的作者），连忙擦了擦汗：咳咳。。。其实，。。。你说的。。。没错。。。。不过！你只对了一半。。。。（小伙伴大佬刚咧开的嘴巴顿时僵住了）。。。</p>
<h2 id="灵魂拷问"><a href="#灵魂拷问" class="headerlink" title="灵魂拷问"></a>灵魂拷问</h2><p>为什么John Resig会冷笑不止呢，其实。。。好吧，我也不知道为啥，可能真正的大佬都不是一般人能理解的吧。。。不过小伙伴大佬确实只对了一半，下面看简单模拟代码（不理解本实现的可以回看<a href="http://codedoges.com/article/1535898268557" target="_blank" rel="noopener" title="jQuery对象的诞生记">系列一</a>文章）：</p>
<pre><code class="js">//即将继承jQuery的函数
function Fn(){
    return this; //关键点：第一种this；
}
function jQuery(){
    return new Fn(); //返回继承jQuery原型的一个实例
}
//继承jQuery函数
Fn.prototype = jQuery.prototype = {
    construtor: jQuery,
    find: function(){
        console.log(&quot;find方法调用&quot;);
        return this;//关键点：第二种this；
    },
    css:function(){
        console.log(&quot;css方法调用&quot;);
        return this;//关键点：第二种this；
    }
}
var $ = jQuery;
$().find().css(); //find方法调用  //css方法调用</code></pre>
<p>小伙伴大佬看到这里，额头青筋暴突，大脸再度涨红了起来：这。。。这有啥了不起的！！？？</p>
<p>额。。。好吧，确实没啥了不起的。其实这里面两种情况代表了<code>this</code>的两种指向：</p>
<ul>
<li>默认绑定，即指向<code>window</code>；</li>
<li>隐式绑定，即指向调用方法的对象；</li>
<li>显示绑定，即通过<code>call</code>，<code>apply</code>，<code>bind</code>显式绑定指向；</li>
<li><code>new</code>绑定；</li>
</ul>
<p>显而易见，小伙伴大佬所指的是隐式绑定的情况，另一种情况则是<code>new</code>的绑定；其实上面四种情况中，前三种大家还是非常熟悉的，接下来具体看一下<code>new</code>绑定时的发生的过程：</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行 [[ 原型 ]] 连接。</li>
<li>这个新对象会绑定到函数调用的 this 。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<p>简而言之，构造函数中的<code>this</code>一定会绑定到生成的实例对象上，但是这个实例对象却不一定会返回（当构造函数返回一个对象时）：</p>
<pre><code class="js">function jQueryA(){
    this.XXX = 1;
    return ; //没有返回对象时，生成一个实例对象
    //return undefined || null || 1 || &quot;string&quot; || true ;
}
function jQueryB(){
    this.XXX = 1;
    return [1,2,3]; //返回一个对象时，直接把该对象返回，无论构造函数里面是什么
    //return {} || function(){} || new Number(1) || ....
}
var a = new jQueryA();
var b = new jQueryB();
console.log(a); //{XXX: 1}
console.log(b); //[1, 2, 3]</code></pre>
<p>对照上面的文字跟代码，相信很多小伙伴都可以理解<code>new</code>构造函数时所发生的情况，不过这里还有一个特殊情况：</p>
<pre><code class="js">function jQueryC(){
    this.XXX = 1;
    return this; //返回的是this对象
}
var c = new jQueryC();
console.log(c); //{XXX: 1}</code></pre>
<p>哈哈，是不是有点小惊喜！其实这段代码也很好理解，已经说过，无论返回的是不是对象，构造函数中的<code>this</code>一定会绑定到生成的实例对象上的，返不返回另说！！！而<code>this</code>则是一个赤裸裸的实例对象啊，既然是对象，肯定就是返回咯，只不过它恰好是实例对象而已！</p>
<p>讲到这里，小伙伴大佬眼神带着一丝惊慌，努力轻蔑一笑：即使我说漏了一半，这也没啥出奇的嘛，小失误啦！哈哈哈。。。</p>
<h2 id="闭关修炼"><a href="#闭关修炼" class="headerlink" title="闭关修炼"></a>闭关修炼</h2><p>正当小伙伴大佬肆无忌惮地狂笑时，John Resig也轻蔑一笑，默默的拿出了源码（简略版，看不懂回看<a href="http://codedoges.com/article/1535898268557" target="_blank" rel="noopener" title="jQuery对象的诞生记">系列一</a>）：</p>
<pre><code class="js">// 定义jQuery构造函数
jQuery = function( selector, context ) {
    //返回一个新函数
    return new jQuery.fn.init(/** selector, context, rootjQuery **/);
};
jQuery.fn = jQuery.prototype = {
    constructor: jQuery,
    init: function(/** selector, context, rootjQuery **/){
        //本篇关键之关键！！！
        return this;//关键点：第一种this；
    },
    find: function(){//伪造的测试方法
        console.log(&quot;find方法调用&quot;);
        return this;//关键点：第二种this；
    },
    css:function(){//伪造的测试方法
        console.log(&quot;css方法调用&quot;);
        return this;//关键点：第二种this；
    }
    //...
}
// init其实就是继承jQuery的新函数(Fn)，所以需要手动添加继承
jQuery.fn.init.prototype = jQuery.fn;
var $ = jQuery;
$().find().css(); //find方法调用  //css方法调用</code></pre>
<p>空气突然安静。小伙伴大佬：这？？。。这踏马是一回事？？？</p>
<p>其实没错，在我们的印象中，构造函数不是一般是大写的吗？里面不是一般都是各种实例属性方法的挂载吗？怎么这<code>jQuery.fn.init</code>也是构造函数？？？</p>
<p>嗯嗯。。。没错，这句话其实是我写本篇唯一想说的一句话，其他都是附带的收获了，逃。。。就酱！！！</p>
<blockquote>
<p>实质上拥有[[Construct]]方法的函数才能成为构造函数，因此不是所有函数都可以用<code>new</code>来调用。例如箭头函数就未拥有该方法。but！who care?</p>
</blockquote>
<h2 id="修仙秘笈"><a href="#修仙秘笈" class="headerlink" title="修仙秘笈"></a>修仙秘笈</h2><p>讲到这里，房间的某处，小伙伴大佬抱着John Resig的大腿正在狂喊大佬云云，暂且不表了，先理一下思路吧。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>显而易见，理解构造函数下<code>this</code>的指向与<code>new</code>构造函数时返回的两种情况是这篇文章的重点；</li>
<li>另一个就是小伙伴们对构造函数要有一个通透的理解，不要被复杂的表象所迷惑，即到底是不是构造函数，就看函数有没有被<code>new</code>过。世上本没有构造函数，被<code>new</code>了之后，就有了构造函数；</li>
</ul>
<p>通篇下来，仔细看的小伙伴应该都知道我这是在挂羊头卖狗肉啦，其实这也正是我的初衷，就是通过jQuery源码的解读重现，从中学习到一丝丝有意思的知识，我觉得这就够了，对我来说这也就是jQuery最大的价值所在，相信你们也会感同身受。</p>
]]></content>
  </entry>
  <entry>
    <title>菜鸟解读jQuery源码系列-三-再谈jQuery对象</title>
    <url>/article/2020/01/28/%E8%8F%9C%E9%B8%9F%E8%A7%A3%E8%AF%BBjQuery%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-%E4%B8%89-%E5%86%8D%E8%B0%88jQuery%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&emsp;&emsp;经过前两个系列的洗礼，小伙伴们大概都大概了解jQuery对象是个啥了。两个系列通篇口水，总结下来无非就是两句话：系列一讲jQuery是如何通过构造函数生成，系列二讲的是jQuery为啥能链式调用。稍微用点心思，认真一点读一遍的小伙伴，应该都能读懂了，哈哈哈（难道还要质疑我的写作能力？?）。</p>
<h2 id="灵魂拷问"><a href="#灵魂拷问" class="headerlink" title="灵魂拷问"></a>灵魂拷问</h2><p>我笑音未落，旁边一个小伙伴脸色铁青，咬着牙气狠狠地对我吼道：你骗人！！！啥？啥？？正当我百思不得其解时，天空飘来一段代码：</p>
<pre><code class="js">//系列一，系列二的代码
var $ = jQuery;
$().find().css(); //find方法调用  //css方法调用

//实践中的jq代码
$(&quot;ul&quot;).find(&quot;li&quot;).css(&quot;background&quot;,&quot;red&quot;);</code></pre>
<p>“你骗人！！！”，旁边小伙伴的怒火有点大，我不禁捂住了耳朵，“我没骗人！！！”，“那你狗屁代码怎么跟人家正宗的不一样？？”，“那。。那是因为我还没写完！！！”我长舒了一口气，有点傲然地撇了一眼脸胀的通红的小伙伴，紧接着低咳了两声，“接下来才是见证奇迹的时刻！！”。</p>
<h5 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h5><p>之前的问题在哪呢？一眼可见，之前实现的代码，方法是正常调用了，jQuery对象原型上的方法也能愉快的继承下来了，但是还没解决两个问题：</p>
<ul>
<li>第一个问题，jQuery原型倒是继承下来，实例对象呢？实例对象长啥样？</li>
<li>第二个问题，方法中的<code>DOM</code>元素是如何选中并进行操作的？</li>
</ul>
<p>好吧，其实是我啰嗦了，这看似是两个问题，其实只是一个问题，接下来，就让我们去收割真正的<code>jQuery</code>对象吧！</p>
<h2 id="闭关修炼"><a href="#闭关修炼" class="headerlink" title="闭关修炼"></a>闭关修炼</h2><p>通过前两个系列，我们已经知道<code>$()</code>返回的是一个jQuery实例对象，既然这样，我们就先打印一下该实例对象：</p>
<pre><code>//...省略代码
&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
console.log($(&quot;li&quot;));
/*{
    0:li,
    1:li,
    2:li,
    context:document,
    length:3,
    selector:&quot;li&quot;,
    prevObject：init [document, context: document]//上一个jQuery实例
    //...
}*/
//为了避免使用图片，我就手打代码了，大伙可以自行打印一下。
&lt;/script&gt;
//...省略代码</code></pre><p>这，，，这不是传说中的类数组对象吗？让我们再看一段代码：</p>
<pre><code class="js">//get方法即是传说中把jQuery对象转换成DOM对象的方法
$(&quot;li&quot;).get(0).nodeType;
//1 ; 元素节点</code></pre>
<p>显而易见，实例对象里面，把选择到的元素节点，一个个都存起来了啊！！！<br>旁边的小伙伴怒气稍减，脸也没那么红了，“有点意思，但是怎么实现呢？”<br>好吧，看来不拿出真本事是不行了，直接看代码吧（看不懂回看<a href="http://codedoges.com/article/1535898268557" target="_blank" rel="noopener" title="jQuery对象的诞生记">系列一</a>）：</p>
<pre><code class="js">// 定义jQuery构造函数
jQuery = function( selector, context ) {
    //返回一个新函数
    return new jQuery.fn.init( selector /**, context, rootjQuery **/);
};
jQuery.fn = jQuery.prototype = {
    constructor: jQuery,
    init: function( selector /** , context, rootjQuery **/){
        if(typeof selector === &quot;string&quot;){//假设这里只传标签名字符串，实际上会有多种情况需要判断
            var arr = document.getElementsByTagName(selector);
            for(var i = 0; i &lt; arr.length; i++){
                this[i] = arr[i];
            }
        }
        return this;//第一种this；
    },
    get: function(index){//伪造的测试方法
        return this[index];//第二种this
    },
    //...
}
// init其实就是继承jQuery的新函数(Fn)，所以需要手动添加继承
jQuery.fn.init.prototype = jQuery.fn;
var $ = jQuery;
$(&quot;body&quot;).get(0).nodeName; //&quot;BODY&quot;</code></pre>
<p>nice ！！！<br>整个系列走到这里，jQuery对象的神秘面纱终于被彻底揭开了！！！<br>这时，旁边的小伙伴由怒转喜，一猛扑就想要过来抱我大腿，我吓得猛地跳开，用手直指正在角落打瞌睡的John Resig，“是他，是他，大佬就是他！！”</p>
<p>正当场面一片喧闹时，一反常态已沉默许久的小伙伴大佬突然发话了，“你所说的好像挺有道理的，不过，jQuery对象里面的那个<code>prevObject</code>是啥回事？”</p>
<p>其他小伙伴这时也缓过神来了，顿时七嘴八舌起来，“对啊，啥回事捏，怎么刚刚没见说？？？又想掺水么？”</p>
<p>眼看刚刚营造的和谐氛围马上就要荡然无存，我也急了，“大家安静，安静，听我继续说！”</p>
<h2 id="渡劫化神"><a href="#渡劫化神" class="headerlink" title="渡劫化神"></a>渡劫化神</h2><p>好吧，其实每次小标题都是乱起的，发现内容严重不符还请手下留情。接下来请看一段代码：</p>
<pre><code class="js">//实践中的用法，大伙自行验证效果
$(&#39;ul&#39;).find(&#39;li&#39;).css(&#39;background&#39;,&#39;red&#39;).end().css(&#39;border&#39;,&#39;1px solid #000000&#39;);//重点关注 .end() 方法；</code></pre>
<p>这段代码的结果就是<code>li</code>元素背景变红，<code>ul</code>元素则加上了边框。</p>
<p>这是为什么呢？按照链式调用，<code>css</code>方法调用时，方法内的<code>this</code>不是指向<code>li</code>元素的么（暂且这么理解，实质是指向包含<code>li</code>元素的jQuery对象）？</p>
<p>疑点的指向小伙伴们应该都能够猜到了，这一切都是<code>.end()</code>方法搞的鬼！</p>
<p>现在就让我们看看<code>end</code>方法是如何做到这一点的：</p>
<pre><code class="js">// 定义jQuery构造函数
jQuery = function( selector, context ) {
    //返回一个新函数
    return new jQuery.fn.init( selector /**, context, rootjQuery **/);
};
jQuery.fn = jQuery.prototype = {
    constructor: jQuery,
    init: function( selector /** , context, rootjQuery **/){
        this[0] = selector; //假装选中该元素（模拟一下就好啦，不要打我！）
        return this;//第一种this；
    },
    find: function(selector){//伪造的测试方法
        var ret = $(selector);//假装选中了子元素，生成全新的jQuery对象；
        //此时的this是指向上一个jQuery对象的，此处把它存起来！
        ret[&#39;prevObject&#39;] = this;//关键点！！！
        return ret;//返回了包装子元素的jQuery对象
    },
    end: function(){//伪造的测试方法
        return this.prevObject;//很简单，把当前jQuery对象存的上一个对象返回；
    },
    //...
}
// init其实就是继承jQuery的新函数(Fn)，所以需要手动添加继承
jQuery.fn.init.prototype = jQuery.fn;
var $ = jQuery;
//赶紧测试一下吧！！！看看里面的结构。
console.log($(&quot;body&quot;).find(&#39;ul&#39;).find(&#39;li&#39;));
//jQuery对象通过end方法进行回溯调用
var obj = $(&quot;body&quot;).find(&#39;ul&#39;);
obj.find(&#39;li&#39;).end() === obj;//true !!!</code></pre>
<p>讲到这里，相信一路看下来的小伙伴应该都差不多明白了，所谓的<code>prevObject</code>属性其实就是存储了当前jQuery对象的上一个jQuery对象，并通过<code>end</code>方法进行回溯查找，从而实现了传说中的链式调用的灵活使用。</p>
<p>这时，方才还在打瞌睡的John Resig适时睡醒了，在众多小伙伴的注视下走了过来，用手轻轻拍了我的肩膀，说道，“盗版虽好，不可贪杯哦”。</p>
<h2 id="羽化登仙"><a href="#羽化登仙" class="headerlink" title="羽化登仙"></a>羽化登仙</h2><p>(｡･∀･)ﾉﾞ嗨！上面的小伙伴，你们还好吗？<br>好吧，其实我只是想多水两句。不过，如果是神情还有点恍惚的小伙伴，还请移步系列一，把这三部曲按照顺序看一遍，相信对传说中的jQuery对象就能够有一个深入的理解了。有没有信心？</p>
<h5 id="为什么这么水？"><a href="#为什么这么水？" class="headerlink" title="为什么这么水？"></a>为什么这么水？</h5><p>我也不想啊！！！<br>好吧，虽然听起来有点言不由衷，不过确实是有苦衷的。</p>
<ul>
<li>苦衷一：个人切身体验。在深入理解jQuery源码之前，给我最大神秘感的，最难以理解的，其实就是这个<code>jQuery</code>对象，它是如何产生的？里面包含了写什么？是结构是怎样的？。。。这些问题一直是我心中最大的疑惑；</li>
<li>苦衷二：理解源码之门槛。啥？门槛不是那些无穷无尽的API吗？是的，真正的门槛其实就是理解<code>jQuery</code>对象，它才是贯穿整个源码的主线，其他无穷无尽的API，都不过是游戏中的一个个副本而已。所以理解它是重中之重；</li>
<li>苦衷三：本人控水能力不足（做欲哭状，旁边小伙伴呕吐声，叫骂声不绝于耳）；</li>
</ul>
<h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h5><p>系列一到系列三，其实讲的是都是jQuery对象，只不过采取的是循序渐进的方式而已，所以小伙伴们最好是放一起来阅读，小伙伴大佬则请自便。</p>
<p>接下来的系列则是关于一系列API的另类解读，敬请期待哈！</p>
]]></content>
  </entry>
  <entry>
    <title>菜鸟解读jQuery源码系列-七-发布订阅时请Callback</title>
    <url>/article/2020/01/28/%E8%8F%9C%E9%B8%9F%E8%A7%A3%E8%AF%BBjQuery%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-%E4%B8%83-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%97%B6%E8%AF%B7Callback.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从这一篇开始，我们就要真正进入jQuery的奥秘大陆了！之前的五个系列虽然略显拖沓，但毕竟是打开新世界的钥匙，详细一点是很有必要的。相信仔细看过一遍的小伙伴也会感同身受。</p>
<p>那有的小伙伴就担心了，我前面都没看，这一篇能不能看呢？额，我有说过不能看吗？有说过吗？ 唉，显然是没有的事嘛！正所谓即使你不知道你是如何来到这世界的，也不影响你在这片土地快乐的生活呀。</p>
<p>好啦，废话到此为止，进入正题。</p>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>先看一个jQuery的API，也就是今天的主题 <code>Callback</code> (自行引入库测试)：</p>
<pre><code class="js">function fn1( value ) {
  console.log( &quot;新书发行啦&quot; );
}
function fn2( value ) {
  console.log( &quot;新电影上映啦&quot; );
}
//创建一个callback对象
var cb = $.Callbacks();
//添加回调函数
cb.add( fn1,fn2 );
//触发回调函数
cb.fire();// &quot;新书发行啦&quot; &quot;新电影上映啦&quot;</code></pre>
<p>这时有的小伙伴就郁闷了，不是上一篇才讲的异步回调么，怎么这次又是回调？</p>
<p>好吧，事实上，回调在JavaScript中是一个比较广泛的概念，就比如现实生活中的美食一样，上次讲的是“中华美食上下五千年”，并不妨碍这次讲“满汉全席”对不对？至于其中区别，本人也懒得厘清了，各位自行体会就好。</p>
<h2 id="简单的实现"><a href="#简单的实现" class="headerlink" title="简单的实现"></a>简单的实现</h2><p>按照惯例，我们目的并不是学习这个API，这对我们并没有什么太大的意义。模拟源码的实现，才是我们所追求的。继续看代码：</p>
<pre><code class="js">function Callbacks(){
    // 每次调用Callbacks函数都要返回一个实例，很容易想到这样的实现。
    return {
        //用一个数组装回调函数
        list:[],
        //添加回调函数
        add: function(){
            //把回调函数存到list数组中
            Array.prototype.push.apply(this.list,arguments);
        },
        //触发回调函数
        fire:function(){
            // 逐一调用回调函数
            this.list.forEach((item) =&gt; {
                item();
            })
        }
    }
}
var cb = Callbacks();
cb.add(fn1,fn2);
cb.fire(); //新书发行啦 新电影上映啦</code></pre>
<p>好啦，jQuery中的Callbacks就实现啦，收工！！</p>
<p>小伙伴们顿时兴奋了起来，这么简单呀，John Resig不过如此嘛！！</p>
<h4 id="做人还是要谦虚一点"><a href="#做人还是要谦虚一点" class="headerlink" title="做人还是要谦虚一点"></a>做人还是要谦虚一点</h4><p>好吧，这句话其实是对我自己说的，我可不是在说你们啊，别瞎猜啊（否认三连）。</p>
<p>其实呢，原理就是这么简单，不过，复杂的是需求。接下来我们就尝试着给它提需求吧。</p>
<h2 id="回调函数的唯一性（unique）"><a href="#回调函数的唯一性（unique）" class="headerlink" title="回调函数的唯一性（unique）"></a>回调函数的唯一性（unique）</h2><p>上面的实现，如果我们这样调用：</p>
<pre><code class="js">//重复添加fn1
cb.add(fn1,fn1,fn2);
cb.fire();//新书发行啦 新书发行啦 新电影上映啦</code></pre>
<p>显然，这不是我们想要的，但是无意中重复添加回调函数是常有的情况，这要如何避免呢？这个需求对很多小伙伴来说还是很简单的：</p>
<pre><code class="js">function Callbacks(option){
    // 设置默认配置
    option = option || {unique: false};
    return {
        //用一个数组装回调函数
        list:[],
        //添加回调函数
        add: function(){
            // 收集回调函数
            var fns = Array.prototype.slice.call(arguments);
            if(option.unique){
                fns.forEach( item =&gt; {
                    //判断回调函数是否已经存在，不存在则添加
                    if(!this.list.includes(item)){
                        this.list.push(item)
                    }
                })
            }else{
                Array.prototype.push.apply(this.list,fns);
            }
        },
        //触发回调函数
        fire:function(){
            // 逐一调用回调函数
            this.list.forEach((item) =&gt; {
                item();
            })
        }
    }
}
var cb = Callbacks({unique:true});
cb.add(fn1,fn2,fn1,fn2);
cb.fire(); //新书发行啦 新电影上映啦</code></pre>
<h2 id="回调函数的记忆功能（memory）"><a href="#回调函数的记忆功能（memory）" class="headerlink" title="回调函数的记忆功能（memory）"></a>回调函数的记忆功能（memory）</h2><p>真正的开发中，比较头疼的一个问题就是，我们不得不注意函数的调用先后顺序，比如上面的栗子：</p>
<pre><code class="js">var cb = Callbacks({unique:true});
cb.add(fn1);
cb.fire();//新书发行啦
cb.add(fn2); // fn2没有触发</code></pre>
<p>能不能实现一个功能，无论<code>add(fn2)</code>在前还是在后，都能够触发所有的回调函数呢？</p>
<pre><code class="js">function Callbacks(option){
    // 设置默认配置
    option = option || {unique: false,memory:false};
    //触发回调函数的起点
    var firingStart = 0;
    // 有没有触发过回调函数
    var fired = false;
    return {
        //用一个数组装回调函数
        list:[],
        //添加回调函数
        add: function(){
            //添加回调函数前，记住原数组的长度；
            firingStart = this.list.length;
            // 收集回调函数
            var fns = Array.prototype.slice.call(arguments);
            if(option.unique){
                fns.forEach( item =&gt; {
                    //判断回调函数是否已经存在，不存在则添加
                    if(!this.list.includes(item)){
                        this.list.push(item)
                    }
                })
            }else{
                Array.prototype.push.apply(this.list,fns);
            }
            //若开启记忆功能
            if(option.memory &amp;&amp; fired){
                // 手动触发回调
                this.fire();
            }else{
                firingStart = 0; //没有记忆功能跟还没触发，则永远是0；
            }
        },
        //触发回调函数
        fire:function(manual){
            //表示函数已经触发过
            fired = true;
            // 逐一调用回调函数
            for(var i = firingStart || 0; i &lt; this.list.length; i++ ){
                (this.list[i])();
            }
        }
    }
}
var cb = Callbacks({memory:true});
cb.add(fn1);
cb.fire();//新书发行啦 新电影上映啦
cb.add(fn2);</code></pre>
<h2 id="修复重复调用功能"><a href="#修复重复调用功能" class="headerlink" title="修复重复调用功能"></a>修复重复调用功能</h2><p>实现了回调函数的记忆功能之后，我们又面临了一个全新的问题（修不完的bug）,就是此时重复调用功能失效了！</p>
<pre><code class="js">var cb = Callbacks({memory:true});
cb.add(fn1);
cb.fire();//新书发行啦 新电影上映啦
cb.add(fn2);
//firingStart不是0了，所以不再从头开始调用了
cb.fire(); // 新电影上映啦</code></pre>
<p>所以这个时候需要重构一下，把<code>fire</code>方法抽离出来，这样就能轻易的控制其调用的初始状态了：</p>
<pre><code class="js">function Callbacks(option){
    // 设置默认配置
    option = option || {unique: false,memory:false};
    //触发回调函数的起点
    var firingStart = 0;
    // 有没有触发过回调函数
    var fired = false;
    //抽离成一个公共函数
    function fire(data){
        //表示函数已经触发过
        fired = true;
        for(var i = firingStart || 0; i &lt; data.length; i++ ){
            (data[i])();
        }
    }
    return {
        //用一个数组装回调函数
        list:[],
        //添加回调函数
        add: function(){
            //添加回调函数前，记住原数组的长度；
            firingStart = this.list.length;
            // 收集回调函数
            var fns = Array.prototype.slice.call(arguments);
            if(option.unique){
                fns.forEach( item =&gt; {
                    //判断回调函数是否已经存在，不存在则添加
                    if(!this.list.includes(item)){
                        this.list.push(item)
                    }
                })
            }else{
                Array.prototype.push.apply(this.list,fns);
            }
            //若开启记忆功能
            if(option.memory &amp;&amp; fired){
                // 手动触发回调,调用公共fire
                fire(this.list);
            }else{
                firingStart = 0; //没有记忆功能跟还没触发，则永远是0；
            }
        },
        //触发回调函数
        fire:function(){
            //从0开始
            firingStart = 0;
            fire(this.list);
        }
    }
}
var cb = Callbacks({memory:true});
cb.add(fn1);
cb.fire();//新书发行啦 新电影上映啦
cb.add(fn2);
cb.fire();//新书发行啦 新电影上映啦</code></pre>
<h2 id="回调函数跳出（stopOnFalse）"><a href="#回调函数跳出（stopOnFalse）" class="headerlink" title="回调函数跳出（stopOnFalse）"></a>回调函数跳出（stopOnFalse）</h2><p>我们经常看到一种场景，就是回调返回 <code>false</code> 的时候，接下来的一系列函数将不再继续执行，这也很简单：</p>
<pre><code class="js">function Callbacks(option){
    //省略代码
    function fire(data){
        //表示函数已经触发过
        fired = true;
        for(var i = firingStart || 0; i &lt; data.length; i++ ){
            if ((data[i])() === false){//等于false时跳出循环
                break;
            }
        }
    }
    //省略代码
}</code></pre>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>总的来说，jQuery里面的回调还是有些复杂，上面的只是主要思路的重现，并不代表源码也是这样实现：</p>
<pre><code class="js">jQuery.Callbacks = function( options ) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === &quot;string&quot; ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery.extend( {}, options );

    var // Last fire value (for non-forgettable lists)
        memory,
        // Flag to know if list was already fired
        fired,
        // Flag to know if list is currently firing
        firing,
        // First callback to fire (used internally by add and fireWith)
        firingStart,
        // End of the loop when firing
        firingLength,
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,
        // Actual callback list
        list = [],
        // Stack of fire calls for repeatable lists
        stack = !options.once &amp;&amp; [],
        // Fire callbacks
        fire = function( data ) {
            memory = options.memory &amp;&amp; data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {
                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {
                    memory = false; // To prevent further calls using add
                    break;
                }
            }
            firing = false;
            if ( list ) {
                if ( stack ) {
                    if ( stack.length ) {
                        fire( stack.shift() );
                    }
                } else if ( memory ) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        },
        // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if ( list ) {
                    // First, we save the current length
                    var start = list.length;
                    (function add( args ) {
                        jQuery.each( args, function( _, arg ) {
                            var type = jQuery.type( arg );
                            if ( type === &quot;function&quot; ) {
                                if ( !options.unique || !self.has( arg ) ) {
                                    list.push( arg );
                                }
                            } else if ( arg &amp;&amp; arg.length &amp;&amp; type !== &quot;string&quot; ) {
                                // Inspect recursively
                                add( arg );
                            }
                        });
                    })( arguments );
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if ( firing ) {
                        firingLength = list.length;
                    // With memory, if we&#39;re not firing then
                    // we should call right away
                    } else if ( memory ) {
                        firingStart = start;
                        fire( memory );
                    }
                }
                return this;
            },
            // ... 省略部分代码
            // Call all callbacks with the given context and arguments
            fireWith: function( context, args ) {
                if ( list &amp;&amp; ( !fired || stack ) ) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if ( firing ) {
                        stack.push( args );
                    } else {
                        fire( args );
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith( this, arguments );
                return this;
            }
        };

    return self;
};</code></pre>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>jQuery源码通过闭包形式返回一个callback对象，可以通过该对象对一系列函数进行管理控制。在动画运动，事件绑定，延迟对象等功能中，都是以回调对象为基础进行实现，所以，理解该API源码的实现对于接下来源码的阅读都有着重要的作用。</p>
<p>好啦，先这样吧。因为这一篇代码贴的有点长，所以大家看得可能并不是太爽，不过没有关系，代码的实现是有多种方式的，这里主要是重现了一下思路吧，大伙提纲挈领的看看即可，若要深究，去看看源码就好啦。</p>
]]></content>
  </entry>
  <entry>
    <title>菜鸟解读jQuery源码系列-一-jQuery对象的诞生记</title>
    <url>/article/2020/01/28/%E8%8F%9C%E9%B8%9F%E8%A7%A3%E8%AF%BBjQuery%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-%E4%B8%80-jQuery%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%9E%E7%94%9F%E8%AE%B0.html</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>作为整个jQuery源码解读系列的开篇，不说点啥怪不好意思的（讨打脸）。</p>
<ul>
<li>首先老生常谈，现在VUE都大行其道了，为啥还要阅读jQuery源码？其实我只想反问一句，春秋战国，唐宋盛世都过去无数年了，你怎么不用草泥马来写高考作文？</li>
<li>其次，jQuery真的过时了么？确定？说过时的不要慌，我不会打你的，不过请你多去看看各类插件的源码，你会发现，jQuery源码的影子无处不在；</li>
<li>其三，jQuery源码是使用原生js写成的，阅读它有助于提高我们的原生能力，也就是传说中的修内功；</li>
<li>最后，很令人忧伤，目前我就只读过jQuery源码啊。。。别打我！这里先定个目标，一年内我会写一个VUE的源码解读系列！！</li>
</ul>
<p>还有一点温馨提示：这个系列不在于解读源码，也就是说，我会尽量用简单的代码来模拟源码的实现，这样，大伙看过之后既便于理解，独自去阅读源码时，自然也就心中有数了。</p>
<p>现在，就让我们开始吧！</p>
<h2 id="一点疑问"><a href="#一点疑问" class="headerlink" title="一点疑问"></a>一点疑问</h2><p>让我们先来看几个常用的场景</p>
<pre><code class="js">$(document).ready(...) //等待DOM渲染完成
$(&quot;#id&quot;).find(...) //查找id下的某元素
$(&quot;&lt;li&gt;&lt;/li&gt;&quot;).appendTo(...) //创建元素添加到某元素
// ...</code></pre>
<p>这些场景我们都是见怪不怪了，不过有没有人思考过，<code>$(...)</code>这个东西是如何产生的呢？很显然它是一个对象，但是它为何可以调用各种我们常见的方法？这里想必有很多聪明的小伙伴已经发怒了，原型啊！这不是侮辱我高达150的智商么！！！额。。。好吧！算你聪明，接下来让我们看一段代码：</p>
<pre><code class="js">function jQuery(){
    this.name = &quot;jquery&quot;;
    //...
}
jQuery.prototype = {
    construtor: jQuery,
    find: function(){
        console.log(&#39;find方法执行&#39;);
    }
}
var $ = new jQuery();
$.find() //find方法执行; 终于可以开始愉快的调用$.find方法了</code></pre>
<p>写到这里，各位小伙伴大佬微微点头：不错不错，我就是这个意思！！这个时候John Resig(jQuery的作者)跳了出来：我可没这样写，不要侮辱我的智商！！！小伙伴大佬：咦，你不就是这样写的吗，有啥了不起的，切！</p>
<h2 id="灵魂拷问"><a href="#灵魂拷问" class="headerlink" title="灵魂拷问"></a>灵魂拷问</h2><p>上面John Resig跟小伙伴大佬的争论我就不管了，先看其中有什么猫腻吧：</p>
<pre><code class="js">$(&quot;#id&quot;).find() //John Resig
$.find() //小伙伴大佬</code></pre>
<p>咦，好像还真有点不一样！！John Resig是通过<code>$(&quot;#id&quot;)</code>函数调用后才调用<code>find</code>，小伙伴大佬是直接通过<code>$</code>对象调用了<code>find</code>；</p>
<p>说到这里，小伙伴大佬不服气了，这有啥了不起啊？！！</p>
<p>嗯嗯。。。这貌似是个问题，这有啥了不起呢？？</p>
<p>文明人还是多上代码少上手吧：</p>
<pre><code class="js">//John Resig：看我的 $ 能变几样！
$(document) === $(document) //false
//小伙伴大佬：难道我的 $ 就虚你？
$ === $ //true  哟，沃德天，咋就一模一样了？...</code></pre>
<p>显而易见，John Resig的<code>$()</code>方法调用时,内部一定是生成并返回了一个新对象，其实也就是每调用一次，<code>new jQuery()</code>都会执行一次并放回，这其实也就是源码内部所做的事情，从而省掉了每次都要手动<code>new</code>一个jQuery实例对象的操作。这个非常精妙的设计是怎么实现的呢？小伙伴大佬陷入了沉思。。。</p>
<h2 id="闭关修炼"><a href="#闭关修炼" class="headerlink" title="闭关修炼"></a>闭关修炼</h2><h4 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h4><p>不就是返回一个<code>new jQuery</code>吗？</p>
<pre><code class="js">function jQuery(){
    return new jQuery(); //so easy!!
}
jQuery.prototype = {
    construtor: jQuery,
    find: function(){
        console.log(&#39;find方法执行&#39;);
    }
}
var $ = jQuery;
//造成了循环调用，内存溢出，失败
$().find();//Uncaught RangeError: Maximum call stack size exceeded...</code></pre>
<p>显而易见，构造函数里面使用同一个构造函数来生成实例是行不通的，这样会造成循环调用导致内存溢出。</p>
<h4 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h4><p>显然直接返回<code>new jQuery()</code>对象是行不通的了，那就返回一个新函数吧，只要新函数的原型继承了原有的jQuery对象，不也就可以了吗？</p>
<pre><code class="js">function Fn(){} //即将继承jQuery的函数
function jQuery(){
    return new Fn(); //so easy!!
}
//继承jQuery函数
Fn.prototype = jQuery.prototype = {
    construtor: jQuery,
    find: function(){console.log(&quot;成功&quot;)}
}
var $ = jQuery;
$().find(); //成功！！</code></pre>
<p>这段代码跟第一次有啥区别呢，其实只是转换了一下思路。我们创建jQuery实例对象的目标，不就是为了使用jQuery原型对象上面的各种方法吗？</p>
<p>是不是一定要jQuery构造函数才可以可以继承呢？显然不是，随便创建一个构造函数，只需要使其继承jQuery构造函数的原型，不是一样可以做到吗？（不熟悉原型继承的小伙伴先移步去了解相关知识点）；</p>
<h4 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h4><p>下面是jQuery源码中的具体实现，小伙伴们请对比上例代码来理解：</p>
<pre><code class="js">// 定义jQuery构造函数
jQuery = function( selector, context ) {
    //返回一个新函数
    return new jQuery.fn.init(/** selector, context, rootjQuery **/);
};
jQuery.fn = jQuery.prototype = {
    constructor: jQuery,
    init: function(/** selector, context, rootjQuery **/){},
    find:function(){console.log(&quot;成功&quot;)},//伪造的测试方法
    //...
}
// init其实就是继承jQuery的新函数(Fn)，所以需要手动添加继承
jQuery.fn.init.prototype = jQuery.fn;
//测试
var $ = jQuery;
$().find(); //成功！！</code></pre>
<p>看到这里，可能有的小伙伴有点蒙，这。。这是类似的代码？没有错，这里的<code>init</code>函数跟上例的<code>Fn</code>函数都是同一个东西，发挥着同样的作用。不理解的小伙伴请继续阅读系列二，那里会做一个深入的分析，这里先不展开了。</p>
<h2 id="修仙秘笈"><a href="#修仙秘笈" class="headerlink" title="修仙秘笈"></a>修仙秘笈</h2><p>上文的源码实现其实就是第二次尝试的升级版本而已，原理是一模一样的，只不过显得有些绕，慢慢琢磨应该都可以领会。因为这是jQuery源码解读的第一篇，所以有必要把一些细节继续讲述一下：</p>
<h4 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h4><p>jQuery的框架结构其实也非常简单，就是一个立即执行函数：</p>
<pre><code class="js">//简化版本
(function( window, undefined ) {
    //...定义一些常用变量
    //定义jQuery构造函数
    var jQuery = function(){};
    //添加各类原型方法
    jQuery.extend({...});
    //构造函数上面挂载各类工具方法
    jQuery.xxx = function(){...}
    //抛出构造函数，把jQuery注册为全局方法
    window.jQuery = window.$ = jQuery;
})( window );//传入window，缩短作用域链，函数内部可以更快访问到window</code></pre>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul>
<li>window传入<br>之所以要在立即执行函数传入window变量，是因为js的作用链机制是层层由内而外查找的，传入window可以缩短查找window时的路径；</li>
<li>undefined<br>  立即执行函数接收两个参数，第二个参数undefined永远是undefined，这样处理是为了避免undefined在外部被修改：<pre><code class="js">undefined = &quot;hello&quot;;
console.log(undefined);//hello (某些版本浏览器下可以修改，如ie8)</code></pre>
</li>
</ul>
<p>好了，这篇到这就暂告一个段落了，下一篇我们会继续探究jQuery对象的秘密，让我们继续下去吧！</p>
]]></content>
  </entry>
  <entry>
    <title>经典排序算法</title>
    <url>/article/2020/01/28/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><pre><code class="js">function swap(arr,i,j){
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
//冒泡排序
function bubbleSort(arr){
    for (var i = arr.length - 1; i &gt; 0; i--) {
        for (var j = 0; j &lt; i; j++) {
            if (arr[j] &gt; arr[j+1]) {
                swap(arr,j,j+1)
            }
        }
    }
    return arr;
}</code></pre>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><pre><code class="js">//选择排序
function selectionSort(arr){
    for (var i = 0; i &lt; arr.length - 1; i++) {
        var index = i;
        for (var j = i + 1; j &lt; arr.length; j++) {
            if (arr[j] &lt; arr[index]) {
                index = j;
            }
        }
        swap(arr,i,index);
    }
    return arr;
}</code></pre>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><pre><code class="js">//插入排序
function insertionSort(arr){
    for (var i = 1; i &lt; arr.length; i++) {
        var temp = arr[i];
        var j = i;
        while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp){
            swap(arr,j,j-1);
            j--;
        }
    }
    return arr;
}</code></pre>
<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><pre><code class="js">//希尔排序
function shellSort(arr){
    var interval = Math.floor(arr.length/2);
    while(interval &gt; 0){
        for (var i = 0; i &lt; interval; i++) {
            for (var j = i + interval; j &lt; arr.length; j = j + interval) {
                var temp = arr[j];
                var index = j;
                while(index &gt; 0 &amp;&amp; arr[index - interval] &gt; temp){
                    swap(arr,index,index - interval);
                    index = index - interval;
                }
            }
        }
        if (interval == 1) {
            return arr;
        }
        interval = Math.floor(interval/3) + 1;
    }
    return arr;
}</code></pre>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><pre><code class="js">//归并排序
function mergeSort(arr){
    if (arr.length &lt; 2) {return;}
    var step = 1;
    var left,right;
    while(step &lt; arr.length){
        left = 0;
        right = step;
        while(right + step &lt;= arr.length) {
            mergeArr(arr,left,left+step,right,right+step);
            left = right + step;
            right = left + step;
        }
        if (right &lt; arr.length) {
            mergeArr(arr,left,left+step,right,arr.length)
        }
        step *= 2;
    }
    return arr;
}
function mergeArr(arr, startLeft, stopLeft, startRight, stopRight){
    var leftArr = new Array(stopLeft - startLeft + 1);
    var rightArr = new Array(stopRight - startRight + 1);
    var k = startLeft;
    for (var i = 0; i &lt; leftArr.length; i++) {
        leftArr[i] = arr[k++];
    }
    k = startRight;
    for (var i = 0; i &lt; rightArr.length; i++) {
        rightArr[i] = arr[k++];
    }
    rightArr[rightArr.length-1] = Infinity; // 哨兵值
    leftArr[leftArr.length-1] = Infinity; // 哨兵值
    var n = 0,m = 0;
    for (var i = startLeft; i &lt; stopRight; i++) {
        if (leftArr[m] &gt; rightArr[n]) {
            arr[i] = rightArr[n++];
        }else{
            arr[i] = leftArr[m++];
        }
    }
}</code></pre>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><pre><code class="js">//快速排序
function qSort(list) {
    if (list.length == 0) {
        return [];
    }
    var lesser = [];
    var greater = [];
    var pivot = list[0];
    for (var i = 1; i &lt; list.length; i++) {
        if (list[i] &lt; pivot) {
            lesser.push(list[i]);
        } else {
            greater.push(list[i]);
        }
    }
    return qSort(lesser).concat(pivot, qSort(greater));
}
//递归型
function recurQuickSort(arr,startIndex,endIndex){
    if (startIndex &gt;= endIndex) {return;}
    var pivotIndex = partition(arr,startIndex,endIndex);
    recurQuickSort(arr,startIndex,pivotIndex);
    recurQuickSort(arr,pivotIndex + 1,endIndex);
    return arr;
}
//非递归型
function  quickSort(arr){
    var stack = [];
    var param = {
        start:0,
        end:arr.length - 1
    }
    stack.push(param);
    while(stack.length &gt; 0){
        var curParam = stack.pop();
        var pivotIndex = partition(arr,curParam.start,curParam.end);
        if (curParam.start &lt; pivotIndex) {
            stack.push({
                start:curParam.start,
                end:pivotIndex
            })
        }
        if (curParam.end &gt; pivotIndex) {
            stack.push({
                start:pivotIndex + 1,
                end:curParam.end
            })
        }
    }
    return arr;
}
//交换左右位置
function partition(arr,startIndex,endIndex){
    var pivot = arr[startIndex];
    var start = startIndex,end = endIndex;
    while(start &lt; end){
        while(start &lt; end){
            if (arr[end] &lt; pivot) {
                break;
            }else{
                end--;
            }
        }
        while(start &lt; end){
            if (arr[start] &gt; pivot) {
                break;
            }else{
                start++;
            }
        }
        swap(arr,start,end);
    }
    swap(arr,startIndex,start);
    return start;
}</code></pre>
<h2 id="快排升级版"><a href="#快排升级版" class="headerlink" title="快排升级版"></a>快排升级版</h2><pre><code class="js">function quickSort(arr,l,r){
    if (l &lt; r) {
        swap(arr, l + Math.floor(Math.random() * (r - l + 1)), r);
        var range = partition(arr,l,r);
        quickSort(arr,l,range[0]-1);
        quickSort(arr,range[1]+1,r)
    }
    return arr;
}
function partition(arr,l,r){
    var less = l-1;
    var more = r;
    var val = arr[r];
    var cur = l;
    while(cur &lt; more){
        if (arr[cur] &lt; val) {
            swap(arr,++less,cur++)
        }else if(arr[cur] &gt; val){
            swap(arr,--more,cur);
        }else{
            cur++;
        }
    }
    swap(arr,r,more)
    return [less+1,more];
}</code></pre>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><pre><code class="js">function heapSort(arr){
    if (arr.length &lt; 2) {return}
    for (var i = 0; i &lt; arr.length; i++) {
        heapInsert(arr,i)
    }
    swap(arr,0,arr.length-1);
    var size = arr.length - 1;
    while(size &gt; 0){
        heapify(arr,0,size);
        swap(arr,0,--size)
    }
    return arr;
}
function heapInsert(arr,index){
    while(arr[index] &gt; arr[Math.floor((index-1)/2)]){
        swap(arr,index,Math.floor((index-1)/2));
        index = Math.floor((index-1)/2);
    }
}
function heapify(arr,index,size){
    var largest,left=index*2+1;
    while(left &lt; size){
        largest = left+1 &lt; size &amp;&amp; arr[left+1] &gt; arr[left] ? left+1 : left;
        largest = arr[largest] &gt; arr[index] ? largest : index;
        if (largest === index) {
            break;
        }
        swap(arr,index,largest);
        index = largest;
        left=index*2+1;
    }
}</code></pre>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="js">test(bubbleSort);
test(selectionSort);
test(insertionSort);
test(shellSort);
test(mergeSort);
test(qSort);
test(recurQuickSort);
test(quickSort);

//生成测试数组
function createData(num){
    if (typeof num !== &#39;number&#39;) {
        num = 1000000;
    }
    var arr = [];
    for (var i = 0; i &lt; num; i++) {
        arr.push(Math.floor(Math.random() * num))
    }
    return arr;
}

//对比排序数组是是否正确
function diffArr(rightArr,sortArr){
    if (rightArr.length !== sortArr.length) {
        return false;
    }
    var len = rightArr.length;
    for (var i = 0; i &lt; len; i++) {
        if (rightArr[i] !== sortArr[i]) {
            return false;
        }
    }
    return true;
}

//测试
function test(fn,num){
    if (typeof num !== &#39;number&#39;) {
        num = 1;
    }
    var isSame = true;
    console.time();
    for (var i = 0; i &lt; num; i++) {
        var arr = createData();
        var rightArr = arr.slice().sort(function(i,j){
            return i - j;
        });
        var sortArr = fn(arr,0,arr.length-1);
          isSame = diffArr(rightArr,sortArr);
          if (!isSame) {break;}
    }
    console.timeEnd();
    if (isSame) {
        console.log(sortArr);
        console.log(&#39;the sort is awsome!!&#39;);
    }else{
        console.log(&#39;fuck shit!!&#39;);
    }
}</code></pre>
]]></content>
  </entry>
  <entry>
    <title>深入理解闭包</title>
    <url>/article/2020/01/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我们来说一个人见人爱，花见花开的的主题 - - 闭包。有的小伙伴就说了，扯犊子，哪里人见人爱，花见花开了？我是见着闭包就烦！好吧，如果是这样，那这句话不是对你说的，我是对神秘莫测的大佬（装逼犯）说的。</p>
<p>好吧，废话有点多，不过有点是真的，如果你掌握了闭包，它确实是个好东西，人见人爱，花见花开是一点也不夸张。</p>
<p>进入正题。</p>
<h2 id="闭包初体验"><a href="#闭包初体验" class="headerlink" title="闭包初体验"></a>闭包初体验</h2><p>看到深入闭包这个吓唬人的标题还敢进来的，相信各位之前都有一定的接触了，我们就暴力一些，直入正题吧：</p>
<pre><code class="js">function foo() {
    var n = 0;
    function bar() {
        return ++n;
    }
    return bar;
}
var a = foo();
a(); // 1
a(); // 2</code></pre>
<p>好了，相信各位小伙伴已经看过无数个类似的栗子了，甚至有了平平无奇大闭包的印象。</p>
<p>这里我想提问一个问题，为什么 <code>a</code> 第2次调用的时候不是1而是再之前的基础上递增？</p>
<ul>
<li>foo 函数调用后返回 bar 函数给 a ,因为 bar 是一个函数对象，所以 a 其实持有的只是 bar 函数的指引。</li>
<li>根据词法作用域，函数的作用域在声明时已经确定了下来，而与函数在哪里调用无关，所以，bar 函数的外层作用域正是 foo 函数的内部作用域。</li>
<li>因为 a 持有 bar 函数的指引，foo 函数调用后，其内部作用域并没有销毁，所以重复调用 a 也就调用 bar 函数时， n 得以不断递增。</li>
</ul>
<p>相信很多小伙伴对这段描述已经是耳熟能详了，我们就到此为止，接着看看改造后的栗子。</p>
<h2 id="孙大圣的汗毛"><a href="#孙大圣的汗毛" class="headerlink" title="孙大圣的汗毛"></a>孙大圣的汗毛</h2><p>小伙伴们无语了，“博主！”，“讨论学术能不能严肃点！！”</p>
<p>好吧，虽然我很多时候起标题有些不靠谱，但是，可以肯定的是，这一次的标题是再恰如其分不过了！</p>
<p>怎么说呢？请看：</p>
<pre><code class="js">function foo() {
    var n = 0;
    function bar() {
        return ++n;
    }
    return bar;
}
var a = foo();
var b = foo();
a(); // 1
a(); // 2
b(); // 1
b(); // 2</code></pre>
<p>小伙伴们无语了，这有啥奇怪呀！</p>
<p>好吧，虽然跟上例只有一点点变化，但是其中隐藏着一个极其重要的知识点。</p>
<p>我先问一个问题，为什么 b 调用后， n 不是在之前的基础上递增，而是从头开始？</p>
<p>照例，代码说话：</p>
<pre><code class="js">function foo() {
    var n = [1,2];
    function bar() {
        n.push(3);
        return n;
    }
    return bar;
}
var a = foo();
var b = foo();
var a1 = a();
var a2 = a();
var b1 = b();
var b2 = b();
console.log(a1);// [1,2,3,3]
console.log(b1);// [1,2,3,3]
//重点关注！！
console.log(a1 === a2); //true
console.log(b1 === b2); //true
console.log(a1 === b1); //false</code></pre>
<p>啥情况？a 跟 b 不都是指向 bar 函数么？怎么返回的 n 不相等呢？</p>
<p>原因简要说就一句话：生成闭包的函数（foo）每调用一次，就创造一个<strong>独立的作用域链</strong>，也可以看做是产生一个上下文环境，<strong>相互独立，互不影响</strong>！</p>
<p>好了，这个时候可以回头看看本小节的标题了。</p>
<p>见没见过孙大圣的汗毛？换句话说孙大圣就是 foo 函数， a 跟 b 就是孙大圣的汗毛了，它们长得跟孙大圣极其类似（要素相同的作用域链），但是它们可以自由活动，互不影响（作用域链相互独立）。</p>
<h2 id="铁证如山"><a href="#铁证如山" class="headerlink" title="铁证如山"></a>铁证如山</h2><p>小伙伴们就郁闷了，这就能证明了么？</p>
<p>按照我的理解，确实是可以证明了，不过为了让大伙加深认识，我们来看看一个栗子，也是促使我写下本文的一个极好的栗子：</p>
<pre><code class="js">var add = null;
function foo() {
    var n = 0;
    add = function(){
        n++;
        console.log(n);
    }
    function bar(){
        n++;
        console.log(n);
    }
    return bar;
}
var a = foo();
var b = foo();
a();//1
a();//2
add();//1
b();//2
b();//3</code></pre>
<p>啥情况？为什么 add 横插一脚调用之后，b 竟然不再从 1 开始了！！！</p>
<p>其实深入理解上一节的小伙伴，加上一点细心，就会发现其中的蹊跷。</p>
<p>上一节说了，a 跟 b 都是 foo 函数产生的一根汗毛，那是怎么产生的呢？</p>
<p>额，被我吓唬一下就一哆嗦的小伙伴，请听我细细道来：</p>
<p>foo 是不是函数？函数是怎么调用的？</p>
<p>当然是一泻千里，一行到底啊！！！函数还能怎么调用！！！</p>
<p>不过这有一个特殊的细节，就是 add 函数。</p>
<h5 id="揭秘时刻"><a href="#揭秘时刻" class="headerlink" title="揭秘时刻"></a>揭秘时刻</h5><p>add 函数是表达式的，产生 a 的时候，全局变量 add 被赋值；接着产生 b 的时候，add 变量就被重写了！！！</p>
<p>什么意思呢？</p>
<p>换句话说，在调用 add 的时候，add 是指向的是 b 函数所在的作用域链。</p>
<p>要证明？</p>
<pre><code class="js">var add = null;
function foo() {
    var n = 0;
    add = function(){
        n++;
        console.log(n);
    }
    function bar(){
        n++;
        console.log(n);
    }
    return {bar:bar,add:add};
}
var a = foo();
var b = foo();
console.log(a.add === add); // false
console.log(b.add === add); // true</code></pre>
<p>同样，我们也可以把 add 函数加到 a 上面啦，交换一下 a , b 产生的顺序即可：</p>
<pre><code class="js">var add = null;
function foo() {
    var n = 0;
    add = function(){
        n++;
        console.log(n);
    }
    function bar(){
        n++;
        console.log(n);
    }
    return bar;
}
//换一下顺序
var b = foo();
var a = foo();
a();//1
a();//2
add();//3
b();//1
b();//2</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，闭包的博文可谓是浩如烟海了，我这篇也是站在巨人的肩膀上胡扯一番，如有错误，还请留言交流。</p>
<p>没有错误也请留下您的脚印，交个朋友嘛，行不行嘛？</p>
]]></content>
  </entry>
  <entry>
    <title>深入理解viewport</title>
    <url>/article/2020/01/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3viewport.html</url>
    <content><![CDATA[<pre><code class="js">screen.width &amp;&amp; screen.height //设备尺寸

window.innerWidth &amp;&amp; window.innerHeight //浏览器CSS像素（CSS pixels），包括滚动条

window.pageXOffset &amp;&amp; window.pageYOffset //浏览器滚动CSS像素

document.documentElement.clientWidth &amp;&amp; document.documentElement.clientWidth //viewport尺寸，不包括滚动条

document.documentElement.offsetWidth &amp;&amp; document.documentElement.offsetHeight //html尺寸

pageX &amp;&amp; pageY //鼠标相对html的位置

clientX &amp;&amp; clientY //鼠标相对viewport的位置

screenX &amp;&amp; screenY //鼠标相对设备的位置</code></pre>
<pre><code class="js">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; &gt;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>探秘Promise的实现原理</title>
    <url>/article/2020/01/28/%E6%8E%A2%E7%A7%98Promise%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面写了很多关于异步回调的文章了，大伙对于Promise的认识可谓再也熟悉不过了。今天我们也就不再炒冷饭了，而是换个角度，手动实现一个自己的promise。还不了解Promise的小伙伴，先去了解一番其基本用法再来阅读更佳。</p>
<h2 id="提个问题"><a href="#提个问题" class="headerlink" title="提个问题"></a>提个问题</h2><p>先看代码：</p>
<pre><code class="js">var promise = new Promise((resolve,reject)=&gt;{
    console.log(&quot;I am in promise&quot;); //执行
});
var then1 = promise.then((res) =&gt; {
    console.log(&quot;I am in then1&quot;); //这句不会执行
});
var then2 = then1.then((res) =&gt; {
    console.log(&quot;I am in then2&quot;); //这句不会执行
});
console.log(then1 instanceof Promise);//true
console.log(then2 instanceof Promise);//true
console.log(promise === then1);//false
console.log(then1 === then2);//false</code></pre>
<p>上面代码是我们再也熟悉不过的了。不过，你们从上面的执行结果中看出了什么了呢？</p>
<ul>
<li>Promise 构造函数里面的参数函数同步执行</li>
<li>then 方法每次都返回一个全新的Promise</li>
<li>then 方法同步顺序执行，只是方法内的回调函数异步执行</li>
</ul>
<p>第一，二点我们之前有提过，更多人会忽略的是第三点。</p>
<p>有人不解了，then 方法同步执行确实有人会忽略，因为有的人会粗心大意的以为它是在回调调用的时候才执行，但是你又怎么证明呢？</p>
<p>其实证明已经在上面了， <code>then1 != then2</code> 充分证明了then方法已经调用并返回一个全新的 Promise 。</p>
<p>说这些有啥用呢？</p>
<p>对于小伙伴大佬来说，这确实是一段废话，不过对于其他小伙伴来说，认清这个知识点对理解下面代码还是有帮助的。</p>
<h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>对照原生的Promise，我们知道它是一个构造函数，这样的话，照葫芦画瓢就好了：</p>
<pre><code class="js">function MyPromise(executor){
    //初始状态
    this.state = &#39;pending&#39;;
    //存放then方法中的回调函数参数
    this.resolvedCallback = [];
    this.rejectedCallback = [];
    //executor的成功回调函数参数
    function resolve(value){
        this.state = &#39;fullfilled&#39;;
        this.resolvedCallback.forEach(function(item){
            item(value);
        })
    }
    //executor的失败回调函数参数
    function reject(value){
        this.state = &#39;rejected&#39;;
        this.rejectedCallback.forEach(function(item){
            item(value);
        })
    }
    //构造函数执行，executor立即执行
    //因为resolve，reject都是在函数外执行，需要绑定this指向
    executor(resolve.bind(this),reject.bind(this));
}</code></pre>
<p>构造函数初步实现，我们看看最关键的then方法。</p>
<p>因为每个Promise对象都有一个then方法，所以，我们需把它定义在原型上：</p>
<pre><code class="js">MyPromise.prototype.then = function(onResolved,onRejected){
    var pendingPromise;
    //当状态为pending时，此时this指向上一个Promise实例
    if (this.state === &#39;pending&#39;) {
        //返回一个全新的实例 pendingPromise
        return pendingPromise = new MyPromise((resolve,reject) =&gt; {
            //存储then方法中的成功回调函数到上一个实例
            this.resolvedCallback.push(function(value){
                //通过一个匿名函数包装起来，等待上一个实例resolve执行
                var res = onResolved(value);
                //判断是否返回一个Promise对象
                if (res instanceof MyPromise) {
                    //pendingPromise实例的控制权交由res实例控制
                    res.then(resolve,reject);
                }else{
                    //直接改变pendingPromise实例的状态，执行下一个then方法的成功回调函数
                    resolve(res);
                }
            });
            //存储then方法中的失败回调函数到上一个实例
            this.rejectedCallback.push(function(value){
                var res = onRejected(value);
                if (res instanceof MyPromise) {
                    res.then(resolve,reject);
                }else{
                    reject(res);
                }
            });
        })
    }
}</code></pre>
<p>这是一段核心代码，而且有点绕，需要小伙伴们仔细阅读注释以助理解。这里我再多解释几句。</p>
<h5 id="一、为什么只需判断-pending-状态？"><a href="#一、为什么只需判断-pending-状态？" class="headerlink" title="一、为什么只需判断 pending 状态？"></a>一、为什么只需判断 <code>pending</code> 状态？</h5><p>前面我们已经知道，因为 then 方法是顺序同步执行的，在executor函数里面是异步调用 <code>resolve</code> 方法的前提下，then 方法调用时，状态都还没改变，也就是都还是 pending 状态。所以无需判断其他状态。</p>
<h5 id="二、pendingPromise-实例是一个什么样的状态？"><a href="#二、pendingPromise-实例是一个什么样的状态？" class="headerlink" title="二、pendingPromise 实例是一个什么样的状态？"></a>二、<code>pendingPromise</code> 实例是一个什么样的状态？</h5><p>很好，既然你都说是实例，也就是构造函数已经执行了，前面我们同样也已经知道，构造函数一执行，executor函数也是立即执行的。</p>
<p>换句话说</p>
<ol>
<li>初始生成一个MyPromise实例</li>
<li>executor函数执行</li>
<li>then 方法执行</li>
<li>生成一个新实例，executor函数执行</li>
<li>then方法的回调函数被添加到上一个实例resolvedCallback中</li>
<li>若还有then方法，重复 3，4，5，6</li>
</ol>
<h5 id="三、then方法中的-onResolved-与-onRejected-存放在哪里？"><a href="#三、then方法中的-onResolved-与-onRejected-存放在哪里？" class="headerlink" title="三、then方法中的 onResolved 与 onRejected 存放在哪里？"></a>三、then方法中的 <code>onResolved</code> 与 <code>onRejected</code> 存放在哪里？</h5><p>为了说明这个问题，我们来看一段伪代码：</p>
<pre><code class="js">new MyPromise(function(){
    //初始生成一个MyPromise实例
}).then(
    //生成一个新实例pendingPromise1，executor函数执行
    //this指向MyPromise实例
    //onResolved被包装在一个匿名函数中，存储到this.resolvedCallback中
    //返回pendingPromise1实例
).then(
    //生成一个新实例pendingPromise2，executor函数执行
    //this指向pendingPromise1实例
    //onResolved被包装在一个匿名函数中，存储到this.resolvedCallback中
     //返回pendingPromise2实例
)</code></pre>
<h5 id="四、resolve-调用时发生了什么？"><a href="#四、resolve-调用时发生了什么？" class="headerlink" title="四、resolve 调用时发生了什么？"></a>四、resolve 调用时发生了什么？</h5><p>在说明这个过程之前，我们先测试一下上面的代码能不能执行：</p>
<pre><code class="js">new MyPromise(function(resolve,reject){//初始生成一个MyPromise实例
    setTimeout(function(){
        resolve(123)
    },1000)
}).then(function(res){//生成一个新实例pendingPromise1
    console.log(res);
    return new MyPromise(function(resolve,reject){
        setTimeout(function(){
            resolve(456)
        },1000)
    })
}).then(function(res){//生成一个新实例pendingPromise2
    console.log(res)
});
//123
//456</code></pre>
<p>很好，经过测试，上例代码完美异步执行了。但是这时小伙伴肯定还是充满疑惑。我们就针对这段代码分析其中的过程。</p>
<ul>
<li>then 方法同步顺序执行，所以在第一个实例的resolve函数执行之前，该段代码已经生成三个MyPromise实例了。</li>
<li>在生成MyPromise实例的同时，把then方法的成功与失败回调函数分别存储到上一个实例中。</li>
<li>then中回调函数参数通过匿名函数包装起来，并且还包含着当前实例的 resolve 跟 reject 方法，这也就前后两个实例的联系的桥梁。</li>
<li>resolve 函数调用时，执行当前实例存储的回调函数。回调函数又保存着下一个实例的 resolve 与 reject 方法指引，继续触发下一个实例的resolve。</li>
<li>当回调函数返回一个 MyPromise 实例时，则交由该实例控制下一个实例的 resolve 异步调用的时机。</li>
</ul>
<h2 id="进一步完善"><a href="#进一步完善" class="headerlink" title="进一步完善"></a>进一步完善</h2><p>好了，认真读到这里的小伙伴，所有的核心代码其实已经接触到了，下面主要是进一步完善而已。</p>
<h5 id="保证-resolve-异步执行"><a href="#保证-resolve-异步执行" class="headerlink" title="保证 resolve 异步执行"></a>保证 resolve 异步执行</h5><p>前面已经提到，当resolve 异步执行的时候，then 方法已经全部调用了，并生成了所有的实例。</p>
<p>但是我们也知道，原生的Promise有时并没有异步调用 resolve，这个时候如果按照目前的实现，resolve同步调用时，后面的then方法还没调用，也就是说还没有生成全部的实例，换句话说回调函数还没存储起来，整个流程也就无法进行下去了，所以我们需要做一些处理：</p>
<pre><code class="js">function resolve(value){
    //避免resolve传进MyPromise实例的情况
    if (value instanceof MyPromise) {
      return value.then(resolve, reject)
    }
    //保证回调函数的调用异步执行，此时回调函数已经被存储起来了
    setTimeout(() =&gt; {
        this.state = &#39;fullfilled&#39;;
        this.resolvedCallback.forEach(function(item){
            item(value);
        })
    })
}</code></pre>
<p>嗯，就是这么简单。不过这里跟原生有个区别，原生的Promise属于微任务，setTimeout却属于宏任务，也就是说，原生Promise的执行优先级是在setTimeout之前的，这也就导致我们的实现跟原生有一丝的区别。</p>
<h5 id="值的传递"><a href="#值的传递" class="headerlink" title="值的传递"></a>值的传递</h5><p>原生中经常有这样的场景：</p>
<pre><code class="js">new Promise((resolve,reject)=&gt;{
    setTimeout(() =&gt; {
        resolve(123)
    },1000)
}).then().then((res)=&gt;{console.log(res)})</code></pre>
<p>所以我们需要保证then方法无参情况下值的传递：</p>
<pre><code class="js">MyPromise.prototype.then = function(onResolved,onRejected){
    //保证有默认的回调函数
    onResolved = typeof onResolved === &#39;function&#39; ? onResolved : function(res){return res;}
    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : function(value){return value;}

    //....
}</code></pre>
<h5 id="catch方法的实现"><a href="#catch方法的实现" class="headerlink" title="catch方法的实现"></a>catch方法的实现</h5><p>catch 方法本质上还是then方法：</p>
<pre><code class="js">MyPromise.prototype.catch = function(onRejected){
    //调用then方法即可
    this.then(null,onRejected);
}</code></pre>
<p>上面我们实现resolve 与 reject 方法时，是可以接收任何值的，下面我们对then方法做一些修改，reject 方法可以接收报错信息：</p>
<pre><code class="js">//....
//没有 reject 函数处理，则继续抛出错误，等待下一个实例的 reject 函数接收
onRejected = typeof onRejected === &#39;function&#39; ? onRejected : function(err){throw err;}
return new MyPromise((resolve,reject) =&gt; {
    this.resolvedCallback.push(function(value){
        try{
            var res = onResolved(value);
            if (res instanceof MyPromise) {
                res.then(resolve,reject);
            }else{
                resolve(res);
            }
        }catch(e){//报错则调用下一个实例的reject函数
            reject(e)
        }
    });
    this.rejectedCallback.push(function(value){
        try{
            var res = onRejected(value);
            if (res instanceof MyPromise) {
                res.then(resolve,reject);
            }
        }catch(e){//报错则调用下一个实例的reject函数
            reject(e);
        }
    });
})</code></pre>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="js">function MyPromise(executor){
    this.state = &#39;pending&#39;;
    this.resolvedCallback = [];
    this.rejectedCallback = [];

    function resolve(value){
        if (value instanceof MyPromise) {
          return value.then(resolve, reject)
        }
        setTimeout(() =&gt; {
            this.state = &#39;fullfilled&#39;;
            this.resolvedCallback.forEach(function(item){
                item(value);
            })
        })
    }

    function reject(value){
        setTimeout(() =&gt; {
            this.state = &#39;rejected&#39;;
            this.rejectedCallback.forEach(function(item){
                item(value);
            })
        })
    }

    try{
        executor(resolve.bind(this),reject.bind(this));
    }catch(e){
        reject.call(this,e);
    }
}

MyPromise.prototype.then = function(onResolved,onRejected){
    onResolved = typeof onResolved === &#39;function&#39; ? onResolved : function(res){return res;}
    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : function(err){throw err;}

    /*if (this.state === &#39;fullfilled&#39;) {
        return new MyPromise(function(resolve,reject){
            var res = onResolved(this.data);
            if (res instanceof MyPromise) {
                res.then(resolve,reject);
            }else{
                resolve(res);
            }
        })
    }

    if (this.state === &#39;rejected&#39;) {
        return new MyPromise(function(resolve,reject){
            var res = onRejected(this.data);
            if (res instanceof MyPromise) {
                res.then(resolve,reject);
            }else{
                reject(res);
            }
        })
    }*/

    if (this.state === &#39;pending&#39;) {
        return new MyPromise((resolve,reject) =&gt; {
            this.resolvedCallback.push(function(value){
                try{
                    var res = onResolved(value);
                    if (res instanceof MyPromise) {
                        res.then(resolve,reject);
                    }else{
                        resolve(res);
                    }
                }catch(e){
                    reject(e)
                }
            });
            this.rejectedCallback.push(function(value){
                try{
                    var res = onRejected(value);
                    if (res instanceof MyPromise) {
                        res.then(resolve,reject);
                    }
                }catch(e){
                    reject(e);
                }
            });
        })
    }
}

MyPromise.prototype.catch = function(onRejected){
    this.then(null,onRejected)
}</code></pre>
<h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><pre><code class="js">new MyPromise(function(resolve,reject){
    setTimeout(function(){
        resolve(123)
    },1000)
}).then(function(res){
    console.log(res);
    throw Error(&#39;eee&#39;)
    return new MyPromise(function(resolve,reject){
        setTimeout(function(){
            resolve(456)
        },1000)
    })
}).then(function(res){
    console.log(res);
}).catch(function(e){
    console.log(e)
})</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好啦，Promise 的原理探秘就到这里了。有的小伙伴可能就有些纳闷，说我看到过更加细致的实现，比如resolvePromise实现不同Promise之间的交互之类的（有多种Promise库）。但是我们真正的目的并不是要实现一个给我们使用的Promise，毕竟再努力也赶不上原生给我们提供的不是吗？（唉，渣渣的无奈），所以，我们的目标是通过探究其中的原理来开阔一下自己的视野，我觉得这才是最有意义的。</p>
<p>有兴趣的小伙伴可以在前面代码的基础上，尝试扩展一下MyPromise.all,MyPromise.race等静态工具方法，这里就不展开啦，就酱。</p>
]]></content>
  </entry>
  <entry>
    <title>异步回调的前世今生</title>
    <url>/article/2020/01/28/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>连续写了五篇jQuery源码的文章，相信很多小伙伴都看吐啦，再好吃的伙食也禁不住天天吃（何况还不一定是好的），今天我们就换个口味，来聊聊JavaScript中的异步回调。</p>
<h2 id="异步回调的黑背景"><a href="#异步回调的黑背景" class="headerlink" title="异步回调的黑背景"></a>异步回调的黑背景</h2><p>说起异步回调，很多小伙伴肯定就很熟悉啦！</p>
<p>譬如定时器：</p>
<pre><code class="js">setTimeout(function(){
    console.log(&quot;我是异步回调&quot;)
},1000);
console.log(&quot;我是个好人&quot;);
//&quot;我是个好人&quot;
//&quot;我是异步回调&quot;</code></pre>
<p>譬如绑定事件：</p>
<pre><code class="js">document.onclick = function(){
    console.log(&quot;不点是狗熊&quot;)
}
console.log(&quot;我是个好人&quot;);
//&quot;我是个好人&quot;
//&quot;不点是狗熊&quot;</code></pre>
<p>为什么会这样呢？小伙伴很生气，小伙伴大佬很不屑。</p>
<p>好吧，因为我是个好人，我还是要给不知道的某个小伙伴说一下：因为JavaScript是单线程的，而且JavaScript是自上而下执行的。</p>
<p>这时候，角落有个小伙伴眼神有点迷离，所以呢？额，你上过大马路吗？即使我是个好人，也有点不耐烦了：</p>
<ul>
<li>车行道（<strong>主线程</strong>）：同步任务（synchronous）执行的通道，只有前一个任务执行完毕，才能执行后一个任务。</li>
<li>人行道（<strong>任务队列</strong>）：异步任务（asynchronous）等候的通道（不执行）。</li>
</ul>
<p>这就是JavaScript为了解决“人车同道”难题而诞生的解决方案 - -  <strong>“事件循环”机制（Event Loop）</strong>。</p>
<p>注意，异步任务在任务队列通道只是等候，执行时还是会切换到主线程来，所以把人行道改为斑马线可能更为准确一些。</p>
<p>所以，同步任务跟异步任务并不是隔绝的，到底是同步还是异步，是可以控制的。例如Ajax操作的时候，我们可以既可以把它定义为异步，也可以定义为同步操作。两者的不同是前者不阻塞代码，而后者会阻塞而已。</p>
<h2 id="一个栗子引发的血案"><a href="#一个栗子引发的血案" class="headerlink" title="一个栗子引发的血案"></a>一个栗子引发的血案</h2><p>看个有趣的题目（请用代码实现）：</p>
<p>按照顺序输出：“开始” - -&gt; “吃饭”  - -&gt;  “睡觉”  - -&gt; “打豆豆” ，每次输出间隔2s。</p>
<p>先思考一秒钟。</p>
<h2 id="传统回调"><a href="#传统回调" class="headerlink" title="传统回调"></a>传统回调</h2><p>话音未落，已经有小伙伴抢答了：</p>
<pre><code class="js">console.log(&quot;开始&quot; + &quot; -- &quot; + new Date().getSeconds())
setTimeout(function(){
    console.log(&quot;吃饭&quot; + &quot; -- &quot; + new Date().getSeconds());
    setTimeout(function(){
        console.log(&quot;睡觉&quot; + &quot; -- &quot; + new Date().getSeconds())
        setTimeout(function(){
            console.log(&quot;打豆豆&quot; + &quot; -- &quot; + new Date().getSeconds())
        },2000)
    },2000)
},2000)</code></pre>
<p>好啦，虽然这程序成功地完成了任务，但是在写程序的过程中，该小伙伴多次漏写了大括号或者小括号，而且因为睡懒觉刚进教室的另一个小伙伴，花了大半天才看懂了他的程序。</p>
<p>为什么呢？</p>
<p>现在程序的任务只是打印一句话，如果是打印一百句不同的话呢？这个时候看这程序最大的障碍就变成了找准对应的大小括号了，如果无意中漏掉了一个大括号，想要马上补全也是一个艰巨的工程。</p>
<p>这时，答题的小伙伴有点不甘了：我可以把打印的代码抽离出来封装成一个函数啊！</p>
<p>嗯，是个不错的解决方法，不过又有一个不足，就是我们这时就要跳着看代码了，如果抽离的函数放的距离远一些，跳来跳去的过程中，我们的思路也要不断的中断切换，中断切换。。。</p>
<h2 id="优雅的-Promise"><a href="#优雅的-Promise" class="headerlink" title="优雅的 Promise"></a>优雅的 Promise</h2><p>还有没有更好的方法？我提高了声音。</p>
<p>“有”，睡懒觉迟到的小伙伴满脸兴奋，“我昨晚熬夜学到了另一种方案！”</p>
<pre><code class="js">console.log(&quot;开始&quot; + &quot; -- &quot; + new Date().getSeconds());
new Promise(function(resolve,reject){
    setTimeout(function(){
        console.log(&quot;吃饭&quot; + &quot; -- &quot; + new Date().getSeconds());
        resolve();
    },2000);
}).then(function(){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            console.log(&quot;睡觉&quot; + &quot; -- &quot; + new Date().getSeconds());
            resolve();
        },2000)
    });
}).then(function(){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            console.log(&quot;打豆豆&quot; + &quot; -- &quot; + new Date().getSeconds());
            resolve();
        },2000)
    });
})</code></pre>
<p>这代码看起来既陌生又熟悉，你看，一排排的，多整齐！</p>
<p>迟到的小伙伴有点得意，写传统回调的小伙伴满脸羡慕：“这下再也不用担心大括号的对齐的问题了呀”，“里面定时器的代码我也能写出来！！”，。。。“就是那个 <code>Promise</code> , <code>then</code> 不知道啥意思” 。。。</p>
<p>没错，<code>Promise</code> 有啥特殊呢？</p>
<p>其实吧，没啥特殊的，就像写传统回调那位小伙伴说的，操作代码那一段他也能写！！</p>
<p>而 <code>Promise</code> 的作用呢？就是一个全新的包装而已！！它把异步的代码包装起来，形成了一个包含异步任务的容器。</p>
<p>“ 那 <code>then</code> 又是啥呀？” ， 小伙伴显得有点楚楚可怜。</p>
<p>“ <code>then</code> 呀，就是 <code>Promise</code> 容器对象的一个出口呀，容器里面的代码执行之后，就接着执行 <code>then</code> 里面的方法 ”。</p>
<p>” 那 <code>then</code> 怎么知道容器里面的代码执行结束了呀？ “，小伙伴快要哭了。</p>
<p>” 哎，你别哭，不是还有 <code>resolve</code> 吗？“， ”当容器里面的 <code>resolve</code> 调用后，<code>then</code> 就开始执行了呀！ “</p>
<h4 id="Promise-容器范式"><a href="#Promise-容器范式" class="headerlink" title="Promise 容器范式"></a>Promise 容器范式</h4><p>既然都说 Promise 只是一种包装，那包装总是有标准的嘛：</p>
<pre><code class="js">// 第一式，先 new 个对象
new Promise(function(resolve,reject){//第二式，定义成功状态函数与失败失败函数
    //第三式， 执行异步代码
    setTimeout(function(){
        console.log(&quot;我是异步代码&quot;);
        //第四式， 确定是成功还是失败状态
        if(true){
            resolve(&quot;成功&quot;);
        }else{
            reject(&quot;失败&quot;);
        }
    },1000)
}).then(function(res){//第五式，根据状态执行代码
    console.log(res);
},function(err){
    console.log(err);
}).catch(function(e){//第六式，捕获报错信息
    console.log(e)
})</code></pre>
<h4 id="then-方法的返回值"><a href="#then-方法的返回值" class="headerlink" title="then 方法的返回值"></a>then 方法的返回值</h4><p>值得注意的一点是，<code>then</code> 方法的返回值是一个 Promise 对象。</p>
<pre><code class="js">var promise = new Promise(function(resolve,reject){
    resolve(&quot;成功&quot;);
});

var then = promise.then(function(res){
    console.log(res);
});
console.log(then instanceof Promise); //true
console.log(then  === promise); //false</code></pre>
<p>我们发现一个非常重要的知识点，then 方法返回一个全新的 Promise !!!</p>
<p>这有什么值得关注的呢？传统回调的小伙伴这时也疑惑的看着我。</p>
<ul>
<li>因为 <code>then</code> 总是能够返回一个全新的 Promise 对象，所以可以通过 <code>then</code> 进行永无止境的链式调用。</li>
<li>若 <code>then</code> 方法里面 <code>return</code> 一个 Promise 对象，则可以开启新一段异步任务。</li>
</ul>
<p>上面的例子就是利用了这两点，接连开启了三个异步任务。如果省略了其中的 <code>return</code> ，则后面两个异步任务变为同时开启（睡觉跟打豆豆同时打印出来），有疑问的小伙伴可以亲自验证一番。</p>
<h2 id="太平盛世-async-await"><a href="#太平盛世-async-await" class="headerlink" title="太平盛世 async/await"></a>太平盛世 async/await</h2><p>通过上面例子的对比，Promise 似乎取得了巨大的进步，代码可以按照顺序愉快的阅读了，也不用费心对齐大括号了，还能随心所欲的连续开启无数个异步任务，多么的美妙！！！</p>
<p>”有没有更更更好的方法呢？“，我也激动了起来，声音提高到了最高分贝。</p>
<p>众小伙伴陷入了沉思。。。</p>
<p>”你们在干嘛呀？“，在这已经快要到饭点的时候，小伙伴大佬走了进来，”霍，谁写的异步回调？“，”第一个是猪吗” , ”这样多麻烦呀，也不优雅！“，”现在流行这样写啦！“</p>
<pre><code class="js">console.log(&quot;开始&quot; + &quot; -- &quot; + new Date().getSeconds());
async function dadoudou(){
    await new Promise(function(resolve,reject){
        setTimeout(function(){
            console.log(&quot;吃饭&quot; + &quot; -- &quot; + new Date().getSeconds());
            resolve();
        },2000);
    });
    await new Promise(function(resolve,reject){
        setTimeout(function(){
            console.log(&quot;睡觉&quot; + &quot; -- &quot; + new Date().getSeconds());
            resolve();
        },2000)
    });
    await new Promise(function(resolve,reject){
        setTimeout(function(){
            console.log(&quot;打豆豆&quot; + &quot; -- &quot; + new Date().getSeconds());
            resolve();
        },2000)
    });
}
dadoudou();</code></pre>
<p>这是什么呀，怎么又冒出 <code>async/await</code>, 什么鬼？？竟然还真的成功执行了？？？</p>
<p>这里只解释一句，async/await 是 <code>Generator</code> 函数的语法糖。</p>
<p>至于Generator函数是什么东东，我们留待下篇再进行详细的描述，本篇只需关注它语法糖在异步回调中的特性。</p>
<p>语法糖又是啥？</p>
<p>翻译一下，让人用的开心的语法。</p>
<p>好了，既然是一种语法，我们就必须知道，这是没有道理可讲的事情了。所以，我们只需关注它为什么能让我们开心了，这必须是个好事情。</p>
<p>就像上例 Promise 一样，语法都是包装，都有范式：</p>
<pre><code class="js">//第一式：定义一个函数，前面加上async
async function fn(){
    //第二式： await(断点) + Promise实例 
    let value = await new Promise(function(resolve,reject){
        //第三式： 执行异步代码，确定成功或者失败状态
        setTimeout(function(){
            resolve(&quot;成功&quot;);
        },2000);
    });
    // 第四式： 返回异步代码的返回值
    return value;
}

// 第五式：调用async函数，返回一个 Promise 对象
fn().then(function(res){
    console.log(res); // &quot;成功&quot;
},function(err){
    console.log(err);
}).catch(function(e){//第六式，捕获报错信息
    console.log(e)
})</code></pre>
<h4 id="神奇的断点"><a href="#神奇的断点" class="headerlink" title="神奇的断点"></a>神奇的断点</h4><p>小伙伴们最疑惑的可能就是 <code>await</code> 这个新事物了，毕竟 <code>async</code> 飘在函数外面，看起来还规规矩矩的，也不影响理解，可它算是个什么东西呢？（影视剧口吻）</p>
<ul>
<li>await 命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象</li>
<li>当前一个 await 命令后面的 Promise 对象调用 resolve 状态函数后，才执行下一个 await 命令下的 Promise 异步任务；</li>
<li>await 命令下的 Promise 调用 reject 状态函数时，后面的 await 命令将不再执行，async 函数返回一个 Promise 对象</li>
</ul>
<p>让我们来看一看代码验证一下：</p>
<pre><code class="js">async function fn1() {
  let value = await new Promise(function(){});
  console.log(value);//验证第二点，上面 Promise 没有 resolve ，这一句永远不会执行。
  return value;
}
fn1().then(v =&gt; console.log(v));</code></pre>
<pre><code class="js">async function fn2() {
  let value = await 123;
  console.log(value); //验证第一点，非 Promise 对象，会被转成一个立即resolve的 Promise 对象
  return value;
}
fn2().then(v =&gt; console.log(v)); // 123</code></pre>
<pre><code class="js">async function fn3() {
  await Promise.reject(&quot;失败&quot;);
  await Promise.resolve(&quot;成功&quot;); //这一句不会执行，验证第三点
}
fn3().then(v =&gt; console.log(v),e =&gt; console.log(e)); // &quot;失败&quot;</code></pre>
<p>好啦，到这里我们应该了解 <code>await</code> 的用法了，其实它就是生成器中的 <code>yeild</code> ，但是目前我们无需理会，知道如何使用它就足够了。</p>
<h2 id="如何继发传值"><a href="#如何继发传值" class="headerlink" title="如何继发传值"></a>如何继发传值</h2><p>说到这里，我们理解了 <code>await</code> 的执行顺序，不过还忽略了一个比较重要的问题：不同段异步任务如何传值？</p>
<p>真实的开发中，不同异步任务不仅仅只有执行顺序的要求，往往也需要值的传递，这是必不可少的一环。现在是时候总结一波啦！</p>
<h4 id="传统回调的传值"><a href="#传统回调的传值" class="headerlink" title="传统回调的传值"></a>传统回调的传值</h4><p>这个是不是不要太简单呢？理解JavaScript作用域的小伙伴都能轻而易举的实现：</p>
<pre><code class="js">setTimeout(function(){
    var level = 1;
    console.log(&quot;我是第一个异步任务&quot;);
    setTimeout(function(){
        console.log(&quot;我是第二个异步任务，接收第 &quot; + level + &quot; 个任务的传值&quot;);
    },2000);
},2000);</code></pre>
<p>有的小伙伴说，我要把代码抽离出来：</p>
<pre><code class="js">setTimeout(function(){
    var level = 1;
    console.log(&quot;我是第一个异步任务&quot;);
    next(level); //传值
},2000);

function next(val){
    setTimeout(function(){
        console.log(&quot;我是第二个异步任务，接收第 &quot; + val + &quot; 个任务的传值&quot;);
    },2000);
}</code></pre>
<h4 id="Promise的传值"><a href="#Promise的传值" class="headerlink" title="Promise的传值"></a>Promise的传值</h4><p>看过前面代码的小伙伴也发现，Promise 传值好像更简单啊！</p>
<pre><code class="js">new Promise(function(resolve,reject){
    setTimeout(() =&gt; {
        resolve(&quot;我来自第一个异步任务&quot;)
    },2000);
}).then(res =&gt; {
    console.log(&quot;在第二个任务中打印：  &quot; + res);
    return new Promise(function(resolve,reject){
        setTimeout(() =&gt; {
            resolve(&quot;我来自第二个异步任务&quot;)
        },2000);
    })
}).then(res =&gt; { console.log(&quot;在第三个任务中打印：  &quot; + res)});</code></pre>
<p>没错，确实更简单了，只需要在 <code>resolve</code> 或 <code>reject</code> 状态函数调用时传参就可以了。</p>
<h4 id="async-await-的传值"><a href="#async-await-的传值" class="headerlink" title="async/await 的传值"></a>async/await 的传值</h4><p>传统回调挺简单，Promise 更简单，那 async/await 岂不是更更更简单啦？？？</p>
<p>额，好吧，确实是这样！</p>
<pre><code class="js">async function fn(){
    let value1 = await new Promise((resolve,reject) =&gt; {
        setTimeout(() =&gt; {
            resolve(&quot;我来自第一个异步任务&quot;);
        },2000)
    });
    let value2 = await new Promise((resolve,reject) =&gt; {
        console.log(&quot;在第二个任务中打印：  &quot; + value1)
        setTimeout(() =&gt; {
            resolve(&quot;我来自第二个异步任务&quot;);
        },2000)
    });
    let value3 = await new Promise((resolve,reject) =&gt; {
        console.log(&quot;在第三个任务中打印：  &quot; + value2)
        setTimeout(() =&gt; {
            resolve(&quot;我来自第三个异步任务&quot;);
        },2000)
    });
    return value3;
}
fn().then(res =&gt; {
    console.log(&quot;在then中打印：  &quot; + res)
});</code></pre>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好啦，认真从头到尾看到这里的小伙伴，应该再也不需要担心实践中异步回调的问题了（有问题向我反馈如何改进）。</p>
<p>不过，依然有一些小伙伴雄心勃勃，觉得这些太简单啦，“能不能搞点大事情？？！”</p>
<p>说实话，如果仅仅是实际开发，知道这些就足够了。只需要熟悉上面的代码范式，完成各种异步回调操作完全没有问题了。</p>
<p>若是想进一步了解 <code>async/await</code> 呢，也是无可厚非的，毕竟目前它看起来完全是个黑匣子。所以呢，后面应该还会写一篇 <code>async/await</code> 内幕的文章，敬请期待吧！就酱。</p>
]]></content>
  </entry>
  <entry>
    <title>大话西游之原型与继承-下</title>
    <url>/article/2020/01/28/%E5%A4%A7%E8%AF%9D%E8%A5%BF%E6%B8%B8%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF-%E4%B8%8B.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开篇之前，想说一点东西。我写这个博客，第一目的是总结所学的知识，以备日后温习；第二才是分享给各位小伙伴，希望给遇到同样疑惑的朋友一些微薄的帮助。古有言，文无第一，武无第二。博客中的言论，只是自家之言；其中观点，更是知识所限，错误疏漏在所难免。所以，日后遇到错误不当的地方，还请各位即时指正，不甚感激。</p>
<p>废话到此为止，接上篇。</p>
<p>有的小伙伴又担心了，接上篇？我上篇还没看呢！</p>
<p>唉，没关系的，不看也无所谓，实在不行再去看看上篇也是可以的。</p>
<p>这一篇的话，主要是继承的应用，内容主要是从红宝书中汇总而来，并无新意。想要理解原型继承的小伙伴，看看<a href="http://codedoges.com/article/1536662941125" target="_blank" rel="noopener">上篇</a>更佳。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><pre><code class="js">function Father(){
    this.fatherName = &quot;father&quot;;
    this.colors = [&#39;red&#39;,&#39;green&#39;];
}
Father.prototype.sayName = function(){
    console.log(this.fatherName);
    console.log(this.childName);
}
function Child(){
    this.childName = &quot;child&quot;;
}
Child.prototype = new Father();
var child = new Child();
child.sayName();// &#39;father&#39; &#39;child&#39;
console.log(child instanceof Child); //true
console.log(child instanceof Father); //true
var child1 = new Child();
child1.colors.push(&#39;yellow&#39;);
var child2 = new Child();
//父实例的属性被共享
console.log(child2.colors);//[&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;]</code></pre>
<p>这里有一个值得注意的问题就是，<code>instanceof</code> 运算符用来检测 constructor.prototype 是否存在于参数 child 的原型链上，详情请看<a href="http://codedoges.com/article/1536738232344" target="_blank" rel="noopener">你不知道的instanceof</a>。</p>
<p>缺点：</p>
<ul>
<li>子实例继承继承父实例的实例属性方法，也继承了父实例的原型。</li>
<li>生成子实例的时候，原型已经确定，无法进行传参。</li>
</ul>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<pre><code class="js">function Father(){
    this.fatherName = &quot;father&quot;;
    this.colors = [&#39;red&#39;,&#39;green&#39;];
}
Father.prototype.sayName = function(){
    console.log(this.fatherName);
    console.log(this.childName);
}
function Child(){
    //子实例接受父实例的属性
    Father.call(this);
    this.childName = &quot;child&quot;;
}
//同样继承了父实例的属性跟原型的属性方法，只不过实例的属性被子实例创建时接收的属性所覆盖
Child.prototype = new Father();
var child = new Child();
child.sayName();// &#39;father&#39; &#39;child&#39;
var child1 = new Child();
child1.colors.push(&#39;yellow&#39;);
//每个实例用一份独立的属性
console.log(child1.colors);//[&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;]
var child2 = new Child();
console.log(child2.colors);//[&quot;red&quot;, &quot;green&quot;]</code></pre>
<p>这是我们使用最多的模式，不过，它依然有缺点：</p>
<ul>
<li>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</li>
</ul>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>有的时候，我们只希望接收父构造函数原型上的方法与属性，则可以使用原型式继承：</p>
<pre><code class="js">function Father(){
    this.fatherName = &quot;father&quot;;
    this.colors = [&#39;red&#39;,&#39;green&#39;];
}
Father.prototype.sayName = function(){
    console.log(this.fatherName);
    console.log(this.childName);
}
function Child(){
    this.childName = &quot;child&quot;;
}
Child.prototype = Object.create(Father.prototype);
var child = new Child();
//只继承原型属性与方法，父实例的属性则不继承
console.log(child.sayName()); // &#39;undefined&#39; &#39;child&#39;
Father.prototype.sayName = null;
//证明create方法返回的只是父构造函数原型的引用
console.log(child.sayName); // &#39;null&#39;</code></pre>
<p>其实原型搞懂了，继承是水到渠成的事情。这里可能我们说一下 <code>Object.create</code> 方法。</p>
<pre><code class="js">var obj = {name:&#39;张三&#39;,age:20};
var copy = Object.create(obj);
console.log(obj === copy); //false
console.log(obj === copy.__proto__);//true</code></pre>
<p>从上可以看出，create方法的实质就是创建一个空实例，并把该空实例的原型指向传进去的 <code>obj</code>；所以obj实质上没有任何变化，当它改变时，依然会影响到实例。</p>
<p>下面放出create方法的实现：</p>
<pre><code class="js">function create(obj){
    //定义一个构造函数
    function Fn(){}
    //原型指向传入对象
    Fn.prototype = obj;
    //创建一个空实例
    var o = new Fn();
    return o;
}</code></pre>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。而且，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<p>寄生组合式继承是组合式继承的改良：</p>
<pre><code class="js">function Father(){
    this.fatherName = &quot;father&quot;;
    this.colors = [&#39;red&#39;,&#39;green&#39;];
}
Father.prototype.sayName = function(){
    console.log(this.fatherName);
    console.log(this.childName);
}
function Child(){
    //子实例接受父实例的属性，相比组合继承，只需在这里调用父构造函数
    Father.call(this);
    this.childName = &quot;child&quot;;
}
//此时不需要调用父构造函数了
Child.prototype = Object.create(Father.prototype);
var child = new Child();
child.sayName();// &#39;father&#39; &#39;child&#39;
var child1 = new Child();
child1.colors.push(&#39;yellow&#39;);
//每个实例用一份独立的属性
console.log(child1.colors);//[&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;]
var child2 = new Child();
console.log(child2.colors);//[&quot;red&quot;, &quot;green&quot;]</code></pre>
<p>结论：寄生组合式继承是引用类型最理想的继承范式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实红宝石中还有所谓的借用构造函数跟寄生式继承两种方式，但是个人认为意义不大。而且，认真理解的小伙伴也能体会到：</p>
<ul>
<li>所谓的继承，就是在子构造函数的原型链上跟子构造函数的内部做文章而已，原型链上做文章是为了继承父构造函数的原型；</li>
<li>子构造函数内部调用父构造函数则是为了继承父构造函数的实例属性。</li>
</ul>
<p>暂时就酱了，如遇到什么问题，欢迎讨论。</p>
]]></content>
  </entry>
  <entry>
    <title>大话西游之原型与继承-上</title>
    <url>/article/2020/01/28/%E5%A4%A7%E8%AF%9D%E8%A5%BF%E6%B8%B8%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF-%E4%B8%8A.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天心血来潮，随手翻了翻红宝书，突然发现其中有个面向对象的章节（时隔久远，目录记不清了），于是一鼓作气，花了几个小时细细重读一遍，深感收获匪浅，之前一直无法理解的地方也觉得通透了很多。深怕时间一长，复蹈前辙，故有此篇。</p>
<h2 id="如何继承？"><a href="#如何继承？" class="headerlink" title="如何继承？"></a>如何继承？</h2><p>这么弱智的问题，提问的我也觉得耳根有些发烫。不过很多时候，我们对一种事物的认识，就是在这一个个这样看似简单的问题中逐渐深化的。</p>
<p>而且相信你也有这样的感觉，越是简单的问题，越是感觉难以回答。</p>
<p>好了，我之所以提出这个问题，只是为了提提神，毕竟疑问句更能引起大伙兴趣而已（打人别打脸！）</p>
<p>我们只需记住一点，ECMAScript 的继承主要是依靠原型链来实现的（我也不知道为啥要加上主要两字，难道还有别的方式不成？）。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>啥是原型链？（老毛病又发了）</p>
<p>在JavaScript中，万物皆对象。有没有人进一步想过，既然皆对象，有没有啥共同点？</p>
<p>猫狗鸟树叶花有没有共同点？当然有啦，小学生都知道它们都是原子组成了（现在小学生很厉害了）</p>
<p>作为努力超越上帝的人类创造的JavaScript，如果它的子民互相没有共同点，你敢信吗？</p>
<pre><code class="js">(&quot;hello&quot;). __proto__ ; //String {&quot;&quot;, length: 0, constructor: ƒ,  …}
(1). __proto__ ; //Number {0, constructor: ƒ, toExponential: ƒ,  …}
[]. __proto__ ; // [constructor: ƒ, concat: ƒ, find: ƒ, …]
(Math). __proto__ ; //{constructor: ƒ, __defineGetter__: ƒ, …}</code></pre>
<p>显而易见，无论引用类型还是基本类型（先转内置对象），都能访问到一个 <code>__proto__</code> 属性。</p>
<p>这是何方神圣呢？接下来的一段描述非常重要：</p>
<pre><code class="js">
万物皆对象 - - &gt; 对象皆有 `__proto__` - - &gt; `__proto__` 指向原型 - - &gt; 原型也是对象 - -&gt; Object原型的原型是null 。
</code></pre>
<p>请各位小伙伴把这段描述多看几遍，细细体会（大佬略过）。</p>
<p>这段描述最重要的一个作用，就是教会我们要用宏观的视角来看JavaScript的原型链。</p>
<p>在JavaScript中，每一个对象的背后，都有一个 <code>__proto__</code> 的属性牵引，互相关联，层层递进，直到原型链的终点 - - <code>null</code>。</p>
<p>对终点有疑问的小伙伴可以看下面代码：</p>
<pre><code class="js">Object.prototype.__proto__ === null; //true</code></pre>
<p><code>Object.prototype</code> 是Object构造函数的原型，原型也是对象，对象就有 <code>__proto__</code> , 结果指向了 <code>null</code> ！</p>
<p>没错，原型链其实就是一张树状的网，它的顶点就是null。</p>
<h2 id="原型（prototype）与-ptoto-与-constructor"><a href="#原型（prototype）与-ptoto-与-constructor" class="headerlink" title="原型（prototype）与 __ptoto__ 与 constructor"></a>原型（prototype）与 <code>__ptoto__</code> 与 constructor</h2><p>学习原型的小伙伴，总会被这三个东西搞的七荤八素，即使暂时搞懂了，过几天又忘得一干二净了（本人深受其害）。</p>
<h5 id="虚心问道"><a href="#虚心问道" class="headerlink" title="虚心问道"></a>虚心问道</h5><p>这次我们索性就不管那些教科书式的定义了，先来一番头脑风暴吧！</p>
<p>“你觉得什么是js的核心？” 问题有点笼统，换个说法，</p>
<p>“在目前阶段，你觉得如果能搞懂什么知识点，你就敢说掌握了js？”</p>
<p>好吧，问题还是不够清晰，因为答案可能太多，看终极问题：</p>
<p>“道生一，一生二，二生三，三生万物。什么是JavaScript中的道？”</p>
<p>小伙伴情绪有点高涨，“对象？”，“函数？”，“null?”，”原型？”。。。。</p>
<p>好吧，虽然答案很多，但是当我反问一句为什么时，空气突然安静了。</p>
<h5 id="大话胡扯"><a href="#大话胡扯" class="headerlink" title="大话胡扯"></a>大话胡扯</h5><p>我个人理解，构造函数。</p>
<p>记住，不是函数，是构造函数。（虽然每个函数都可以变成构造函数，详见<a href="http://codedoges.com/article/1535898754108" target="_blank" rel="noopener">疯狂的链式调用</a>）</p>
<p>我们看看JavaScript给了我们什么构造函数：</p>
<pre><code class="js">String;
Boolean;
Number;
Object;
Array;
RegExp;
Date;
Map;
Set;
Symbol;</code></pre>
<p>没错，内置的构造函数就这些了。</p>
<p>有的小伙伴就急了，这么多，让我怎么学啊！！</p>
<p>别急，听我一句劝，一个都不用学。</p>
<p>“真的假的？吹牛逼！”</p>
<p>“你唯一要做的，是搞懂什么是构造函数！”（重点重点重点！！！）</p>
<h5 id="什么是构造函数"><a href="#什么是构造函数" class="headerlink" title="什么是构造函数"></a>什么是构造函数</h5><p>这是十万个为什么专场么？（保证是最后一个为什么了！）</p>
<p>构造函数，顾名思义，就是专门用来构造的函数。构造什么呢？一切。（重点重点重点！！！）</p>
<ul>
<li>碰到数字，找Number构造函数；</li>
<li>碰到对象，找Object构造函数；</li>
<li>碰到数组，找Array构造函数；</li>
<li>碰到正则，找RegExp构造函数；。。。。</li>
</ul>
<p>为什么要找构造函数？（好吧，又一个为什么）</p>
<p>因为每个构造函数上面都有一个原型 <code>prototype</code> 。它里面包含了<strong>被构造者</strong>所有能用的方法跟属性。</p>
<p>啥是被构造者（一般也叫实例）？</p>
<p>好啦，请回看一开始那句话：<strong>构造函数，构造一切！</strong></p>
<p>所以，你js中的每一个对象，字符串，数组，。。。都是被构造者。</p>
<p>那有些小伙伴疑问了，那构造函数也是被构造者？</p>
<p>没错，只不过是被原型链上的更高一层构造而已。</p>
<pre><code class="js">[] instanceof Array;//true
Array instanceof Function; //true
Function instanceof Object;//true</code></pre>
<p>显而易见，<code>Object</code> 是终极的构造函数，它构造出了内置的构造函数，再由内置构造函数，构造出我们js代码中的所有对象，正所谓构造一切！</p>
<h5 id="连接一切"><a href="#连接一切" class="headerlink" title="连接一切"></a>连接一切</h5><p>到这里，大伙已经了解了构造函数构造一切的磅礴气势，现在还剩下一个问题，构造完了之后，难道就撒手不管了么？</p>
<p>当然不是，构造函数肩负道的重任，提起裤子不认人的事情是不可能的！</p>
<p>构造函数在构造一切的同时，也默默连接了一切。</p>
<p>如何连接？其实上面已经讲过了，<code>__proto__</code> 与 <code>prototype</code> 肩负此重任。</p>
<p>请记住下面公式：</p>
<pre><code class="js">(&#39;被构造者&#39;).__proto__  ===  (&#39;构造者&#39;).prototype</code></pre>
<p>验证：</p>
<pre><code class="js">(&#39;hello&#39;).__proto__ === String.prototype ;//true
String.__proto__ === Function.prototype; //true
//高能！！！
Function.__proto__ === Function.prototype;//true
Function.prototype.__proto__ === Object.prototype;//true</code></pre>
<p>上面有两个极其重要的知识点！！！</p>
<ul>
<li><code>Function</code> 构造函数是由 <code>Function</code> 构造的！！！</li>
<li><code>Function.prototype</code> 是对象，所以自然而然是由 <code>Object</code> 构造的。</li>
</ul>
<h2 id="如何找原型"><a href="#如何找原型" class="headerlink" title="如何找原型"></a>如何找原型</h2><p>根据小伙伴们的反馈，之前的阐述确实还有所不足，特补加一段。</p>
<h5 id="费解之处"><a href="#费解之处" class="headerlink" title="费解之处"></a>费解之处</h5><p>前面说过, Object原型的原型是null,小伙伴们就蒙蔽了，你不是说原型是对象么，如果按照你上面的公式，对象的原型应该是指向对象的构造函数的原型呀？如下：</p>
<pre><code class="js">Object.prototype.__proto__ === null; //true
//Object.prototype是对象，怎么不是指向构造器Object.prototype ?
Object.prototype.__proto__ === Object.prototype; //false 蒙蔽！</code></pre>
<h5 id="被谁构造？"><a href="#被谁构造？" class="headerlink" title="被谁构造？"></a>被谁构造？</h5><p>寻找原型的法则，其实还是看上面的公式：</p>
<pre><code class="js">(&#39;被构造者&#39;).__proto__  ===  (&#39;构造者&#39;).prototype</code></pre>
<p>这里很多人会走入一个误区，就是以为<code>Object</code>既然是最大的boss，正所谓普天之下，莫非王土；率土之滨，莫非王臣，就把上面的这个公式自作主张改成了下面的：</p>
<pre><code class="js">(&#39;被构造者&#39;).__proto__  ===  (Object).prototype;//Object 构造一切！
//结果被打脸
[].__proto__ === (Object).prototype; //false
(&#39;hello&#39;).__proto__ === (Object).prototype; //false</code></pre>
<p>好吧，追根溯源，锅还是我背，毕竟还是因为我没有讲清楚，其实上面的公式，实质是这样的：</p>
<pre><code class="js">(&#39;被构造者&#39;).__proto__  ===  (&#39;直接构造者&#39;).prototype</code></pre>
<p>没错，就是只需加上两个字。小伙伴们气歪了，我们的大boss呢，说好的构造一切呢！</p>
<p>说句实在话，你见过事必躬亲的大boss么？你见过亲自种粮食的帝王么？没看到马云爸爸都准备退休了么？真正的大boss，都是托管的好吧！</p>
<pre><code class="js">function A(){};
var a = new A();
//a是由A构造
a.__proto__ === A.prototype; //true
//声明A时，内置的Function构造函数默默帮你构造了
A.__proto__ === Function.prototype;//true
//Function这哥们是自己构造了自己，没办法，谁让自己的工作就是来生成函数呢，难道自己是面包师，就不能吃面包了？
Function.__proto__ === Function.prototype; //true</code></pre>
<p>小伙伴还是有点蒙，那怎么才能接触到大boss <code>Object</code> 呢？</p>
<p>让我们重新回味一个词，<strong>原型链</strong>。</p>
<p>我们都知道了，构造函数，构造一切。但是很不幸，这句话其实就是约等于， “劳动者最光荣”。真正的掌权者，还是原型链啊。</p>
<pre><code class="js">function A(){};
//A.prototype是Object构造的对象，直达权力最高层
A.prototype.__proto__ === Object.prototype;//true
//{}是Object构造的对象，直达权力最高层
({}).__proto__ === Object.prototype;//true
//已经到最高层，空虚寂寞冷
Object.prototype.__proto__ === null;//true</code></pre>
<p>所以说，大boss即使是托管，但是还是抓主线，抓战略方向的。</p>
<h5 id="延伸权力机构"><a href="#延伸权力机构" class="headerlink" title="延伸权力机构"></a>延伸权力机构</h5><p>从上面可以看出，目前权力机构显然不够庞大，力量有所不足。这时候，直通高层的A就开始发展自己的势力了。</p>
<pre><code class="js">function A(){}
//直通高层
console.log(A.prototype.__proto__ === Object.prototype);//true
//原型是权力所在
A.prototype.sayName = function(){
    console.log(&#39;我是大佬A&#39;)
}
//构造一个，才能继承权力
var a = new A();
function B(){}
//无依无靠的B（其实也是直通高层，只是目光短浅，只想找A做靠山）
console.log(B.prototype.__proto__ === Object.prototype);//true
//找到靠山了，a的权力就是B的权力了
B.prototype = a;
//投靠之后不能直通高层了
console.log(B.prototype.__proto__ === A.prototype); //true
//构造一个，继承权力
var b = new B();
//可以狐假虎威了
b.sayName(); //我是大佬A</code></pre>
<h5 id="当代吕奉先"><a href="#当代吕奉先" class="headerlink" title="当代吕奉先"></a>当代吕奉先</h5><p>上面栗子说了，B本来有直通高层的机会，却选择了投靠直通高层的A；那是不是意味着B从此就忠心耿耿了呢？</p>
<p>当然不是，B连高层都可以舍弃，更何况小小的A了。</p>
<pre><code class="js">function A(){}
A.prototype.sayName = function(){
    console.log(&#39;我是大佬A&#39;)
}
var a = new A();
function C(){}
C.prototype.sayName = function(){
    console.log(&#39;我是大佬C&#39;)
}
var c = new C();
function B(){}

//投靠A
B.prototype = a;
var b1 = new B();
//可以狐假虎威了
b1.sayName(); //我是大佬A

//投靠C
B.prototype = c;
var b2 = new B();
//可以狐假虎威了
b2.sayName(); //我是大佬C</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说来可能大伙不信，在写本篇开始，解释原型本不在计划只能，是想写继承的几种方式的，结果越写越觉得很有必要，一不留神就写了这么多了，所以这篇暂定为上篇吧，下篇写继承。</p>
]]></content>
  </entry>
  <entry>
    <title>命令行根据端口关闭进程</title>
    <url>/article/2020/01/28/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A0%B9%E6%8D%AE%E7%AB%AF%E5%8F%A3%E5%85%B3%E9%97%AD%E8%BF%9B%E7%A8%8B.html</url>
    <content><![CDATA[<p>##根据占用端口关闭进程的步骤：</p>
<ol>
<li>netstat -ano | findstr 8088 //列出进程极其占用的端口<pre><code class="cmd">$ netstat -aon|findstr 8088
TCP    0.0.0.0:8088           0.0.0.0:0              LISTENING       1916
TCP    [::]:8088              [::]:0                 LISTENING       1916
TCP    [::1]:8088             [::1]:53450            ESTABLISHED     1916
TCP    [::1]:53450            [::1]:8088             ESTABLISHED     8304</code></pre>
</li>
<li>tasklist|findstr 1916 //按回车显示占用8080端口对应的程序的PID号；<pre><code class="cmd">$ tasklist|findstr 1916
node.exe        1916 Console       1    119,056 K</code></pre>
</li>
<li>taskkill -pid 1916 -f //关闭进程<pre><code class="cmd">$ taskkill -pid 1916 -f
▒ɹ▒: ▒▒▒▒ֹ PID Ϊ 1916 ▒Ľ▒▒̡▒</code></pre>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>前端面试题汇总-转载</title>
    <url>/article/2020/01/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB-%E8%BD%AC%E8%BD%BD.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a name='preface'>前言</a></h2><p><a href="https://markyun.github.io/2015/Front-end-Developer-Questions/" target="_blank" rel="noopener" title="Questions">只看问题点这里 </a></p>
<p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="noopener" title="Questions-and-Answers">看全部问题和答案点这里</a></p>
<p>本文由我收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！</p>
<p>前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。</p>
<p>最近也收到许多微博私信的鼓励和更正题目信息，后面会经常更新题目和答案到<a href="http://markyun.github.io/" target="_blank" rel="noopener">github博客</a>。希望前端er达到既能使用也会表达，对理论知识有自己的理解。可根据下面的知识点一个一个去进阶学习，形成自己的职业技能链。</p>
<p><strong>面试有几点需注意：(来源<a href="http://weibo.com/wintercn" target="_blank" rel="noopener" title="微博：寒冬winter">寒冬winter</a> 老师，github:@wintercn)</strong></p>
<ol>
<li><p>面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。</p>
</li>
<li><p>题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。</p>
</li>
<li><p>细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。</p>
</li>
<li><p>回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲( •̣̣̣̣̣̥́௰•̣̣̣̣̣̥̀ )）</p>
</li>
<li><p>资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。</p>
</li>
</ol>
<p><strong>前端开发所需掌握知识点概要：</strong></p>
<pre><code>HTML&amp;CSS：
    对Web标准的理解（结构、表现、行为）、浏览器内核、渲染原理、依赖管理、兼容性、CSS语法、层次关系，常用属性、布局、选择器、权重、盒模型、
    Hack、CSS预处理器、CSS3、Flexbox、CSS Modules、Document flow、BFC、HTML5（离线 &amp; 存储、Histoy,多媒体、WebGL\SVG\Canvas）；        
JavaScript：
    数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、
    内存泄漏、跨域、异步请求、模板引擎、模块化、Flux、同构、算法、ECMAScript6、Nodejs、HTTP、

其他：
    主流MVVM框架(React\Vue\Angular)、Hybrid App\React Native\Weex、TypeScript、RESTFul、WEB安全、前端工程化、依赖管理、性能优化、
    重构、团队协作、可维护、易用性、SEO、UED、前端技术选型、快速学习能力等；</code></pre><p>作为一名前端工程师，<strong>无论工作年头长短都应该掌握的知识点</strong>：</p>
<p>此条由 王子墨 发表在 <a href="http://lab.yuanwai.wang/" target="_blank" rel="noopener">攻城师的实验室</a></p>
<pre><code>    1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。

    2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。

    3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。

    4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。

    5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。

    6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型

    7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们

    8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。

    9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。

    10、JSON —— 作用、用途、设计结构。</code></pre><p><strong>备注：</strong></p>
<pre><code>根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。

资料答案不够正确和全面，欢迎欢迎Star和提交issues。

格式不断修改更新中。

更新记录：
2018-01-14： 公司在招聘前端，使用react技术栈；借此机会更新一波前端框架相关的题目；
2016-10-20： 更新一些已被发现的问题。
2016-03-25： 新增ECMAScript6 相关问题</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><a name='html'>HTML</a></h2><ul>
<li><p>Doctype作用？标准模式与兼容模式各有什么区别?</p>
<pre><code>  （1）、&lt;!DOCTYPE&gt;声明位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。

  （2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</code></pre></li>
<li><p>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>？</p>
<pre><code>   HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；

   而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</code></pre></li>
<li><p>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</p>
<pre><code>  首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。

  （1）行内元素有：a b span img input select strong（强调的语气）
  （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p

  （3）常见的空元素：
      &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;
      鲜为人知的是：
      &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;

  不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异
  参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements</code></pre></li>
</ul>
<ul>
<li>页面导入样式时，使用link和@import有什么区别？</li>
</ul>
<pre><code>    （1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;

    （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;

    （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;

     (4)link支持使用js控制DOM去改变样式，而@import不支持;</code></pre><ul>
<li><p>介绍一下你对浏览器内核的理解？</p>
<pre><code>  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

  JS引擎则：解析和执行javascript来实现网页的动态效果。

  最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</code></pre></li>
<li><p>常见的浏览器内核有哪些？</p>
<pre><code>  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]

详细文章：[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html)</code></pre></li>
</ul>
<ul>
<li>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</li>
</ul>
<pre><code>    * HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
          绘画 canvas;
          用于媒介回放的 video 和 audio 元素;
          本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
          sessionStorage 的数据在浏览器关闭后自动删除;
          语意化更好的内容元素，比如 article、footer、header、nav、section;
          表单控件，calendar、date、time、email、url、search;
          新的技术webworker, websocket, Geolocation;

      移除的元素：
          纯表现的元素：basefont，big，center，font, s，strike，tt，u;
          对可用性产生负面影响的元素：frame，frameset，noframes；

    * 支持HTML5新标签：
         IE8/IE7/IE6支持通过document.createElement方法产生的标签，
           可以利用这一特性让这些浏览器支持HTML5新标签，
           浏览器支持新标签后，还需要添加标签默认的样式。

         当然也可以直接使用成熟的框架、比如html5shim;
         &lt;!--[if lt IE 9]&gt;
            &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;
         &lt;![endif]--&gt;

    * 如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</code></pre><ul>
<li><p>简述一下你对HTML语义化的理解？</p>
<pre><code>  用正确的标签做正确的事情。
  html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
  即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
  搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
  使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</code></pre></li>
</ul>
<ul>
<li><p>HTML5的离线储存怎么使用，工作原理能不能解释一下？</p>
<pre><code>  在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</code></pre></li>
</ul>
<pre><code>    如何使用：
    1、页面头部像下面一样加入一个manifest的属性；
    2、在cache.manifest文件的编写离线存储的资源；
        CACHE MANIFEST
        #v0.11
        CACHE:
        js/app.js
        css/style.css
        NETWORK:
        resourse/logo.png
        FALLBACK:
        / /offline.html
    3、在离线状态时，操作window.applicationCache进行需求实现。

详细的使用请参考：

[HTML5 离线缓存-manifest简介](http://yanhaijing.com/html/2014/12/28/html5-manifest/)

[有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)</code></pre><ul>
<li><p>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</p>
<pre><code>  在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
  离线的情况下，浏览器就直接使用离线存储的资源。</code></pre><p>  详细请参考：<a href="http://segmentfault.com/a/1190000000732617" target="_blank" rel="noopener">有趣的HTML5：离线存储</a></p>
</li>
<li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p>
<pre><code>  cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

  存储大小：
      cookie数据大小不能超过4k。
      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

  有期时间：
      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
      sessionStorage  数据在当前浏览器窗口关闭后自动删除。
      cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</code></pre></li>
<li><p>iframe有那些缺点？</p>
<pre><code>  *iframe会阻塞主页面的Onload事件；
  *搜索引擎的检索程序无法解读这种页面，不利于SEO;

  *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

  使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
  动态给iframe添加src属性值，这样可以绕开以上两个问题。</code></pre></li>
<li><p>Label的作用是什么？是怎么用的？</p>
<pre><code>  label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。

  &lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;
  &lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;

  &lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</code></pre></li>
<li><p>HTML5的form如何关闭自动完成功能？</p>
<pre><code>  给不想要提示的 form 或某个 input 设置为 autocomplete=off。</code></pre></li>
</ul>
<ul>
<li><p>如何实现浏览器内多个标签页之间的通信? (阿里)</p>
<pre><code>  WebSocket、SharedWorker；
  也可以调用localstorge、cookies等本地存储方式；

  localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，
  我们通过监听事件，控制它的值来进行页面信息通信；
  注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</code></pre></li>
<li><p>webSocket如何兼容低浏览器？(阿里)</p>
<pre><code>  Adobe Flash Socket 、
  ActiveX HTMLFile (IE) 、
  基于 multipart 编码发送 XHR 、
  基于长轮询的 XHR</code></pre></li>
<li><p>页面可见性（Page Visibility API） 可以有哪些用途？</p>
<pre><code>  通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;
  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</code></pre></li>
</ul>
<ul>
<li><p>如何在页面上实现一个圆形的可点击区域？</p>
<pre><code>  1、map+area或者svg
  2、border-radius
  3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</code></pre></li>
<li><p>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</p>
<pre><code>  &lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></pre></li>
</ul>
<ul>
<li><p>网页验证码是干嘛的，是为了解决什么安全问题。</p>
<pre><code>  区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；
  有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</code></pre></li>
<li><p>title与h1的区别、b与strong的区别、i与em的区别？</p>
<pre><code>  title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；

  strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。

  i内容展示为斜体，em表示强调的文本；

  Physical Style Elements -- 自然样式标签
  b, i, u, s, pre
  Semantic Style Elements -- 语义样式标签
  strong, em, ins, del, code
  应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</code></pre></li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><a name='css'>CSS</a></h2><ul>
<li><p>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</p>
<pre><code>  （1）有两种， IE 盒子模型、W3C 盒子模型；
  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；
  （3）区  别： IE的content部分把 border 和 padding计算了进去;</code></pre></li>
</ul>
<ul>
<li><p>CSS选择符有哪些？哪些属性可以继承？</p>
<pre><code>  *   1.id选择器（ # myid）
      2.类选择器（.myclassname）
      3.标签选择器（div, h1, p）
      4.相邻选择器（h1 + p）
      5.子选择器（ul &gt; li）
      6.后代选择器（li a）
      7.通配符选择器（ * ）
      8.属性选择器（a[rel = &quot;external&quot;]）
      9.伪类选择器（a:hover, li:nth-child）

  *   可继承的样式： font-size font-family color, UL LI DL DD DT;

  *   不可继承的样式：border padding margin width height ;</code></pre></li>
</ul>
<ul>
<li><p>CSS优先级算法如何计算？</p>
<pre><code>  *   优先级就近原则，同权重情况下样式定义最近者为准;
  *   载入样式以最后载入的定位为准;

  优先级为:
      同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。
      !important &gt;  id &gt; class &gt; tag
      important 比 内联优先级高</code></pre></li>
<li><p>CSS3新增伪类有那些？</p>
<pre><code>      举例：
      p:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
      p:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
      p:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
      p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
      p:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。

      ::after            在元素之前添加内容,也可以用来做清除浮动。
      ::before            在元素之后添加内容
       :enabled          
      :disabled         控制表单控件的禁用状态。
      :checked        单选框或复选框被选中。</code></pre></li>
<li><p>如何居中div？</p>
</li>
</ul>
<pre><code>*  水平居中：给div设置一个宽度，然后添加margin:0 auto属性

        div{
            width:200px;
            margin:0 auto;
         }

*  让绝对定位的div居中

        div {
            position: absolute;
            width: 300px;
            height: 300px;
            margin: auto;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-color: pink;    /* 方便看效果 */
        }

*  水平垂直居中一

        确定容器的宽高 宽500 高 300 的层
        设置层的外边距

        div {
            position: relative;        /* 相对定位或绝对定位均可 */
            width:500px;
            height:300px;
            top: 50%;
            left: 50%;
            margin: -150px 0 0 -250px;         /* 外边距为自身宽高的一半 */
            background-color: pink;         /* 方便看效果 */

         }

*  水平垂直居中二

        未知容器的宽高，利用 `transform` 属性

        div {
            position: absolute;        /* 相对定位或绝对定位均可 */
            width:500px;
            height:300px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: pink;         /* 方便看效果 */

        }

*  水平垂直居中三

        利用 flex 布局
        实际使用时应考虑兼容性

        .container {
            display: flex;
            align-items: center;         /* 垂直居中 */
            justify-content: center;    /* 水平居中 */

        }
        .container div {
            width: 100px;
            height: 100px;
            background-color: pink;        /* 方便看效果 */
        }  </code></pre><ul>
<li><p>display有哪些值？说明他们的作用。</p>
<pre><code>    block           块类型。默认宽度为父元素宽度，可设置宽高，换行显示。
    none            元素不显示，并从文档流中移除。
    inline          行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。
    inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。
    list-item       象块类型元素一样显示，并添加样式列表标记。
    table           此元素会作为块级表格来显示。
    inherit         规定应该从父元素继承 display 属性的值。</code></pre></li>
</ul>
<ul>
<li><p>position的值relative和absolute定位原点是？</p>
<pre><code>    absolute
      生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。
    fixed （老IE不支持）
      生成绝对定位的元素，相对于浏览器窗口进行定位。
    relative
      生成相对定位的元素，相对于其正常位置进行定位。
    static
      默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
    inherit
      规定从父元素继承 position 属性的值。</code></pre></li>
<li><p>CSS3有哪些新特性？</p>
<pre><code>    新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）
      圆角            （border-radius:8px）
    多列布局        （multi-column layout）
    阴影和反射    （Shadow\Reflect）
    文字特效        （text-shadow、）
    文字渲染        （Text-decoration）
    线性渐变        （gradient）
    旋转             （transform）
    缩放,定位,倾斜,动画,多背景
    例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></pre></li>
<li><p>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p>
<pre><code>   一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。
   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。
   采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。
   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;。
   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。
   在布局上有了比以前更加灵活的空间。

   具体：http://www.w3cplus.com/css3/flexbox-basics.html</code></pre></li>
<li><p>用纯CSS创建一个三角形的原理是什么？</p>
<pre><code>  把上、左、右三条边隐藏掉（颜色设为 transparent）
  #demo {
    width: 0;
    height: 0;
    border-width: 20px;
    border-style: solid;
    border-color: transparent transparent red transparent;
  }</code></pre></li>
<li><p>一个满屏 品 字布局 如何设计?</p>
<pre><code>  简单的方式：
      上面的div宽100%，
      下面的两个div分别宽50%，
      然后用float或者inline使其不换行即可</code></pre></li>
<li><p>css多列等高如何实现？</p>
<pre><code>  利用padding-bottom|margin-bottom正负值相抵；
  设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，
  当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，
  其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</code></pre></li>
</ul>
<ul>
<li><p>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</p>
<pre><code>  * png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.

  * 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

  * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

    浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}

    这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

    渐进识别的方式，从总体中逐渐排除局部。

    首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。
    接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

    css
        .bb{
            background-color:red;/*所有识别*/
            background-color:#00deff\9; /*IE6、7、8识别*/
            +background-color:#a200ff;/*IE6、7识别*/
            _background-color:#1e0bd1;/*IE6识别*/
        }</code></pre></li>
</ul>
<pre><code>    *  IE下,可以使用获取常规属性的方法来获取自定义属性,
       也可以使用getAttribute()获取自定义属性;
       Firefox下,只能使用getAttribute()获取自定义属性。
       解决方法:统一通过getAttribute()获取自定义属性。

    *  IE下,even对象有x,y属性,但是没有pageX,pageY属性;
       Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。

    *  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

    *  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,
       可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。

    超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
    L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</code></pre><ul>
<li><p>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p>
<pre><code>  行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</code></pre></li>
</ul>
<ul>
<li><p>为什么要初始化CSS样式。</p>
<pre><code>  - 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。

  - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。

  最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）

  淘宝的样式初始化代码：
  body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }
  body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }
  h1, h2, h3, h4, h5, h6{ font-size:100%; }
  address, cite, dfn, em, var { font-style:normal; }
  code, kbd, pre, samp { font-family:couriernew, courier, monospace; }
  small{ font-size:12px; }
  ul, ol { list-style:none; }
  a { text-decoration:none; }
  a:hover { text-decoration:underline; }
  sup { vertical-align:text-top; }
  sub{ vertical-align:text-bottom; }
  legend { color:#000; }
  fieldset, img { border:0; }
  button, input, select, textarea { font-size:100%; }
  table { border-collapse:collapse; border-spacing:0; }</code></pre></li>
</ul>
<ul>
<li><p>absolute的containing block(容器块)计算方式跟正常流有什么不同？</p>
<pre><code>  无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：
  1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；
  2、否则,则由这个祖先元素的 padding box 构成。
  如果都找不到，则为 initial containing block。

  补充：
  1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）
  2. absolute: 向上找最近的定位为absolute/relative的元素
  3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</code></pre></li>
<li><p>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p>
<p>  对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.<br>  如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.<br>  仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.</p>
</li>
<li><p>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</p>
<p>  如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠.</p>
</li>
<li><p>对BFC规范(块级格式化上下文：block formatting context)的理解？</p>
<pre><code>  （W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）
   一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。
   不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</code></pre></li>
<li><p>css定义的权重</p>
<pre><code>  以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：

  /*权重为1*/
  div{
  }
  /*权重为10*/
  .class1{
  }
  /*权重为100*/
  #id1{
  }
  /*权重为100+1=101*/
  #id1 div{
  }
  /*权重为10+1=11*/
  .class1 div{
  }
  /*权重为10+10+1=21*/
  .class1 .class2 div{
  }

  如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</code></pre></li>
</ul>
<ul>
<li><p>请解释一下为什么需要清除浮动？清除浮动的方式</p>
<p>  清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</p>
<pre><code>  1、父级div定义height；
  2、父级div 也一起浮动；
  3、常规的使用一个class；
      .clearfix::before, .clearfix::after {
          content: &quot; &quot;;
          display: table;
      }
      .clearfix::after {
          clear: both;
      }
      .clearfix {
          *zoom: 1;
      }

  4、SASS编译的时候，浮动元素的父级div定义伪类:after
      &amp;::after,&amp;::before{
          content: &quot; &quot;;
          visibility: hidden;
          display: block;
          height: 0;
          clear: both;
      }

  解析原理：
  1) display:block 使生成的元素以块级元素显示,占满剩余空间;
  2) height:0 避免生成内容破坏原有布局的高度。
  3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;
  4）通过 content:&quot;.&quot;生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:&quot;.&quot;,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”&quot; 仍然会产生额外的空隙；
  5）zoom：1 触发IE hasLayout。

  通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。</code></pre></li>
<li><p>什么是外边距合并？</p>
<pre><code>  外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。
  合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。
  w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp</code></pre></li>
<li><p>zoom:1的清除浮动原理?</p>
<pre><code>  清除浮动，触发hasLayout；
  Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。
  譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。

  来龙去脉大概如下：
  当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。

  Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。

  目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？
  可以通过css3里面的动画属性scale进行缩放。</code></pre></li>
<li><p>移动端的布局用过媒体查询吗？</p>
</li>
</ul>
<pre><code>假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，
而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法

&lt;!-- link元素中的CSS媒体查询 --&gt;
当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。
当媒体查询返回假， &lt;link&gt; 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。

&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;

&lt;!-- 样式表中的CSS媒体查询 --&gt;
包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。
CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。

&lt;style&gt;
    @media (min-width: 700px) and (orientation: landscape){
      .sidebar {
        display: none;
      }
    }
&lt;/style&gt;</code></pre><ul>
<li><p>使用 CSS 预处理器吗？喜欢那个？</p>
<pre><code>  SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)</code></pre></li>
</ul>
<ul>
<li><p>CSS优化、提高性能的方法有哪些？</p>
<pre><code>  关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；
  如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；
  提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;
  使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）；</code></pre></li>
</ul>
<ul>
<li><p>浏览器是怎样解析CSS选择器的？</p>
<pre><code>  样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。
  只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。</code></pre></li>
</ul>
<ul>
<li><p>在网页中的应该使用奇数还是偶数的字体？为什么呢？</p>
</li>
<li><p>margin和padding分别适合什么场景使用？</p>
<pre><code>  margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。
  margin用于布局分开元素使元素与元素互不相干；
  padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段</code></pre></li>
</ul>
<ul>
<li><p>抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</p>
</li>
<li><p>元素竖向的百分比设定是相对于容器的高度吗？</p>
</li>
<li><p>全屏滚动的原理是什么？用到了CSS的那些属性？</p>
</li>
<li><p>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p>
</li>
<li><p>视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</p>
</li>
<li><p>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p>
<pre><code>  单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）
  双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，
  比如:first-line、:first-letter、:before、:after等，
  而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。

  想让插入的内容出现在其它内容前，使用::before，否者，使用::after；
  在代码顺序上，::after生成的内容也比::before生成的内容靠后。
  如果按堆栈视角，::after生成的内容会在::before生成的内容之上</code></pre></li>
</ul>
<ul>
<li><p>如何修改chrome记住密码后自动填充表单的黄色背景 ？</p>
<pre><code>  input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {
    background-color: rgb(250, 255, 189); /* #FAFFBD; */
    background-image: none;
    color: rgb(0, 0, 0);
  }</code></pre></li>
<li><p>你对line-height是如何理解的？</p>
</li>
<li><p>设置元素浮动后，该元素的display值是多少？</p>
<pre><code>  自动变成了 display:block</code></pre></li>
<li><p>怎么让Chrome支持小于12px 的文字？</p>
<pre><code>  1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。
  2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。
  3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。
  4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。</code></pre></li>
<li><p>让页面里的字体变清晰，变细用CSS怎么做？</p>
<pre><code>  -webkit-font-smoothing: antialiased;</code></pre></li>
<li><p>font-style属性可以让它赋值为“oblique” oblique是什么意思？</p>
<pre><code>  倾斜的字体样式</code></pre></li>
<li><p>position:fixed;在android下无效怎么处理？</p>
<pre><code>  fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，
  原来的网页还好好的在那，fixed的内容也没有变过位置，
  所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</code></pre></li>
<li><p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p>
<pre><code>  多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</code></pre></li>
<li><p>display:inline-block 什么时候会显示间隙？(携程)</p>
<pre><code>  移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</code></pre></li>
<li><p>overflow: scroll时不能平滑滚动的问题怎么处理？</p>
</li>
<li><p>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</p>
</li>
<li><p>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p>
</li>
</ul>
<ul>
<li><p>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</p>
<pre><code>  如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，
  所以不如隔离开。

  因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，
  这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。

  同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，
  提高了webserver的http请求的解析速度。</code></pre></li>
</ul>
<ul>
<li>style标签写在body后与body前有什么区别？</li>
</ul>
<ul>
<li><p>什么是CSS 预处理器 / 后处理器？</p>
<pre><code>  - 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，
    还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。

  - 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的
    是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</code></pre></li>
</ul>
<ul>
<li>rem布局的优缺点</li>
</ul>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><a name='js'>JavaScript</a></h2><ul>
<li><p>介绍js的基本数据类型。</p>
<pre><code>  Undefined、Null、Boolean、Number、String、
  ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</code></pre></li>
<li><p>介绍js有哪些内置对象？</p>
<pre><code> Object 是 JavaScript 中所有对象的父对象

 数据封装类对象：Object、Array、Boolean、Number 和 String
 其他对象：Function、Arguments、Math、Date、RegExp、Error

 参考：http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html</code></pre></li>
<li><p>说几条写JavaScript的基本规范？</p>
<pre><code> 1.不要在同一行声明多个变量。
 2.请使用 ===/!==来比较true/false或者数值
 3.使用对象字面量替代new Array这种形式
 4.不要使用全局函数。
 5.Switch语句必须带有default分支
 6.函数不应该有时候有返回值，有时候没有返回值。
 7.For循环必须使用大括号
 8.If语句必须使用大括号
 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</code></pre></li>
<li><p>JavaScript原型，原型链 ? 有什么特点？</p>
<pre><code> 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，
 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，
 于是就这样一直找下去，也就是我们平时所说的原型链的概念。
 关系：instance.constructor.prototype = instance.__proto__

 特点：
 JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</code></pre></li>
</ul>
<pre><code>     当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，
     就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。
        function Func(){}
        Func.prototype.name = &quot;Sean&quot;;
        Func.prototype.getInfo = function() {
          return this.name;
        }
        var person = new Func();//现在可以参考var person = Object.create(oldObject);
        console.log(person.getInfo());//它拥有了Func的属性和方法
        //&quot;Sean&quot;
        console.log(Func.prototype);
        // Func { name=&quot;Sean&quot;, getInfo=function()}</code></pre><ul>
<li><p>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</p>
<pre><code> 栈：原始数据类型（Undefined，Null，Boolean，Number、String）
 堆：引用数据类型（对象、数组和函数）

 两种类型的区别是：存储位置不同；
 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</code></pre><p> <img src="http://www.w3school.com.cn/i/ct_js_value.gif" alt="Stated Clearly Image"></p>
</li>
<li><p>如何将字符串转化为数字，例如’12.3b’?</p>
<pre><code>  * parseFloat(&#39;12.3b&#39;);
  * 正则表达式，&#39;12.3b&#39;.match(/(\d)+(\.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</code></pre></li>
<li><p>如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</p>
<pre><code>  function commafy(num){
      return num &amp;&amp; num
          .toString()
          .replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2){
              return $2 + &#39;,&#39;;
          });
  }</code></pre></li>
<li><p>如何实现数组的随机排序？</p>
<pre><code>  方法一：
      var arr = [1,2,3,4,5,6,7,8,9,10];
      function randSort1(arr){
          for(var i = 0,len = arr.length;i &lt; len; i++ ){
              var rand = parseInt(Math.random()*len);
              var temp = arr[rand];
              arr[rand] = arr[i];
              arr[i] = temp;
          }
          return arr;
      }
      console.log(randSort1(arr));

  方法二：
      var arr = [1,2,3,4,5,6,7,8,9,10];
      function randSort2(arr){
          var mixedArray = [];
          while(arr.length &gt; 0){
              var randomIndex = parseInt(Math.random()*arr.length);
              mixedArray.push(arr[randomIndex]);
              arr.splice(randomIndex, 1);
          }
          return mixedArray;
      }
      console.log(randSort2(arr));

  方法三：
      var arr = [1,2,3,4,5,6,7,8,9,10];
      arr.sort(function(){
          return Math.random() - 0.5;
      })
      console.log(arr);</code></pre></li>
<li><p>Javascript如何实现继承？</p>
<pre><code> 1、构造继承
 2、原型继承
 3、实例继承
 4、拷贝继承

 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。

     function Parent(){
         this.name = &#39;wang&#39;;
     }

     function Child(){
         this.age = 28;
     }
     Child.prototype = new Parent();//继承了Parent，通过原型

     var demo = new Child();
     alert(demo.age);
     alert(demo.name);//得到被继承的属性</code></pre></li>
<li><p>JavaScript继承的几种实现方式？</p>
<ul>
<li>参考：<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">构造函数的继承</a>，<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="noopener">非构造函数的继承</a>；</li>
</ul>
</li>
</ul>
<ul>
<li><p>javascript创建对象的几种方式？</p>
<pre><code> javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</code></pre></li>
</ul>
<pre><code>    1、对象字面量的方式

        person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};

    2、用function来模拟无参的构造函数

        function Person(){}
        var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class
        person.name=&quot;Mark&quot;;
        person.age=&quot;25&quot;;
        person.work=function(){
        alert(person.name+&quot; hello...&quot;);
        }
        person.work();

    3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）

        function Pet(name,age,hobby){
           this.name=name;//this作用域：当前对象
           this.age=age;
           this.hobby=hobby;
           this.eat=function(){
              alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);
           }
        }
        var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象
        maidou.eat();//调用eat方法


    4、用工厂方式来创建（内置对象）

         var wcDog =new Object();
         wcDog.name=&quot;旺财&quot;;
         wcDog.age=3;
         wcDog.work=function(){
           alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);
         }
         wcDog.work();


    5、用原型方式来创建

        function Dog(){

         }
         Dog.prototype.name=&quot;旺财&quot;;
         Dog.prototype.eat=function(){
         alert(this.name+&quot;是个吃货&quot;);
         }
         var wangcai =new Dog();
         wangcai.eat();


    5、用混合方式来创建

        function Car(name,price){
          this.name=name;
          this.price=price;
        }
         Car.prototype.sell=function(){
           alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);
          }
        var camry =new Car(&quot;凯美瑞&quot;,27);
        camry.sell();</code></pre><ul>
<li><p>Javascript作用链域?</p>
<pre><code> 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。
 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，
 直至全局函数，这种组织形式就是作用域链。</code></pre></li>
<li><p>谈谈This对象的理解。</p>
<pre><code>   this总是指向函数的直接调用者（而非间接调用者）；
 如果有new关键字，this指向new出来的那个对象；
 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</code></pre></li>
<li><p>eval是做什么的？</p>
<pre><code> 它的功能是把对应的字符串解析成JS代码并运行；
 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);</code></pre></li>
<li><p>什么是window对象? 什么是document对象?</p>
<pre><code> window对象是指浏览器打开的窗口。
 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</code></pre></li>
<li><p>null，undefined 的区别？</p>
<pre><code> null         表示一个对象是“没有值”的值，也就是值为“空”；
 undefined     表示一个变量声明了没有初始化(赋值)；

 undefined不是一个有效的JSON，而null是；
 undefined的类型(typeof)是undefined；
 null的类型(typeof)是object；</code></pre></li>
</ul>
<pre><code>    Javascript将未赋值的变量默认值设为undefined；
    Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。

    typeof undefined
        //&quot;undefined&quot;
        undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；
        例如变量被声明了，但没有赋值时，就等于undefined

    typeof null
        //&quot;object&quot;
        null : 是一个对象(空对象, 没有任何属性和方法)；
        例如作为函数的参数，表示该函数的参数不是对象；

    注意：
        在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined
         null == undefined // true
          null === undefined // false

    再来一个例子：

        null
        Q：有张三这个人么？
        A：有！
        Q：张三有房子么？
        A：没有！

        undefined
        Q：有张三这个人么？
        A：有！
        Q: 张三有多少岁？
        A: 不知道（没有被告诉）

参考阅读：[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)</code></pre><ul>
<li><p>写一个通用的事件侦听器函数。</p>
<pre><code>     // event(事件)工具集，来源：github.com/markyun
     markyun.Event = {
         // 页面加载完成后
         readyEvent : function(fn) {
             if (fn==null) {
                 fn=document;
             }
             var oldonload = window.onload;
             if (typeof window.onload != &#39;function&#39;) {
                 window.onload = fn;
             } else {
                 window.onload = function() {
                     oldonload();
                     fn();
                 };
             }
         },
         // 视能力分别使用dom0||dom2||IE方式 来绑定事件
         // 参数： 操作的元素,事件名称 ,事件处理程序
         addEvent : function(element, type, handler) {
             if (element.addEventListener) {
                 //事件类型、需要执行的函数、是否捕捉
                 element.addEventListener(type, handler, false);
             } else if (element.attachEvent) {
                 element.attachEvent(&#39;on&#39; + type, function() {
                     handler.call(element);
                 });
             } else {
                 element[&#39;on&#39; + type] = handler;
             }
         },
         // 移除事件
         removeEvent : function(element, type, handler) {
             if (element.removeEventListener) {
                 element.removeEventListener(type, handler, false);
             } else if (element.datachEvent) {
                 element.detachEvent(&#39;on&#39; + type, handler);
             } else {
                 element[&#39;on&#39; + type] = null;
             }
         },
         // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
         stopPropagation : function(ev) {
             if (ev.stopPropagation) {
                 ev.stopPropagation();
             } else {
                 ev.cancelBubble = true;
             }
         },
         // 取消事件的默认行为
         preventDefault : function(event) {
             if (event.preventDefault) {
                 event.preventDefault();
             } else {
                 event.returnValue = false;
             }
         },
         // 获取事件目标
         getTarget : function(event) {
             return event.target || event.srcElement;
         },
         // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
         getEvent : function(e) {
             var ev = e || window.event;
             if (!ev) {
                 var c = this.getEvent.caller;
                 while (c) {
                     ev = c.arguments[0];
                     if (ev &amp;&amp; Event == ev.constructor) {
                         break;
                     }
                     c = c.caller;
                 }
             }
             return ev;
         }
     };</code></pre></li>
<li><p>[“1”, “2”, “3”].map(parseInt) 答案是多少？</p>
<pre><code> parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，
 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;
 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。

 function parseInt(str, radix) {
     return str+&#39;-&#39;+radix;
 };
 var a=[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;];
 a.map(parseInt);  // [&quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;] 不能大于radix

 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN
 所以[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案也就是：[1, NaN, NaN]

 详细解析：http://blog.csdn.net/justjavac/article/details/19473199</code></pre></li>
<li><p>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p>
<pre><code>  1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
  2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；
  3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</code></pre></li>
</ul>
<ul>
<li><p>什么是闭包（closure），为什么要用它？</p>
<pre><code> 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。

 闭包的特性：

 1.函数内再嵌套函数
 2.内部函数可以引用外层的参数和变量
 3.参数和变量不会被垃圾回收机制回收

 //li节点的onclick事件都能正确的弹出当前被点击的li索引
  &lt;ul id=&quot;testUL&quot;&gt;
     &lt;li&gt; index = 0&lt;/li&gt;
     &lt;li&gt; index = 1&lt;/li&gt;
     &lt;li&gt; index = 2&lt;/li&gt;
     &lt;li&gt; index = 3&lt;/li&gt;
 &lt;/ul&gt;
 &lt;script type=&quot;text/javascript&quot;&gt;
       var nodes = document.getElementsByTagName(&quot;li&quot;);
     for(i = 0;i&lt;nodes.length;i+= 1){
         nodes[i].onclick = (function(i){
                   return function() {
                      console.log(i);
                   } //不用闭包的话，值每次都是4
                 })(i);
     }
 &lt;/script&gt;</code></pre></li>
</ul>
<pre><code>    执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在
    使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源
    因为say667()的内部函数的执行需要依赖say667()中的变量
    这是对闭包作用的非常直白的描述

      function say667() {
        // Local variable that ends up within closure
        var num = 666;
        var sayAlert = function() {
            alert(num);
        }
        num++;
        return sayAlert;
    }

     var sayAlert = say667();
     sayAlert()//执行结果应该弹出的667</code></pre><ul>
<li><p>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p>
<pre><code> use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,

 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。
 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;
 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；
 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;

 提高编译器效率，增加运行速度；
 为未来新版本的Javascript标准化做铺垫。</code></pre></li>
</ul>
<ul>
<li><p>如何判断一个对象是否属于某个类？</p>
<pre><code>    使用instanceof （待完善）
    if(a instanceof Person){
        alert(&#39;yes&#39;);
    }</code></pre></li>
<li><p>new操作符具体干了什么呢?</p>
<pre><code>      1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
          2、属性和方法被加入到 this 引用的对象中。
       3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。

 var obj  = {};
 obj.__proto__ = Base.prototype;
 Base.call(obj);</code></pre></li>
</ul>
<ul>
<li>用原生JavaScript的实现过什么功能吗？</li>
</ul>
<ul>
<li><p>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p>
<pre><code> hasOwnProperty

 javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。
 使用方法：
 object.hasOwnProperty(proName)
 其中参数object是必选项。一个对象的实例。
 proName是必选项。一个属性名称的字符串值。

 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</code></pre></li>
<li><p>JSON 的了解？</p>
<pre><code> JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
 如：{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}

 JSON字符串转换为JSON对象:
 var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);
 var obj = str.parseJSON();
 var obj = JSON.parse(str);

 JSON对象转换为JSON字符串：
 var last=obj.toJSONString();
 var last=JSON.stringify(obj);</code></pre></li>
<li><p><code>[].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)})</code> 能解释一下这段代码的意思吗？</p>
</li>
</ul>
<ul>
<li><p>js延迟加载的方式有哪些？</p>
<pre><code> defer和async、动态创建DOM方式（用得最多）、按需异步载入js</code></pre></li>
</ul>
<ul>
<li><p>Ajax 是什么? 如何创建一个Ajax？</p>
<pre><code> ajax的全称：Asynchronous Javascript And XML。
 异步传输+js+xml。
 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。

 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象
 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
 (3)设置响应HTTP请求状态变化的函数
 (4)发送HTTP请求
 (5)获取异步调用返回的数据
 (6)使用JavaScript和DOM实现局部刷新</code></pre></li>
<li><p>Ajax 解决浏览器缓存问题？</p>
<pre><code>  1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。

  2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。

  3、在URL后面加上一个随机数： &quot;fresh=&quot; + Math.random();。

  4、在URL后面加上时间戳：&quot;nowtime=&quot; + new Date().getTime();。

  5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</code></pre></li>
<li><p>同步和异步的区别?</p>
<p> 同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</p>
</li>
</ul>
<pre><code>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。

异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。



（待完善）</code></pre><ul>
<li><p>如何解决跨域问题?</p>
<pre><code> jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</code></pre></li>
<li><p>页面编码和被请求的资源编码如果不一致如何处理？</p>
</li>
<li><p>服务器代理转发时，该如何处理cookie？</p>
<pre><code> nginx</code></pre></li>
</ul>
<ul>
<li><p>模块化开发怎么做？</p>
<p>  <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="noopener"> 立即执行函数</a>,不暴露私有成员</p>
<pre><code>     var module1 = (function(){
     　　　　var _count = 0;
     　　　　var m1 = function(){
     　　　　　　//...
     　　　　};
     　　　　var m2 = function(){
     　　　　　　//...
     　　　　};
     　　　　return {
     　　　　　　m1 : m1,
     　　　　　　m2 : m2
     　　　　};
     　　})();</code></pre><p> （待完善）</p>
</li>
<li><p>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p>
<blockquote>
<p>AMD 规范在这里：<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">https://github.com/amdjs/amdjs-api/wiki/AMD</a></p>
</blockquote>
<blockquote>
<p>CMD 规范在这里：<a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/242</a></p>
</blockquote>
<pre><code> Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。

  区别：

     1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
     2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

 // CMD
 define(function(require, exports, module) {
     var a = require(&#39;./a&#39;)
     a.doSomething()
     // 此处略去 100 行
     var b = require(&#39;./b&#39;) // 依赖可以就近书写
     b.doSomething()
     // ...
 })

 // AMD 默认推荐
 define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { // 依赖必须一开始就写好
     a.doSomething()
     // 此处略去 100 行
     b.doSomething()
     // ...
 })</code></pre></li>
</ul>
<ul>
<li><p>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何<br>缓存的？）</p>
<pre><code> 参考：http://annn.me/how-to-realize-cmd-loader/</code></pre></li>
<li><p>JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</p>
</li>
<li><p>谈一谈你对ECMAScript6的了解？</p>
</li>
<li><p>ECMAScript6 怎么写class么，为什么会出现class这种东西?</p>
</li>
<li><p>异步加载JS的方式有哪些？</p>
<pre><code>   (1) defer，只支持IE

   (2) async：

   (3) 创建script，插入到DOM中，加载完毕后callBack</code></pre></li>
<li><p>documen.write和 innerHTML的区别</p>
<pre><code>  document.write只能重绘整个页面

  innerHTML可以重绘页面的一部分</code></pre></li>
<li><p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p>
<pre><code>  （1）创建新节点
    createDocumentFragment()    //创建一个DOM片段
    createElement()   //创建一个具体的元素
    createTextNode()   //创建一个文本节点
  （2）添加、移除、替换、插入
    appendChild()
    removeChild()
    replaceChild()
    insertBefore() //在已有的子节点前插入一个新的子节点
  （3）查找
    getElementsByTagName()    //通过标签名称
    getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
    getElementById()    //通过元素Id，唯一性</code></pre></li>
<li><p>.call() 和 .apply() 的区别？</p>
</li>
</ul>
<pre><code>      例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);

      注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。

        function add(a,b)
        {
            alert(a+b);
        }

        function sub(a,b)
        {
            alert(a-b);
        }

        add.call(sub,3,1);</code></pre><ul>
<li><p>数组和对象有哪些原生方法，列举一下？</p>
</li>
<li><p>JS 怎么实现一个类。怎么实例化这个类</p>
</li>
<li><p>JavaScript中的作用域与变量声明提升？</p>
</li>
<li><p>如何编写高性能的Javascript？</p>
</li>
<li><p>那些操作会造成内存泄漏？</p>
</li>
<li><p>JQuery的源码看过吗？能不能简单概况一下它的实现原理？</p>
</li>
<li><p>jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</p>
</li>
<li><p>jquery中如何将数组转化为json字符串，然后再转化回来？</p>
</li>
<li><p>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</p>
</li>
<li><p>jquery.extend 与 jquery.fn.extend的区别？</p>
<pre><code> * jquery.extend 为jquery类添加类方法，可以理解为添加静态方法
 * jquery.fn.extend:
     源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数
 使用：
 jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。</code></pre></li>
</ul>
<ul>
<li><p>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p>
</li>
<li><p>谈一下Jquery中的bind(),live(),delegate(),on()的区别？</p>
</li>
<li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>
</li>
<li><p>是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？</p>
</li>
<li><p>jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）</p>
</li>
<li><p>针对 jQuery性能的优化方法？</p>
</li>
<li><p>Jquery与jQuery UI 有啥区别？</p>
</li>
</ul>
<pre><code>    *jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。

    *jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。
     提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</code></pre><ul>
<li><p>JQuery的源码看过吗？能不能简单说一下它的实现原理？</p>
</li>
<li><p>jquery 中如何将数组转化为json字符串，然后再转化回来？</p>
</li>
</ul>
<p>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</p>
<pre><code>    $.fn.stringifyArray = function(array) {
        return JSON.stringify(array)
    }

    $.fn.parseArray = function(array) {
        return JSON.parse(array)
    }

    然后调用：
    $(&quot;&quot;).stringifyArray(array)</code></pre><ul>
<li><p>jQuery和Zepto的区别？各自的使用场景？</p>
</li>
<li><p>针对 jQuery 的优化方法？</p>
<pre><code> *基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。

 *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。
  比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;);

 *for (var i = size; i &lt; arr.length; i++) {}
  for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：
  for (var i = size, length = arr.length; i &lt; length; i++) {}</code></pre></li>
</ul>
<ul>
<li><p>Zepto的点透问题如何解决？</p>
</li>
<li><p>jQueryUI如何自定义组件?</p>
</li>
<li><p>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</p>
</li>
<li><p>如何判断当前脚本运行在浏览器还是node环境中？（阿里）</p>
<pre><code>  this === window ? &#39;browser&#39; : &#39;node&#39;;

  通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</code></pre></li>
<li><p>移动端最小触控区域是多大？</p>
</li>
<li><p>jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</p>
<pre><code> jquery stop(): 如：$(&quot;#div&quot;).stop().animate({width:&quot;100px&quot;},100);</code></pre></li>
<li><p>把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</p>
</li>
<li><p>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）</p>
</li>
<li><p>知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?</p>
</li>
<li><p>Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？</p>
</li>
<li><p>解释JavaScript中的作用域与变量声明提升？</p>
</li>
<li><p>那些操作会造成内存泄漏？</p>
<pre><code> 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</code></pre></li>
<li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>
<pre><code> * 多个事件同一个函数：
     $(&quot;div&quot;).on(&quot;click mouseover&quot;, function(){});
 * 多个事件不同函数
     $(&quot;div&quot;).on({
         click: function(){},
         mouseover: function(){}
     });</code></pre></li>
<li><p>Node.js的适用场景？</p>
</li>
<li><p>(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?</p>
</li>
<li><p>解释一下 Backbone 的 MVC 实现方式？</p>
</li>
<li><p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</p>
</li>
<li><p>知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</p>
<pre><code>  Chrome,Safari浏览器内核。</code></pre></li>
<li><p>如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</p>
</li>
<li><p>前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</p>
</li>
<li><p>简述一下 Handlebars 的基本用法？</p>
</li>
<li><p>简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</p>
</li>
<li><p>用js实现千位分隔符?(来源：<a href="http://div.io/topic/744" target="_blank" rel="noopener">前端农民工</a>，提示：正则+replace)</p>
</li>
</ul>
<pre><code>    参考：http://www.tuicool.com/articles/ArQZfui
    function commafy(num) {
        return num &amp;&amp; num
            .toString()
            .replace(/(\d)(?=(\d{3})+\.)/g, function($0, $1) {
                return $1 + &quot;,&quot;;
            });
    }
    console.log(commafy(1234567.90)); //1,234,567.90</code></pre><ul>
<li><p>检测浏览器版本版本有哪些方式？</p>
<pre><code>  功能检测、userAgent特征检测

  比如：navigator.userAgent
  //&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36
    (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36&quot;</code></pre></li>
</ul>
<ul>
<li><p>What is a Polyfill?</p>
<pre><code>  polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。
  例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，
  所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，
  一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</code></pre></li>
<li><p>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？</p>
<pre><code>  比如： html5shiv、Geolocation、Placeholder</code></pre></li>
<li><p>我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</p>
</li>
</ul>
<ul>
<li><p>使用JS实现获取文件扩展名？</p>
<pre><code>  function getFileExtension(filename) {
    return filename.slice((filename.lastIndexOf(&quot;.&quot;) - 1 &gt;&gt;&gt; 0) + 2);
  }

  String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。
  对于&#39;filename&#39;和&#39;.hiddenfile&#39;，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。
  String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</code></pre></li>
<li><p>Webpack热更新实现原理?</p>
<pre><code>  1. Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信)
  2. 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端
  3. 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash
  4. 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端
  5. 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档
  6. hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。</code></pre></li>
<li><p>请介绍一下JS之事件节流？</p>
</li>
<li><p>什么是JS的函数防抖？</p>
</li>
</ul>
<h4 id="ECMAScript6-相关"><a href="#ECMAScript6-相关" class="headerlink" title="ECMAScript6 相关"></a><a name='other'>ECMAScript6 相关</a></h4><ul>
<li><p>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</p>
<pre><code>  两等号判等，会在比较时进行类型转换；
  三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；

  Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，
  但 Object.is(NaN, NaN) 会返回 true.

   Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</code></pre></li>
<li><p>ES6是如何实现编译成ES5的？</p>
</li>
<li><p>css-loader的原理？</p>
</li>
</ul>
<h2 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a><a name='other'>前端框架</a></h2><ul>
<li><p>React 使用场景？</p>
<pre><code>      逻辑复杂单页应用，偏中后台管理系统，纯展示性的UI页面不合适、</code></pre></li>
<li><p>描述一下React 生命周期</p>
<pre><code>      渲染过程调用到的生命周期函数，主要几个要知道；
      * constructor 
      * getInitialState 
      * getDefaultProps 
      * componentWillMount 
      * render 
      * componentDidMount 

      更新过程

      * componentWillReceiveProps 
      * shouldComponentUpdate 
      * componentWillUpdate 
      * render 
      * componentDidUpdate 

      卸载过程

      componentWillUnmount</code></pre></li>
</ul>
<ul>
<li><p>实现组件有哪些方式？</p>
<pre><code>  React.createClass 使用API来定义组件
  React ES6 class component 用 ES6 的class 来定义组件
  Functional stateless component 通过函数定义无状态组件</code></pre></li>
</ul>
<ul>
<li><p>应该在React生命周期的什么阶段发出ajax请求，为什么？</p>
<pre><code>          AJAX请求应在 componentDidMount函数 进行请求。</code></pre></li>
<li><p>shouldComponentUpdate函数有什么作用？</p>
<pre><code>          shouldComponentUpdate是一个允许我们自行决定某些组件（以及他们的子组件）是否进行更新的生命周期函数，reconciliation的最终目的是尽可能以最有效的方式去根据新的state更新UI，
          如果你已经知道UI的哪些状态无需进行改变，就没必要去让React去判断它是否该改变。 让shouldComponentUpdate返回falss, React就会让当前的组件和其子组件保持不变。</code></pre></li>
<li><p>当组件的setState函数被调用之后，发生了什么？</p>
<pre><code>          React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，
          尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，
          React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，
          并且知道如何只通过必要的更新来最小化重渲染。</code></pre></li>
<li><p>为什么循环产生的组件中要利用上key这个特殊的prop？</p>
<pre><code>          Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。React利用子元素的key在比较两棵树的时候，快速得知一个元素是新的还是刚刚被移除。没有keys，React也就不知道当前哪一个的item被移除了。</code></pre></li>
<li><p>React-router 路由的实现原理？</p>
</li>
<li><p>说说React Native,Weex框架的实现原理？</p>
</li>
<li><p>受控组件(Controlled Component)与非受控组件(Uncontrolled Component)的区别</p>
</li>
<li><p>refs 是什么?</p>
<pre><code>      Refs是能访问DOM元素或组件实例的一个函数；</code></pre></li>
<li><p>React为什么自己定义一套事件体系呢，与浏览器原生事件体系有什么关系？</p>
</li>
<li><p>什么时候应该选择用class实现一个组件，什么时候用一个函数实现一个组件？</p>
<pre><code>      组件用到了state或者用了生命周期函数，那么就该使用Class component。其他情况下，应使用Functional component。</code></pre></li>
<li><p>什么是HoC（Higher-Order Component）？适用于什么场景？</p>
<pre><code>      高阶组件就是一个 React 组件包裹着另外一个 React 组件</code></pre></li>
<li><p>并不是父子关系的组件，如何实现相互的数据通信？</p>
<pre><code>      使用父组件，通过props将变量传入子组件 （如通过refs，父组件获取一个子组件的方法，简单包装后，将包装后的方法通过props传入另一个子组件 ）</code></pre></li>
<li><p>用过 React 技术栈中哪些数据流管理库？</p>
<pre><code>      Redux\Dva</code></pre></li>
<li><p>Redux是如何做到可预测呢？</p>
</li>
<li><p>Redux将React组件划分为哪两种？</p>
</li>
<li><p>Redux是如何将state注入到React组件上的？</p>
</li>
<li><p>请描述一次完整的 Redux 数据流</p>
</li>
<li><p>React的批量更新机制 BatchUpdates？</p>
</li>
<li><p>React与Vue，各自的组件更新进行对比，它们有哪些区别？</p>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a><a name='other'>其他问题</a></h2><ul>
<li><p>原来公司工作流程是怎么样的，如何与其他人协作的？如何跨部门合作的？</p>
</li>
<li><p>你遇到过比较难的技术问题是？你是如何解决的？</p>
</li>
<li><p>设计模式 知道什么是singleton, factory, strategy, decrator么?</p>
</li>
<li><p>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</p>
</li>
<li><p>页面重构怎么操作？</p>
<pre><code>  网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。
  也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。

  对于传统的网站来说重构通常是：

  表格(table)布局改为DIV+CSS
  使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)
  对于移动平台的优化
  针对于SEO进行优化
  深层次的网站重构应该考虑的方面

  减少代码间的耦合
  让代码保持弹性
  严格按规范编写代码
  设计可扩展的API
  代替旧有的框架、语言(如VB)
  增强用户体验
  通常来说对于速度的优化也包含在重构中

  压缩JS、CSS、image等前端资源(通常是由服务器来解决)
  程序的性能优化(如数据读写)
  采用CDN来加速资源加载
  对于JS DOM的优化
  HTTP服务器的文件缓存</code></pre></li>
<li><p>列举IE与其他浏览器不一样的特性？</p>
</li>
</ul>
<pre><code>    1、事件不同之处：

           触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；

        获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；

        阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；

        停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；</code></pre><ul>
<li><p>99%的网站都需要被重构是那本书上写的？</p>
<pre><code>  网站重构：应用web标准进行设计（第2版）</code></pre></li>
<li><p>什么叫优雅降级和渐进增强？</p>
<pre><code>  优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。
  如：border-shadow

  渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
  如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</code></pre></li>
<li><p>是否了解公钥加密和私钥加密。</p>
<pre><code>  一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;
  HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</code></pre></li>
</ul>
<ul>
<li><p>WEB应用从服务器主动推送Data到客户端有那些方式？</p>
<pre><code>  html5提供的Websocket
  不可见的iframe
  WebSocket通过Flash
  XHR长时间连接
  XHR Multipart Streaming
  &lt;script&gt;标签的长时间连接(可跨域)</code></pre></li>
<li><p>对Node的优点和缺点提出了自己的看法？</p>
</li>
</ul>
<pre><code>    *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
      因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
      此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，
      因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

    *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，
      而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</code></pre><ul>
<li><p>你有用过哪些前端性能优化的方法？</p>
<pre><code>    （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。

    （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

    （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

    （4） 当需要设置的样式很多时设置className而不是直接操作style。

    （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

    （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。

    （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

    （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
    对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</code></pre></li>
<li><p>http状态码有那些？分别代表是什么意思？</p>
<pre><code>      简单版
      [
          100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
          200  OK         正常返回信息
          201  Created      请求成功并且服务器创建了新的资源
          202  Accepted     服务器已接受请求，但尚未处理
          301  Moved Permanently  请求的网页已永久移动到新位置。
          302 Found          临时性重定向。
          303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。
          304  Not Modified 自从上次请求后，请求的网页未修改过。

          400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
          401 Unauthorized 请求未授权。
          403 Forbidden      禁止访问。
          404 Not Found      找不到如何与 URI 相匹配的资源。

          500 Internal Server Error  最常见的服务器端错误。
          503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
      ]

    完整版
    1**(信息类)：表示接收到请求并且继续处理
      100——客户必须继续发出请求
      101——客户要求服务器根据请求转换HTTP协议版本

    2**(响应成功)：表示动作被成功接收、理解和接受
      200——表明该请求被成功地完成，所请求的资源发送回客户端
      201——提示知道新文件的URL
      202——接受和处理、但处理未完成
      203——返回信息不确定或不完整
      204——请求收到，但返回信息为空
      205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
      206——服务器已经完成了部分用户的GET请求

    3**(重定向类)：为了完成指定的动作，必须接受进一步处理
      300——请求的资源可在多处得到
      301——本网页被永久性转移到另一个URL
      302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
      303——建议客户访问其他URL或访问方式
      304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用
      305——请求的资源必须从服务器指定的地址得到
      306——前一版本HTTP中使用的代码，现行版本中不再使用
      307——申明请求的资源临时性删除

    4**(客户端错误类)：请求包含错误语法或不能正确执行
      400——客户端请求有语法错误，不能被服务器所理解
      401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
      HTTP 401.1 - 未授权：登录失败
      　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败
      　　HTTP 401.3 - ACL 禁止访问资源
      　　HTTP 401.4 - 未授权：授权被筛选器拒绝
      HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
      402——保留有效ChargeTo头响应
      403——禁止访问，服务器收到请求，但是拒绝提供服务
      HTTP 403.1 禁止访问：禁止可执行访问
      　　HTTP 403.2 - 禁止访问：禁止读访问
      　　HTTP 403.3 - 禁止访问：禁止写访问
      　　HTTP 403.4 - 禁止访问：要求 SSL
      　　HTTP 403.5 - 禁止访问：要求 SSL 128
      　　HTTP 403.6 - 禁止访问：IP 地址被拒绝
      　　HTTP 403.7 - 禁止访问：要求客户证书
      　　HTTP 403.8 - 禁止访问：禁止站点访问
      　　HTTP 403.9 - 禁止访问：连接的用户过多
      　　HTTP 403.10 - 禁止访问：配置无效
      　　HTTP 403.11 - 禁止访问：密码更改
      　　HTTP 403.12 - 禁止访问：映射器拒绝访问
      　　HTTP 403.13 - 禁止访问：客户证书已被吊销
      　　HTTP 403.15 - 禁止访问：客户访问许可过多
      　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效
      HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效
      404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL
      405——用户在Request-Line字段定义的方法不允许
      406——根据用户发送的Accept拖，请求资源不可访问
      407——类似401，用户必须首先在代理服务器上得到授权
      408——客户端没有在用户指定的饿时间内完成请求
      409——对当前资源状态，请求不能完成
      410——服务器上不再有此资源且无进一步的参考地址
      411——服务器拒绝用户定义的Content-Length属性请求
      412——一个或多个请求头字段在当前请求中错误
      413——请求的资源大于服务器允许的大小
      414——请求的资源URL长于服务器允许的长度
      415——请求资源不支持请求项目格式
      416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
      417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。

    5**(服务端错误类)：服务器不能正确执行一个正确的请求
      HTTP 500 - 服务器遇到错误，无法完成请求
      　　HTTP 500.100 - 内部服务器错误 - ASP 错误
      　　HTTP 500-11 服务器关闭
      　　HTTP 500-12 应用程序重新启动
      　　HTTP 500-13 - 服务器太忙
      　　HTTP 500-14 - 应用程序无效
      　　HTTP 500-15 - 不允许请求 global.asa
      　　Error 501 - 未实现
    HTTP 502 - 网关错误
    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</code></pre></li>
<li><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</p>
<pre><code>    注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，
    而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、
    到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；

    详细版：
      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;
      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;
      4、进行HTTP协议会话，客户端发送报头(请求报头);
      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;
      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;
      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;
      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。

    简洁版：
      浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
      服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
      浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
      载入解析到的资源文件，渲染页面，完成。</code></pre></li>
<li><p>部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？</p>
</li>
<li><p>从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?</p>
</li>
<li><p>第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？</p>
<pre><code>      localStorage</code></pre></li>
<li><p>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</p>
</li>
<li><p>你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？</p>
<pre><code>  Sublime Text 3 + 插件
  Google chrome 查看页面UI、动画效果和交互功能，Firebug 兼容测试和
  Node.js + webpack
  Git 版本控制和Code Review</code></pre></li>
<li><p>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</p>
<pre><code>  前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。
  1、实现界面交互
  2、提升用户体验
  3、有了Node.js，前端可以实现服务端的一些事情</code></pre></li>
</ul>
<pre><code>    前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，

    参与项目，快速高质量完成实现效果图，精确到1px；

    与团队成员，UI设计，产品经理的沟通；

    做好的页面结构，页面重构和用户体验；

    处理hack，兼容、写出优美的代码格式；

    针对服务器的优化、拥抱最新前端技术。</code></pre><ul>
<li><p>你怎么看待Web App 、hybrid App、Native App？</p>
</li>
<li><p>你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）</p>
</li>
<li><p>产品进行版本升级时，可能发生不兼容性问题，如何提前预防和解决？</p>
<pre><code>  非覆盖式发布，API新增而不是在原来的上面修改；
  提前做好 @Deprecated的版本提示；</code></pre></li>
<li><p>你对加班的看法？</p>
</li>
</ul>
<pre><code>       加班就像借钱，原则应当是------救急不救穷</code></pre><ul>
<li><p>平时如何管理你的项目？</p>
<pre><code>  先期团队必须确定好全局样式（global.css），编码模式(utf-8) 等；

  编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；

  标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；

  页面进行标注（例如 页面 模块 开始和结束）；

  CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；

  JS 分文件夹存放 命名以该JS功能为准的英文翻译。

  图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</code></pre></li>
<li><p>如何设计突发大规模并发架构？</p>
</li>
</ul>
<ul>
<li><p>当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？</p>
</li>
<li><p>说说最近最流行的一些东西吧？常去哪些网站？</p>
<pre><code>      ES6\WebAssembly\Node\MVVM\Web Components\React\React Native\Webpack 组件化</code></pre></li>
<li><p>知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?</p>
</li>
</ul>
<ul>
<li><p>移动端（Android IOS）怎么做好用户体验?</p>
<pre><code>  清晰的视觉纵线、
  信息的分组、极致的减法、
  利用选择代替输入、
  标签及文字的排布方式、
  依靠明文确认密码、
  合理的键盘利用、</code></pre></li>
<li><p>简单描述一下你做过的移动APP项目研发流程？</p>
</li>
<li><p>你在现在的团队处于什么样的角色，起到了什么明显的作用？</p>
</li>
<li><p>你认为怎样才是全端工程师（Full Stack developer）？</p>
</li>
<li><p>介绍一个你最得意的作品吧？</p>
</li>
<li><p>你有自己的技术博客吗，用了哪些技术？</p>
</li>
<li><p>对前端安全有什么看法？</p>
</li>
<li><p>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p>
</li>
<li><p>项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。</p>
</li>
<li><p>最近在学什么东西？</p>
</li>
<li><p>你的优点是什么？缺点是什么？</p>
</li>
<li><p>如何管理前端团队?</p>
</li>
<li><p>最近在学什么？能谈谈你未来3，5年给自己的规划吗？</p>
</li>
</ul>
<h2 id="前端学习网站推荐"><a href="#前端学习网站推荐" class="headerlink" title="前端学习网站推荐"></a><a name='web'>前端学习网站推荐</a></h2><pre><code>1. 极客标签：     http://www.gbtags.com/

2. 码农周刊：     http://weekly.manong.io/issues/

3. 前端周刊：     http://www.feweekly.com/issues

4. 慕课网：       http://www.imooc.com/

5. div.io：         http://div.io

6. Hacker News： https://news.ycombinator.com/news

7. InfoQ：       http://www.infoq.com/

8. w3cplus：     http://www.w3cplus.com/

9. Stack Overflow： http://stackoverflow.com/

10.w3school：    http://www.w3school.com.cn/

11.mozilla：     https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</code></pre><h2 id="文档推荐"><a href="#文档推荐" class="headerlink" title="文档推荐"></a><a name='web'>文档推荐</a></h2><ol>
<li><p><a href="http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html" target="_blank" rel="noopener" title="jQuery 基本原理">jQuery 基本原理</a></p>
</li>
<li><p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="noopener">JavaScript 秘密花园</a></p>
</li>
<li><p><a href="http://css.doyoe.com/" target="_blank" rel="noopener">CSS参考手册</a></p>
</li>
<li><p><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">JavaScript 标准参考教程</a></p>
</li>
<li><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6入门</a></p>
</li>
</ol>
<p><strong>备注：</strong></p>
<pre><code>根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。

资料答案不够正确和全面，欢迎欢迎Star和提交issues。

格式不断修改更新中。

在 github 项目的右上角，有三个按钮,分别是 watch、star、fork，新来的同学注意不要用错了，无休止的邮件提醒会给你造成不必要的信息干扰。

当你选择Watching，表示你以后会关注这个项目的全部动态，以后只要这个项目发生变动，被别人提交了pull request、被发起了issue等情况你都会收到邮件通知。

star相当于是点赞或收藏，方便以后查找。

fork表示你想要补充完善这个项目的内容。

更新记录：
2018-01-14： 公司在招聘前端，使用react技术栈；借此机会更新一波前端框架相关的题目；
2016-10-20： 更新一些已被发现的问题。
2016-03-25： 新增ECMAScript6 相关问题</code></pre><h3 id="更新时间-2018-01-14"><a href="#更新时间-2018-01-14" class="headerlink" title="更新时间:  2018-01-14"></a>更新时间:  2018-01-14</h3><pre><code>爱机车、爱骑行、爱旅行、爱摄影、爱阅读的前端开发攻城师。

我的微博：http://weibo.com/920802999</code></pre>]]></content>
  </entry>
  <entry>
    <title>前端面试经典问题汇总-JS篇</title>
    <url>/article/2020/01/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB-JS%E7%AF%87.html</url>
    <content><![CDATA[<h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<p>描述符可同时具有的键值</p>
<table>
<thead>
<tr>
<th></th>
<th>configurable</th>
<th>enumerable</th>
<th>value</th>
<th>writable</th>
<th>get</th>
<th>set</th>
</tr>
</thead>
<tbody><tr>
<td>数据描述符</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>存取描述符</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<h5 id="数据属性："><a href="#数据属性：" class="headerlink" title="数据属性："></a>数据属性：</h5><pre><code class="js">var obj = {};
Object.defineProperty(obj, &quot;key&quot;, {
  enumerable: false,
  configurable: false,
  writable: false,
  value: &quot;static&quot;
});</code></pre>
<h5 id="访问器属性："><a href="#访问器属性：" class="headerlink" title="访问器属性："></a>访问器属性：</h5><pre><code class="js">var obj = {
  _year:2001,
  get year() {
    return this._year;
  },
  set year(val){
    this._year = val
  }
}
console.log(obj._year); //2001
console.log(obj.year); //2001
obj.year = &#39;hello&#39;;
console.log(obj._year); // hello
console.log(obj.year); // hello</code></pre>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><h5 id="为什么要事件委托："><a href="#为什么要事件委托：" class="headerlink" title="为什么要事件委托："></a>为什么要事件委托：</h5><ul>
<li>绑定事件越多，浏览器内存占用越大，严重影响性能。</li>
<li>ajax的出现，局部刷新的盛行，导致每次加载完，都要重新绑定事件</li>
<li>部分浏览器移除元素时，绑定的事件并没有被及时移除，导致的内存泄漏，严重影响性能</li>
<li>大部分ajax局部刷新的，只是显示的数据，而操作却是大部分相同的，重复绑定，会导致代码的耦合性过大，严重影响后期的维护。</li>
</ul>
<h5 id="事件委托的简单实现："><a href="#事件委托的简单实现：" class="headerlink" title="事件委托的简单实现："></a>事件委托的简单实现：</h5><pre><code class="js">function _addEvent(obj,type,fn){
    obj.addEventListener(type,fn,false);
}
function _delegate(obj,tag,fn){
    function cb(e){
        var target = e.target || e.srcElement;
        var tags = obj.getElementsByTagName(tag);
        if(tags.length === 0){return;}
        while(e.nodeName.toLowerCase() !== tag){
            target = target.parentNode;
        }
        for(var i = 0; i &lt; tags.length; i++){
            if(tags[i] === target){
                alert(i);
                break;
            }
        }
    }
    _addEvent(obj,&quot;click&quot;,cb);
}</code></pre>
<h5 id="事件委托的缺点："><a href="#事件委托的缺点：" class="headerlink" title="事件委托的缺点："></a>事件委托的缺点：</h5><p>通过jQuery的源码可以获知，事件委托的性能受下面三个因素所影响：</p>
<ul>
<li>DOM遍历的次数</li>
<li>DOM结构的层数</li>
<li>事件委托绑定的个数</li>
</ul>
<h5 id="提高事件委托性能的解决方案："><a href="#提高事件委托性能的解决方案：" class="headerlink" title="提高事件委托性能的解决方案："></a>提高事件委托性能的解决方案：</h5><ul>
<li>降低层级，尽量在父级绑定</li>
<li>减少绑定的次数</li>
</ul>
<h2 id="图片预加载与懒加载"><a href="#图片预加载与懒加载" class="headerlink" title="图片预加载与懒加载"></a>图片预加载与懒加载</h2><h5 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h5><p>######方法一：用CSS和JavaScript实现预加载<br>使用纯CSS:</p>
<pre><code class="css">background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px; }  </code></pre>
<p>使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。</p>
<pre><code class="js">function preloader() {
    if (document.getElementById) {
        document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(http://domain.tld/image-01.png) no-repeat -9999px -9999px&quot;;
    }
}
function addLoadEvent(func) {
    var oldonload = window.onload;
    if (typeof window.onload != &#39;function&#39;) {
        window.onload = func;
    } else {
        window.onload = function() {
            if (oldonload) {
                oldonload();
            }
            func();
        }
    }
}
addLoadEvent(preloader);</code></pre>
<h6 id="方法二：仅使用JavaScript实现预加载"><a href="#方法二：仅使用JavaScript实现预加载" class="headerlink" title="方法二：仅使用JavaScript实现预加载"></a>方法二：仅使用JavaScript实现预加载</h6><p>上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。</p>
<pre><code class="js">var images = new Array()
function preload() {
    for (i = 0; i &lt; preload.arguments.length; i++) {
        images[i] = new Image()
        images[i].src = preload.arguments[i]
    }
}
preload(
    &quot;http://domain.tld/gallery/image-001.jpg&quot;,
    &quot;http://domain.tld/gallery/image-002.jpg&quot;,
    &quot;http://domain.tld/gallery/image-003.jpg&quot;)</code></pre>
<h6 id="方法三：使用Ajax实现预加载"><a href="#方法三：使用Ajax实现预加载" class="headerlink" title="方法三：使用Ajax实现预加载"></a>方法三：使用Ajax实现预加载</h6><pre><code class="js">window.onload = function() {
setTimeout(function() {
    // XHR to request a JS and a CSS
    var xhr = new XMLHttpRequest();
    xhr.open(&#39;GET&#39;, &#39;http://domain.tld/preload.js&#39;);
    xhr.send(&#39;&#39;);
    xhr = new XMLHttpRequest();
    xhr.open(&#39;GET&#39;, &#39;http://domain.tld/preload.css&#39;);
    xhr.send(&#39;&#39;);
    // preload image
    new Image().src = &quot;http://domain.tld/preload.png&quot;;
}, 1000);
};</code></pre>
<h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5><ul>
<li>第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟。</li>
<li>第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。</li>
<li>第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现。</li>
</ul>
<pre><code class="js">(function($) {
    $.fn.scrollLoading = function(options) {
        var defaults = {
            attr: &quot;data-url&quot;,
            container: $(window),
            callback: $.noop
        };
        var params = $.extend({}, defaults, options || {});
        params.cache = [];
        $(this).each(function() {
            var node = this.nodeName.toLowerCase(), url = $(this).attr(params[&quot;attr&quot;]);
            var data = {
                obj: $(this),
                tag: node,
                url: url
            };
            params.cache.push(data);
        });
        var callback = function(call) {
            if ($.isFunction(params.callback)) {
                params.callback.call(call.get(0));
            }
        };
        var loading = function() {
            var contHeight = params.container.height();
            if ($(window).get(0) === window) {
                contop = $(window).scrollTop();
            } else {
                contop = params.container.offset().top;
            }
            $.each(params.cache, function(i, data) {
                var o = data.obj, tag = data.tag, url = data.url, post, posb;
                if (o) {
                    post = o.offset().top - contop, post + o.height();
                    if (o.is(&#39;:visible&#39;) &amp;&amp; (post &gt;= 0 &amp;&amp; post &lt; contHeight) || (posb &gt; 0 &amp;&amp; posb &lt;= contHeight)) {
                        if (url) {
                            if (tag === &quot;img&quot;) {
                                callback(o.attr(&quot;src&quot;, url));
                            } else {
                                o.load(url, {}, function() {
                                    callback(o);
                                });
                            }
                        } else {
                            callback(o);
                        }
                        data.obj = null;
                    }
                }
            });
        };
        loading();
        params.container.bind(&quot;scroll&quot;, loading);
    };
})(jQuery);</code></pre>
<h2 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h2><ul>
<li>mouseover 事件具有冒泡特性，也就是说无论鼠标是从别的元素移动到element或者是从element的子元素移动到element都会触发mouseover事件。</li>
<li>mouseenter 事件，该事件没有冒泡特性，也就是说只有鼠标穿过该事件的时候才会触发mouseenter</li>
</ul>
<h6 id="mouseover-模拟-mouseenter"><a href="#mouseover-模拟-mouseenter" class="headerlink" title="mouseover 模拟 mouseenter"></a>mouseover 模拟 mouseenter</h6><pre><code class="js">var selector = document.getElementById(&#39;test&#39;);
  selector.addEventListener(&quot;mouseover&quot;, function( event ) {
    var target = event.target,
        related = event.relatedTarget,//触发事件前所在的节点
        match;
    // 通过触发事件节点找到绑定事件节点
    while ( target &amp;&amp; target !== document &amp;&amp; target!== this ) {
        target = target.parentNode;
        if (target === this) {match = true;}
    }
    // 没找到绑定事件的节点
    if ( !match ) { return; }
    // 判断是不是冒泡触发的节点，如果是则related置为target
    while ( related &amp;&amp; related != target &amp;&amp; related != document ) {
        related = related.parentNode;
    }
    // 冒泡触发，也就是子节点触发
    if ( related == target ) { return; }

    //......mouseenter事件代码
  }, false);
</code></pre>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><pre><code class="js">function f1(){
    var n = [1,2];
    add = function(){
        n.unshift(0);
        return n;
    }
    function f2(){
        n.push(3);
        return n;
    }
    return f2;
}
var result1 = f1();//拷贝一份
var result2 = f1();//拷贝一份
var result3 = f1();//拷贝一份
var a1 = result1();add();console.log(a1);//[1, 2, 3]
var a2 = result2();add();console.log(a2);//[1, 2, 3]
var a3 = result3();add();console.log(a3);//[0, 0, 0, 1, 2, 3]
var a4 = add();
console.log(a1 === a2);//false
console.log(a2 === a3);//false
console.log(a3 === a4);//true</code></pre>
<h2 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h2><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>使用new命令时，它后面的函数依次执行下面的步骤。</p>
<ul>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的prototype属性。</li>
<li>将这个空对象赋值给函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ul>
<p>实现代码：</p>
<pre><code class="js">function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {
  // 将 arguments 对象转为数组
  var args = [].slice.call(arguments);
  // 取出构造函数
  var constructor = args.shift();
  // 创建一个空对象，继承构造函数的 prototype 属性
  var context = Object.create(constructor.prototype);
  // 执行构造函数
  var result = constructor.apply(context, args);
  // 如果返回结果是对象，就直接返回，否则返回 context 对象
  return (typeof result === &#39;object&#39; &amp;&amp; result != null) ? result : context;
}
// 实例
var actor = _new(Person, &#39;张三&#39;, 28);</code></pre>
<h5 id="保证构造函数使用new"><a href="#保证构造函数使用new" class="headerlink" title="保证构造函数使用new"></a>保证构造函数使用new</h5><h6 id="方法一，严格模式"><a href="#方法一，严格模式" class="headerlink" title="方法一，严格模式"></a>方法一，严格模式</h6><pre><code class="js">function Fubar(foo, bar){
  &#39;use strict&#39;;
  this._foo = foo;
  this._bar = bar;
}
Fubar()
// TypeError: Cannot set property &#39;_foo&#39; of undefined</code></pre>
<h6 id="方法二，new-target"><a href="#方法二，new-target" class="headerlink" title="方法二，new.target"></a>方法二，new.target</h6><pre><code class="js">function f() {
  if (!new.target) {
    throw new Error(&#39;请使用 new 命令调用！&#39;);
  }
  // ...
}
f() // Uncaught Error: 请使用 new 命令调用！</code></pre>
<h2 id="call-、-apply-、bind-的实现"><a href="#call-、-apply-、bind-的实现" class="headerlink" title="call 、 apply 、bind 的实现"></a>call 、 apply 、bind 的实现</h2><h5 id="call-的实现"><a href="#call-的实现" class="headerlink" title="call 的实现"></a>call 的实现</h5><pre><code class="js">if(!Function.prototype.call){
    Function.prototype.call = function(args){
        if (typeof this !== &quot;function&quot;) {
            throw Error(&quot;函数才能调用call方法&quot;);
        }
        //this绑定的指向
        var context = arguments[0];
        //调用call的函数
        var fn = this;
        //call调用时的传参
        var param = Array.prototype.slice.call(arguments,1);
        //创建一个唯一key;
        var key = &#39;fn&#39; + Math.random();
        if (context == undefined) {
            //return eval(&quot;fn(&quot; + param + &quot;)&quot;);
            return fn(...param);
        }else{
            //保证是对象
            context = Object(context);
            //将函数变为context的方法
            context[key] = fn;
            //通过对象方法的形式调用
            //return eval(&quot;context[key](&quot; + param + &quot;)&quot;);
            return context[key](...param);
        }
    }
}</code></pre>
<h5 id="apply-的实现"><a href="#apply-的实现" class="headerlink" title="apply 的实现"></a>apply 的实现</h5><pre><code class="js">if(!Function.prototype.apply){
    Function.prototype.myapply = function(args){
        if (typeof this !== &quot;function&quot;) {
            throw Error(&quot;函数才能调用appy方法&quot;);
        }
        //this绑定的指向
        var context = arguments[0];
        //调用apply的函数
        var fn = this;
        //apply调用时的传参
        var param = arguments[1] instanceof Array ? arguments[1] : [];
        //创建一个唯一key;
        var key = &#39;fn&#39; + Math.random();
        if (context == undefined) {
            //return eval(&quot;fn(&quot; + param + &quot;)&quot;);
            return fn(...param);
        }else{
            //保证是对象
            context = Object(context);
            //将函数变为context的方法
            context[key] = fn;
            //通过对象方法的形式调用
            //return eval(&quot;context[key](&quot; + param + &quot;)&quot;);
            return context[key](...param);
        }
    }
}</code></pre>
<h5 id="bind-的实现"><a href="#bind-的实现" class="headerlink" title="bind 的实现"></a>bind 的实现</h5><pre><code class="js">if (!Function.prototype.bind) {
    Function.prototype.mybind = function(args){
        if (typeof this !== &quot;function&quot;) {
            throw Error(&quot;函数才能调用bind方法&quot;);
        }
        //this绑定的指向
        var context = arguments[0];
        //调用bind的函数
        var fn = this;
        //bind调用时的传参
        var param = Array.prototype.slice.call(arguments,1);
        //返回的函数，等待下一步调用
        var callback = function(){
            //判断callback是直接调用还是new调用
            fn.apply(this instanceof callback ? this : context,
                //合并参数
                param.concat(Array.prototype.slice.call(arguments))
            );
        }
        //维护原型关系
        if (fn.prototype) {
            callback.prototype = Object.create(fn.prototype);
        }
        //返回待调用的函数
        return callback;
    }
}</code></pre>
<h2 id="异步加载js的方法"><a href="#异步加载js的方法" class="headerlink" title="异步加载js的方法"></a>异步加载js的方法</h2><p>defer属性和async属性到底应该使用哪一个？</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。</p>
<p>如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。</p>
<h5 id="defer："><a href="#defer：" class="headerlink" title="defer："></a>defer：</h5><p>有了defer属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在DOMContentLoaded事件触发前执行（即刚刚读取完</html>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>
<p>对于内置而不是加载外部脚本的script标签，以及动态生成的script标签，defer属性不起作用。</p>
<ul>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有defer属性的script元素。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载script元素加载的外部脚本。</li>
<li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li>
</ul>
<h5 id="async"><a href="#async" class="headerlink" title="async:"></a>async:</h5><p>async属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。</p>
<ul>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有async属性的script标签。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载script标签中的外部脚本。</li>
<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li>
<li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li>
</ul>
<h5 id="ES6-模块-type-”module”"><a href="#ES6-模块-type-”module”" class="headerlink" title="ES6 模块(type=”module”)"></a>ES6 模块(type=”module”)</h5><p>浏览器对于带有type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。</p>
<p><code>&lt;script&gt;</code>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<h5 id="动态创建script标签"><a href="#动态创建script标签" class="headerlink" title="动态创建script标签"></a>动态创建script标签</h5><h2 id="Ajax解决浏览器的缓存问题"><a href="#Ajax解决浏览器的缓存问题" class="headerlink" title="Ajax解决浏览器的缓存问题"></a>Ajax解决浏览器的缓存问题</h2><p>Ajax能提高页面载入速度的主要原因是通过Ajax减少了重复数据的载入，也即在载入数据的同时将数据缓存到内存中，一旦数据被加载，只要没有刷新页面，这些数据就会一直被缓存在内存中，当提交的URL与历史的URL一致时，就不需要提交给服务器，也即不需要从服务器获取数据，虽然降低了服务器的负载，提高了用户体验，但不能获取最新的数据。为了保证读取的信息都是最新的，需要禁止其缓存功能。</p>
<ul>
<li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</li>
<li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</li>
<li>在URL后面加上一个随机数： “fresh=” + Math.random()。</li>
<li>在URL后面加上时间搓：”nowtime=” + new Date().getTime()。</li>
<li>如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</li>
</ul>
<h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><h5 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h5><p>根据用户输入信息发请求的时候，为了防止频繁触发请求，需要等待用户最后输入的时候再发送请求，也就是防抖：</p>
<pre><code class="js">function debounce(fn,delay){
    //利用闭包，保留定时器的指引
    var timer = null;
    return function(){
        //每调用一次就取消上一次回调。
        clearTimeout(timer);
        //重新开启定时器，过一段时间后若无操作，则执行回调
        timer = setTimeout(fn,delay)
    }
}
var scroll = debounce(function(){
    console.log(&#39;do something!!!&#39;)
},500)
window.onscroll = scroll;</code></pre>
<h5 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h5><p>当滚动鼠标时，因为滚动事件触发间隔极短，需要限制其在某个时间段内，只执行一次。</p>
<pre><code class="js">function throttle(fn,interval){
    //设定初始时间
    var begin = new Date();
    //定时器指引
    var timer = null;
    return function(){
        //总是清除上一次回调
        clearTimeout(timer);
        //获取当前时间
        var now = new Date();
        //当时间间隔大于设定，执行回调
        if (now - begin &gt; interval) {
            //重置开始时间
            begin = now;
            fn();
        }else{
            timer = setTimeout(function(){
                //若距离上一次触发大于时间间隔，执行一次回调
                begin = now;
                fn();
            },interval)
        }
    }
}
var scroll = throttle(function(){
    console.log(&#39;do something!!!&#39;)
},500)
window.onscroll = scroll;</code></pre>
<h2 id="js监听对象属性的改变"><a href="#js监听对象属性的改变" class="headerlink" title="js监听对象属性的改变"></a>js监听对象属性的改变</h2><h5 id="在ES5中可以通过Object-defineProperty来实现已有属性的监听"><a href="#在ES5中可以通过Object-defineProperty来实现已有属性的监听" class="headerlink" title="在ES5中可以通过Object.defineProperty来实现已有属性的监听"></a>在ES5中可以通过Object.defineProperty来实现已有属性的监听</h5><pre><code class="js">Object.defineProperty(user,&#39;name&#39;,{
    set：function(key,value){
    }
})</code></pre>
<p>缺点：如果属性不在user对象中，则不能监听该属性的变化</p>
<h5 id="在ES6中可以通过Proxy来实现"><a href="#在ES6中可以通过Proxy来实现" class="headerlink" title="在ES6中可以通过Proxy来实现"></a>在ES6中可以通过Proxy来实现</h5><pre><code class="js">var  user = new Proxy({}，{
 set：function(target,key,value,receiver){
  }
})</code></pre>
<p>这样即使有属性在user中不存在，通过user.id来定义也同样可以这样监听这个属性的变化。</p>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h2><pre><code class="js">// 特例
Object.is(0, -0);            // false
Object.is(-0, -0);           // true
Object.is(NaN, 0/0);         // true

if (!Object.is) {
  Object.is = function(x, y) {
    if (x === y) {
      // +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // NaN == NaN
      return x !== x &amp;&amp; y !== y;
    }
  };
}</code></pre>
<h2 id="requestAnimationFrame-与-cancelAnimationFrame"><a href="#requestAnimationFrame-与-cancelAnimationFrame" class="headerlink" title="requestAnimationFrame 与 cancelAnimationFrame"></a>requestAnimationFrame 与 cancelAnimationFrame</h2><p>大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms</p>
<p>而setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。</p>
<p>requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p>
<p>特点</p>
<ul>
<li>requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量</li>
<li>requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销</li>
</ul>
<pre><code class="js">var a = 1;
var cb = function(){
    console.log(a++);
    if (a &gt; 100) {
        cancelAnimationFrame(timer);
    }else{
        requestAnimationFrame(cb)
    }
}
var timer = requestAnimationFrame(cb);</code></pre>
<h2 id="用-setTimeout-模拟-setInterval"><a href="#用-setTimeout-模拟-setInterval" class="headerlink" title="用 setTimeout 模拟 setInterval"></a>用 setTimeout 模拟 setInterval</h2><pre><code class="js">function interval(func, wait, times){
    var interv = function(w, t){
        return function(){
            if(typeof t === &quot;undefined&quot; || t-- &gt; 0){
                setTimeout(interv, w);
                try{
                    func.call(null);
                }
                catch(e){
                    t = 0;
                    throw e.toString();
                }
            }
        };
    }(wait, times);
    setTimeout(interv, wait);
};</code></pre>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><ul>
<li>先主线程，后任务队列；</li>
<li>先微任务（promise,nextTick），后宏任务(setTimeout)；</li>
<li>先nextTick，后promise（then）</li>
</ul>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h6 id="利用对象的属性不能相同（有漏洞，数组值是引用类型时做键值会先调用toString）"><a href="#利用对象的属性不能相同（有漏洞，数组值是引用类型时做键值会先调用toString）" class="headerlink" title="利用对象的属性不能相同（有漏洞，数组值是引用类型时做键值会先调用toString）"></a>利用对象的属性不能相同（有漏洞，数组值是引用类型时做键值会先调用toString）</h6><pre><code class="js">Array.prototype.distinct = function (){
 var arr = this,
  i,
  obj = {},
  result = [],
  len = arr.length;
 for(i = 0; i&lt; arr.length; i++){
  if(!obj[arr[i]]){ //如果能查找到，证明数组元素重复了
   obj[arr[i]] = 1;
   result.push(arr[i]);
  }
 }
 return result;
};
var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,];
var b = a.distinct();</code></pre>
<h6 id="利用indexOf以及forEach"><a href="#利用indexOf以及forEach" class="headerlink" title="利用indexOf以及forEach"></a>利用indexOf以及forEach</h6><h6 id="利用数组sort方法先排序"><a href="#利用数组sort方法先排序" class="headerlink" title="利用数组sort方法先排序"></a>利用数组sort方法先排序</h6><pre><code class="js">Array.prototype.distinct = function(){
 var len = this.length,res = [];
 if(len &lt; 2){ return this;}
 this.sort(); //先排序
 for(var i = 0; i &lt; len - 1; i++){
  if(this[i] !== this[i+1]){
   res.push(this[i]);
  }
 }
 //最后那位不会重复
 res.push(this[this.length-1])
 return res;
}</code></pre>
<h6 id="利用ES6的set"><a href="#利用ES6的set" class="headerlink" title="利用ES6的set"></a>利用ES6的set</h6><pre><code class="js">//利用Array.from将Set结构转换成数组
function dedupe(array){
 return Array.from(new Set(array));
}
dedupe([1,1,2,3]);

//拓展运算符(...)内部使用for...of循环
let arr = [1,2,3,3];
let resultarr = [...new Set(arr)];
console.log(resultarr); //[1,2,3]</code></pre>
<pre><code class="js">Array.prototype.distinct = function (){
 var arr = this,
  result = [],
  len = arr.length;
 arr.forEach(function(v, i ,arr){  //这里利用map，filter方法也可以实现
  var bool = arr.indexOf(v,i+1);  //从传入参数的下一个索引值开始寻找是否存在重复
  if(bool === -1){
   result.push(v);
  }
 })
 return result;
};
var a = [1,1,1,1,1,1,1,2,3,2,3,2,3];
var b = a.distinct();</code></pre>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><pre><code class="js">function swap(arr,i,j){
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

//冒泡排序
function bubbleSort(arr){
    for (var i = arr.length - 1; i &gt; 0; i--) {
        for (var j = 0; j &lt; i; j++) {
            if (arr[j] &gt; arr[j+1]) {
                swap(arr,j,j+1)
            }
        }
    }
    return arr;
}</code></pre>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><pre><code class="js">//选择排序
function selectionSort(arr){
    for (var i = 0; i &lt; arr.length - 1; i++) {
        var index = i;
        for (var j = i + 1; j &lt; arr.length; j++) {
            if (arr[j] &lt; arr[index]) {
                index = j;
            }
        }
        swap(arr,i,index);
    }
    return arr;
}</code></pre>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><pre><code class="js">//插入排序
function insertionSort(arr){
    for (var i = 1; i &lt; arr.length; i++) {
        var temp = arr[i];
        var j = i;
        while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp){
            swap(arr,j,j-1);
            j--;
        }
    }
    return arr;
}</code></pre>
<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><pre><code class="js">//希尔排序
function shellSort(arr){
    var interval = Math.floor(arr.length/2);
    while(interval &gt; 0){
        for (var i = 0; i &lt; interval; i++) {
            for (var j = i + interval; j &lt; arr.length; j = j + interval) {
                var temp = arr[j];
                var index = j;
                while(index &gt; 0 &amp;&amp; arr[index - interval] &gt; temp){
                    swap(arr,index,index - interval);
                    index = index - interval;
                }
            }
        }
        if (interval == 1) {
            return arr;
        }
        interval = Math.floor(interval/3) + 1;
    }
    return arr;
}</code></pre>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><pre><code class="js">//归并排序

function mergeSort(arr){
    if (arr.length &lt; 2) {return;}
    var step = 1;
    var left,right;
    while(step &lt; arr.length){
        left = 0;
        right = step;
        while(right + step &lt;= arr.length) {
            mergeArr(arr,left,left+step,right,right+step);
            left = right + step;
            right = left + step;
        }
        if (right &lt; arr.length) {
            mergeArr(arr,left,left+step,right,arr.length)
        }
        step *= 2;
    }
    return arr;
}

function mergeArr(arr, startLeft, stopLeft, startRight, stopRight){
    var leftArr = new Array(stopLeft - startLeft + 1);
    var rightArr = new Array(stopRight - startRight + 1);
    var k = startLeft;
    for (var i = 0; i &lt; leftArr.length; i++) {
        leftArr[i] = arr[k++];
    }
    k = startRight;
    for (var i = 0; i &lt; rightArr.length; i++) {
        rightArr[i] = arr[k++];
    }
    rightArr[rightArr.length-1] = Infinity; // 哨兵值
    leftArr[leftArr.length-1] = Infinity; // 哨兵值
    var n = 0,m = 0;
    for (var i = startLeft; i &lt; stopRight; i++) {
        if (leftArr[m] &gt; rightArr[n]) {
            arr[i] = rightArr[n++];
        }else{
            arr[i] = leftArr[m++];
        }
    }
}</code></pre>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><pre><code class="js">//快速排序
function qSort(list) {
    if (list.length == 0) {
        return [];
    }
    var lesser = [];
    var greater = [];
    var pivot = list[0];
    for (var i = 1; i &lt; list.length; i++) {
        if (list[i] &lt; pivot) {
            lesser.push(list[i]);
        } else {
            greater.push(list[i]);
        }
    }
    return qSort(lesser).concat(pivot, qSort(greater));
}

//递归型
function recurQuickSort(arr,startIndex,endIndex){
    if (startIndex &gt;= endIndex) {return;}
    var pivotIndex = partition(arr,startIndex,endIndex);
    recurQuickSort(arr,startIndex,pivotIndex);
    recurQuickSort(arr,pivotIndex + 1,endIndex);
    return arr;
}

//非递归型
function  quickSort(arr){
    var stack = [];
    var param = {
        start:0,
        end:arr.length - 1
    }
    stack.push(param);
    while(stack.length &gt; 0){
        var curParam = stack.pop();
        var pivotIndex = partition(arr,curParam.start,curParam.end);
        if (curParam.start &lt; pivotIndex) {
            stack.push({
                start:curParam.start,
                end:pivotIndex
            })
        }
        if (curParam.end &gt; pivotIndex) {
            stack.push({
                start:pivotIndex + 1,
                end:curParam.end
            })
        }
    }
    return arr;
}

//交换左右位置
function partition(arr,startIndex,endIndex){
    var pivot = arr[startIndex];
    var start = startIndex,end = endIndex;
    while(start &lt; end){
        while(start &lt; end){
            if (arr[end] &lt; pivot) {
                break;
            }else{
                end--;
            }
        }
        while(start &lt; end){
            if (arr[start] &gt; pivot) {
                break;
            }else{
                start++;
            }
        }
        swap(arr,start,end);
    }
    swap(arr,startIndex,start);
    return start;
}</code></pre>
<h2 id="javascript-中常见的内存泄露陷阱"><a href="#javascript-中常见的内存泄露陷阱" class="headerlink" title="javascript 中常见的内存泄露陷阱"></a><a href="http://web.jobbole.com/88463/" target="_blank" rel="noopener">javascript 中常见的内存泄露陷阱</a></h2><ul>
<li>意外的全局变量</li>
<li>被遗漏的定时器和回调函数，回调函数中保持着外部变量的引用</li>
<li>js对DOM 的引用，即使该DOM节点被移除，若依然保持着引用，则该DOM节点依然在内存中</li>
<li>闭包</li>
</ul>
<h2 id="babel把ES6转成ES5或者ES3之类的原理"><a href="#babel把ES6转成ES5或者ES3之类的原理" class="headerlink" title="babel把ES6转成ES5或者ES3之类的原理"></a>babel把ES6转成ES5或者ES3之类的原理</h2><p>它就是个编译器，输入语言是ES6+，编译目标语言是ES5。</p>
<ul>
<li>解析：将代码字符串解析成抽象语法树</li>
<li>变换：对抽象语法树进行变换操作</li>
<li>再建：根据变换后的抽象语法树再生成代码字符串</li>
</ul>
<h2 id="前端工程与性能优化"><a href="#前端工程与性能优化" class="headerlink" title="前端工程与性能优化"></a>前端工程与性能优化</h2><table>
<thead>
<tr>
<th>优化方向</th>
<th>优化手段</th>
</tr>
</thead>
<tbody><tr>
<td>请求数量</td>
<td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</td>
</tr>
<tr>
<td>请求带宽</td>
<td>开启GZip，精简JavaScript，移除重复脚本，图像优化</td>
</tr>
<tr>
<td>缓存利用</td>
<td>使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</td>
</tr>
<tr>
<td>页面结构</td>
<td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td>
</tr>
<tr>
<td>代码校验</td>
<td>避免CSS表达式，避免重定向</td>
</tr>
</tbody></table>
<h2 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h2><ul>
<li>CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用</li>
<li>CommonJS 模块是运行时加载，ES6模块是编译时输出接口</li>
<li>ES6输入的模块变量，只是一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错</li>
</ul>
<p>CommonJs所谓值的拷贝类似于对module.exports对象的一个浅拷贝，基本类型值无法被修改，引用类型值则依然保存着对模块的引用，类似闭包。</p>
<p>ES6模块输出的是值的引用，指的是import的对象保存着对模块的作用域的引用，并且该作用域是可以共享的。换句话说ES6模块export唯一一个实例，被所有import的对象共享。</p>
<h5 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h5><p>Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。</p>
<pre><code class="js">// a.js
module.exports = {
  foo: &#39;hello&#39;,
  bar: &#39;world&#39;
};
// 等同于
export default {
  foo: &#39;hello&#39;,
  bar: &#39;world&#39;
};</code></pre>
<h5 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h5><p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</p>
<pre><code class="js">// es.js
export let foo = { bar:&#39;my-default&#39; };
export { foo as bar };
export function f() {};
export class c {};

// cjs.js
const es_namespace = await import(&#39;./es&#39;);
// es_namespace = {
//   get foo() {return foo;}
//   get bar() {return foo;}
//   get f() {return f;}
//   get c() {return c;}
// }</code></pre>
<h2 id="浅拷贝和深拷贝的问题"><a href="#浅拷贝和深拷贝的问题" class="headerlink" title="浅拷贝和深拷贝的问题"></a>浅拷贝和深拷贝的问题</h2><ul>
<li>深拷贝和浅拷贝是只针对Object和Array这样的复杂类型的</li>
<li>也就是说a和b指向了同一块内存，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</li>
<li>浅拷贝， ”Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象</li>
<li>深拷贝，JSON.parse()和JSON.stringify()给了我们一个基本的解决办法。但是函数不能被正确处理</li>
</ul>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><pre><code class="js">function curry(fn){
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return fn.apply(null, finalArgs);
    };
}</code></pre>
<h2 id="原生Ajax书写"><a href="#原生Ajax书写" class="headerlink" title="原生Ajax书写"></a>原生Ajax书写</h2><pre><code class="js">function createXHR(){
    if (typeof XMLHttpRequest != &quot;undefined&quot;){
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != &quot;undefined&quot;){
        var versions = [ &quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],
        i, len,xml;
        for (i=0,len=versions.length; i &lt; len; i++){
            try {
                xml = new ActiveXObject(versions[i]);
                break;
            } catch (ex){//跳过
            }
        }
        return xml;
    } else {
        throw new Error(&quot;No XHR object available.&quot;);
    }
}
var xhr = createXHR();
xhr.onreadystatechange = function(){
    // 通信成功时，状态值为4
    if (xhr.readyState === 4){
          if (xhr.status === 200){
              console.log(xhr.responseText);
          } else {
              console.error(xhr.statusText);
          }
    }
};
xhr.onerror = function (e) {
    console.error(xhr.statusText);
};
xhr.open(&#39;GET&#39;, &#39;/endpoint&#39;, true);
xhr.send(null);</code></pre>
<h2 id="ES5继承与Class继承的区别"><a href="#ES5继承与Class继承的区别" class="headerlink" title="ES5继承与Class继承的区别"></a>ES5继承与Class继承的区别</h2><p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。</p>
<p>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
]]></content>
  </entry>
  <entry>
    <title>前端面试经典问题汇总-HTTP篇</title>
    <url>/article/2020/01/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB-HTTP%E7%AF%87.html</url>
    <content><![CDATA[<h2 id="GET与POST请求的区别"><a href="#GET与POST请求的区别" class="headerlink" title="GET与POST请求的区别"></a>GET与POST请求的区别</h2><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p>
<p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP连接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p>
<p>为什么GET与POST请求还有这么多差异呢？根源在于浏览器与服务器的限制。</p>
<h5 id="缓存上的区别"><a href="#缓存上的区别" class="headerlink" title="缓存上的区别"></a><strong>缓存上的区别</strong></h5><ul>
<li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li>
<li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li>
</ul>
<h5 id="安全上的区别"><a href="#安全上的区别" class="headerlink" title="安全上的区别"></a><strong>安全上的区别</strong></h5><ul>
<li>查询字符串（名称/值对）是在 GET 请求的 URL 中发送的，有安全问题。</li>
<li>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的，因此安全性较get高</li>
</ul>
<p><strong>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。</strong></p>
<p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p>
<ul>
<li>HTTP 协议 未规定 GET 和POST的长度限制</li>
<li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li>
<li>不同的浏览器和WEB服务器，限制的最大长度不一样</li>
<li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>有关 GET 请求的其他一些注释：</p>
<ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据</li>
</ul>
<p>有关 POST 请求的其他一些注释：</p>
<ul>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求</li>
</ul>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a><a href="http://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">浏览器缓存</a></h2><p>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；</p>
<p>区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>
<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。</p>
<ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</li>
</ul>
<h6 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h6><p>在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</li>
</ul>
<p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p>
<p>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。</p>
<h5 id="强缓存的管理"><a href="#强缓存的管理" class="headerlink" title="强缓存的管理"></a>强缓存的管理</h5><p>通常有2种方式来设置是否启用强缓存：</p>
<ul>
<li>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li>
<li>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</li>
</ul>
<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。</p>
<h6 id="Last-Modified，If-Modified-Since"><a href="#Last-Modified，If-Modified-Since" class="headerlink" title="Last-Modified，If-Modified-Since"></a>Last-Modified，If-Modified-Since</h6><ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间；</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值；</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</li>
</ul>
<h6 id="ETag、If-None-Match"><a href="#ETag、If-None-Match" class="headerlink" title="ETag、If-None-Match"></a>ETag、If-None-Match</h6><ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系；</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值；</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化；</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
</ul>
<h5 id="协商缓存的管理"><a href="#协商缓存的管理" class="headerlink" title="协商缓存的管理"></a>协商缓存的管理</h5><p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。</p>
<p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p>
<p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</p>
<h5 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h5><ul>
<li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</li>
</ul>
<h2 id="OPTIONS请求方法"><a href="#OPTIONS请求方法" class="headerlink" title="OPTIONS请求方法"></a>OPTIONS请求方法</h2><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<ul>
<li>获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。</li>
<li>用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。</li>
</ul>
<h2 id="前端工程与性能优化"><a href="#前端工程与性能优化" class="headerlink" title="前端工程与性能优化"></a>前端工程与性能优化</h2><table>
<thead>
<tr>
<th>优化方向</th>
<th>优化手段</th>
</tr>
</thead>
<tbody><tr>
<td>请求数量</td>
<td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</td>
</tr>
<tr>
<td>请求带宽</td>
<td>开启GZip，精简JavaScript，移除重复脚本，图像优化</td>
</tr>
<tr>
<td>缓存利用</td>
<td>使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</td>
</tr>
<tr>
<td>页面结构</td>
<td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td>
</tr>
<tr>
<td>代码校验</td>
<td>避免CSS表达式，避免重定向</td>
</tr>
</tbody></table>
<h2 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h2><ul>
<li>CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用</li>
<li>CommonJS 模块是运行时加载，ES6模块是编译时输出接口</li>
<li>ES6输入的模块变量，只是一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错</li>
</ul>
<h2 id="http-与-https"><a href="#http-与-https" class="headerlink" title="http 与 https"></a>http 与 https</h2><h5 id="http的不足："><a href="#http的不足：" class="headerlink" title="http的不足："></a>http的不足：</h5><ul>
<li>通信使用明文，可能会被窃听</li>
<li>不验证通信方的身份，可能遭遇伪装</li>
<li>无法证明报文的完整性，可能遭遇篡改</li>
</ul>
<h5 id="何为https"><a href="#何为https" class="headerlink" title="何为https?"></a>何为https?</h5><p><strong>http + 加密 + 验证 + 完整性保护 = https</strong></p>
<h5 id="https的原理"><a href="#https的原理" class="headerlink" title="https的原理"></a>https的原理</h5><p>https并非应用层上一种新的协议，而是http通信接口部分用SSL（Secure Socket Layer，安全套接层）和TLS（Transport Layer Security，传输安全协议）协议代替。</p>
<p>通常情况下，http与TCP直接通信，当使用SSL时，就演变层先跟SSL通信，再由SSL与TCP通信。</p>
<p>所谓的https，也就是身披SSL协议外壳的http。</p>
<h5 id="SSL如何加密？"><a href="#SSL如何加密？" class="headerlink" title="SSL如何加密？"></a>SSL如何加密？</h5><p>SSL使用的是一种公开密钥加密（Public-key cryptography）的加密方式。</p>
<p>加密方法中，加密算法是公开的，密钥是保密的，加密跟解密都需要用到密钥。</p>
<h6 id="共享密钥加密（Common-key-cryto-system）"><a href="#共享密钥加密（Common-key-cryto-system）" class="headerlink" title="共享密钥加密（Common key cryto system）"></a>共享密钥加密（Common key cryto system）</h6><p>加密与解密使用同一个密钥，也被称为对称密钥加密。</p>
<p>不足：密钥能够安全发送，信息也能安全发送。</p>
<h6 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h6><p>公开密钥加密使用一对非对称的密钥，一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。</p>
<p>发送密文的一方使用公开密钥加密，对方收到信息之后，再使用私有密钥解密。</p>
<h5 id="https使用混合加密机制"><a href="#https使用混合加密机制" class="headerlink" title="https使用混合加密机制"></a>https使用混合加密机制</h5><p>公开密钥加密与共享密钥加密相比，其处理速度要慢，所以需要利用其各自的优势。</p>
<p>在交换密钥阶段使用公开密钥加密的方式，之后建立通信交换报文阶段则使用共享密钥加密的方式。</p>
<h5 id="公开密钥的可靠性证明"><a href="#公开密钥的可靠性证明" class="headerlink" title="公开密钥的可靠性证明"></a>公开密钥的可靠性证明</h5><p>解决方法是，使用数据证书认证机构（CA,Certificate Authority）和其相关机构颁布的公开密钥证书。</p>
<ul>
<li>提出公开密钥申请</li>
<li>数字证书认证机构对公开密钥做数字签名，颁发公钥证书</li>
<li>服务器发送公钥证书给客户端，进行公开密钥加密通信</li>
<li>客户端使用内置的数据证书认证机构的公开密钥，对公钥证书的数字签名进行认证。</li>
</ul>
<p>数据证书认证机构的公开密钥必须安全的转交给客户端，使用通信方式进行安全转交是一件非常困难的事情，所以，浏览器发布时，一般会事先植入认证机构的公开密钥。</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<ul>
<li>第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN-SEND状态，等待服务器B确认。</li>
<li>第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN-RECV状态。</li>
<li>第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<p>完成三次握手，客户端与服务器开始传送数据。</p>
<p>LISTEN - 侦听来自远方TCP端口的连接请求；<br>SYN-SENT -在发送连接请求后等待匹配的连接请求；<br>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；<br>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<ul>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ul>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>“信道复用技术”实现了，在同一条线路上，单位时间内可供X台计算机同时通信。</p>
<p>一个TCP协议连接其实就是在物理线路上创建的一条“虚拟信道”。这条“虚拟信道”建立后，在TCP协议发出FIN包之前（两个终端都会向对方发送一个FIN包），是不会释放的。正因为这一点，TCP协议被称为面向连接的协议！</p>
<p>UDP协议，一样会在物理线路上创建一条“虚拟信道”，否则UDP协议无法传输数据！但是，当UDP协议传完数据后，这条“虚拟信道”就被立即注销了！因此，称UDP是不面向连接的协议！</p>
<ul>
<li>TCP协议提供了可靠的数据传输,但是其拥塞控制、数据校验、重传机制的网络开销很大,不适合实时通信。</li>
<li>UDP 协议是无连接的数据传输协议并且无重传机制,会发生丢包、收到重复包、乱序等情况。而对于数据精确性要求不高的状态数据以及视频数据,丢包的影响不大。</li>
</ul>
<h2 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h2><p>WebSocket protocol 是HTML5一种新的协议。它是实现了浏览器与服务器全双工通信(full-duplex)。HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽并达到实时通讯。</p>
<p>在WebSocket出现之前，一般通过两种方式来实现Web实时用：轮询机制和流技术；其中轮询有不同的轮询，还有一种叫Comet的长轮询。</p>
<ul>
<li><p>轮询：这是最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的同步。这种同步方案的缺点是，当客户端以固定频率向服务器发起请求的时候，服务器端的数据可能并没有更新，这样会带来很多<strong>无谓的网络传输</strong>，所以这是一种非常低效的实时方案。</p>
</li>
<li><p>长轮询：是对定时轮询的改进和提高，目地是为了降低无效的网络传输。当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互。当然，如果服务端的数据变更非常频繁的话，这种机制和定时轮询比较起来没有本质上的性能的提高。</p>
</li>
<li><p>流：常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个<strong>长连接的请求</strong>。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务 器端的连接不过期。通过这种机制可以将服务器端的信息源源不断地推向客户端。这种机制在用户体验上有一点问题，需要针对不同的浏览器设计不同的方案来改进 用户体验，同时这种机制在并发比较大的情况下，对服务器端的资源是一个极大的考验。</p>
</li>
</ul>
<p>WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
]]></content>
  </entry>
  <entry>
    <title>你不知道的instanceof</title>
    <url>/article/2020/01/28/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84instanceof.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大伙看了标题，肯定是一头雾水，啥？我不知道的instancof ? 我天天都在用！还有什么不知道的？！</p>
<p>说实话，我也很担心这看似标题党的标题一语成谶，因为此篇东西确实不多。所以，自信已经知道的大佬可以绕道走，剩下的小伙伴来跟我一探究竟吧！</p>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>按照惯例，我们先来看一个小栗子：</p>
<pre><code class="js">function A(){}
var a = new A();
//100%的小伙伴做对
console.log(a instanceof A);//true
//50%的小伙伴能做对
console.log(a instanceof Object);//true</code></pre>
<p>这是 <code>instanceof</code> 最常用的一个场景。第一种情况我们就不说了，显而易见的事情，我们来看第二种情况。</p>
<h2 id="instanceof-与原型链"><a href="#instanceof-与原型链" class="headerlink" title="instanceof 与原型链"></a>instanceof 与原型链</h2><p>在看第二种情况之前，我们先来看MDN上面的定义：</p>
<blockquote>
<p><strong>instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置</strong></p>
</blockquote>
<p>说实话，我第一次看到这个定义也很懵，每一个字都能够看懂，放在一起就蒙蔽的典型。</p>
<p>现在我们来分步解析一下：</p>
<ul>
<li>构造函数的prototype，其实就是 <code>A.prototype</code></li>
<li>对象（实际就是实例）的原型链，其实就是 <code>a.__proto__</code></li>
</ul>
<p>顺着上面的代码，我们打印验证一下：</p>
<pre><code class="js">function A(){}
var a = new A();
console.log(a.__proto__ === A.prototype); //true
console.log(A.prototype.__proto__ === Object.prototype);
//上面两个组合起来
console.log(a.__proto__.__proto__ === Object.prototype); //true</code></pre>
<p>啥叫原型链？这里已经很清晰了，其实就是以一个<strong>实例为起点</strong>，<code>__proto__</code> 属性为指引，一步步延伸的一个链条。中间经历过的构造函数，都算是在该实例的原型链上。</p>
<p>为什么要在实例为起点加粗呢？请继续看下文。</p>
<h2 id="深入认识-proto"><a href="#深入认识-proto" class="headerlink" title="深入认识 __proto__"></a>深入认识 <code>__proto__</code></h2><p>通过上例，我们已经算是深入到了原型链的实质，但是很有可能认识还不够透彻，下面再看一个栗子：</p>
<pre><code class="js">function A(){}
function B(){}
var a1 = new A();
console.log(a1 instanceof A); //true
//改变原型指向
A.prototype = {constructor :B};
//被影响了，很正常
console.log(a1 instanceof A); //false
//什么鬼，constructor不是B么？
console.log(a1 instanceof B); // false
// 重新构造一个
var a2 = new A();
//什么鬼，constructor不是B么?
console.log(a2 instanceof A); //true
//好吧，99%小伙伴选择放弃！
console.log(a2 instanceof B); //false</code></pre>
<p>怎么样，刚刚还信心满满说已经理解了<code>instanceof</code>，已经理解了 <code>__proto__</code>的小伙伴在哪里呢？</p>
<p>没有做对上面题目的小伙伴，其实也不用灰心，现在我就带你们彻底了解它。</p>
<p>下面我们用原型的视角看这问题：</p>
<pre><code class="js">function A(){}
function B(){}
var a1 = new A();
console.log(a1 instanceof A); //true
console.log(a1.__proto__ === A.prototype); //true
//改变原型指向
A.prototype = {constructor :B};
//此时A.prototype地址已经修改，a1.__proto__指向不变
console.log(a1 instanceof A); //false
console.log(a1.__proto__ === A.prototype); //false
// 重新构造一个
var a2 = new A();
//a2是A最新构造的，a2.__proto__指向修改后的A.prototype
console.log(a2 instanceof A); //true
console.log(a2.__proto__ === A.prototype); //true
//证明跟原型的constructor没一点关系，只看是被哪个构造函数构造！
console.log(a2 instanceof B); //false
console.log(a2.__proto__ === B.prototype); //false</code></pre>
<p>好啦，各位有没有拨开云雾见天日，守得云开见月明的感觉呢？认真看到这里的小伙伴，应该已经算是彻底的了解了<code>instanceof</code>。若有看不懂的，可以参照<a href="http://codedoges.com/article/1536662941125" target="_blank" rel="noopener" title="大话西游之原型与继承（上）">大话西游之原型与继承（上）</a>，必能加深认识。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有的小伙伴说，不谈框架，天天搞这些无聊的东西有啥意思？其实很简单，人各有志，道不同则不与为谋。同样，每个人的技术观也不一样，并无高低贵贱之分，技术的汪洋大海中，各取一瓢罢了。</p>
]]></content>
  </entry>
  <entry>
    <title>webpack深入与实战</title>
    <url>/article/2020/01/28/webpack%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%AE%9E%E6%88%98.html</url>
    <content><![CDATA[<p>##webpack深入与实战</p>
<h4 id="一、webpack的安装"><a href="#一、webpack的安装" class="headerlink" title="一、webpack的安装"></a>一、webpack的安装</h4><ol>
<li>创建项目根目录文件夹，<code>npm init</code>，一路按回车键，初始化文件夹，此时生成默认package.json文件；</li>
<li><code>npm install webpack --save-dev -g</code>，安装webpack;此时有可能会报一下错误：<pre><code class="js">npm ERR! code ENOSELF
npm ERR! Refusing to install package with name &quot;webpack&quot; under a package
npm ERR! also called &quot;webpack&quot;. Did you name your project the same
npm ERR! as the dependency you&#39;re installing?</code></pre>
则表示项目名称与webpack冲突，只需重新npm init,回车到<code>package name</code>的时候，输入其他的名称即可；</li>
<li>此时目录下有<code>node_modules</code>、<code>package.json</code>、<code>package-lock</code>三个文件，则安装成功；</li>
<li><code>webpack hello.js hello.bundle.js</code>,即可成功开始编译文件；注如果提示==’webpack’ 不是内部或外部命令，也不是可运行的程序==，则环境变量配置有问题，全局安装即可；</li>
</ol>
<h4 id="二、webpack实例入门"><a href="#二、webpack实例入门" class="headerlink" title="二、webpack实例入门"></a>二、webpack实例入门</h4><h6 id="1，js中引入js文件"><a href="#1，js中引入js文件" class="headerlink" title="1，js中引入js文件"></a>1，js中引入js文件</h6><p>在根目录文件夹下，创建<code>hello.js</code>与<code>world.js</code>文件，在前者中引入后者，如图：</p>
<pre><code class="js">require(&quot;./world.js&quot;);
function hello (){
    alert(&quot;hello&quot;)
}</code></pre>
<p>运行<code>webpack hello.js hello.bundle.js</code>命令，即可发现根目录下生成<code>hello.bundle.js</code>文件；里面代码截图如下：</p>
<pre><code class="js">/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {
    __webpack_require__(1);
    //require(&quot;css-loader!./style.css&quot;);
    function hello (){
        alert(&quot;hello&quot;)
    }
/***/ },
/* 1 */
/***/ function(module, exports) {
    function world(){
        return {
            name:&quot;hhh&quot;
        }
    }
/***/ }
/******/ ]);</code></pre>
<p>######2、js文件中引入css文件<br>引入css文件不同于引入js，引入前需要安装相关的<code>loader</code>，否则回报错，如图：</p>
<pre><code class="js">ERROR in ./style.css
Module parse failed: C:\Users\haotengfei\Desktop\study\webpack\style.css Unexpected token (1:4)
You may need an appropriate loader to handle this file type.
SyntaxError: Unexpected token (1:4)
    at Parser.pp$4.raise (C:\Users\haotengfei\Desktop\study\webpack\node_modules\acorn\dist\acorn.js:2221:15)
    at Parser.pp.unexpected (C:\Users\haotengfei\Desktop\study\webpack\node_modules\acorn\dist\acorn.js:603:10)</code></pre>
<p>根目录下新建一个<code>style.css</code>文件，在<code>hello.js</code>文件中引入(引入方式也区别于js，注：<code>css-loader</code>让webpack可以处理css文件，<code>style-loader</code>让打包后的css起作用，插入的html中)：</p>
<pre><code class="js">require(&quot;./world.js&quot;);
require(&quot;style-loader!css-loader!./style.css&quot;);
function hello (){
    alert(&quot;hello world&quot;)
}
hello();</code></pre>
<p>先安装相关<code>loader</code>，运行<code>npm install css-loader style-loader --save-dev</code>；接着运行<code>webpack hello.js hello.bundle.js</code>，即可生成新的<code>hello.bundle.js</code>文件；如图：</p>
<pre><code class="js">/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {
    __webpack_require__(1);
    __webpack_require__(2);
    function hello (){
        alert(&quot;hello&quot;)
    }
    hello();
/***/ },
/* 1 */
/***/ function(module, exports) {
    function world(){
        return {
            name:&quot;hhh&quot;
        }
    }
/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {
    exports = module.exports = __webpack_require__(3)(false);
    // imports
    // module
    exports.push([module.id, &quot;body{\r\n\tpadding: 0;\r\n\theight: 0;\r\n}&quot;, &quot;&quot;]);
    // exports
/***/ },
/* 3 */
/***/ function(module, exports) {</code></pre>
<p>######3、这个时候，在根目录创建一个index.html文件，引入打包后的<code>hello.bundle.js</code>，即可发现弹窗<code>hello world</code>，页面也变红了，即是打包的文件涵括了所有被打包文件的功能作用；<br>######4、显而易见，每个文件引入css如果都需要指定<code>style-loader!css-loader!</code>，文件一多，会变得非常麻烦，此时也可以通过命令行指令，更加快捷的针对文件进行打包，例如上例同样可以这样处理，如图：</p>
<pre><code class="js">require(&quot;./world.js&quot;);
require(&quot;./style.css&quot;);
function hello (){
    alert(&quot;hello world&quot;)
}
hello();</code></pre>
<p>运行<code>webpack hello.js hello.bundle.js --module-bind &#39;css=style-loader!css-loader&#39;</code>，也可以正常打包，达到相同的效果；</p>
]]></content>
  </entry>
  <entry>
    <title>git常见操作</title>
    <url>/article/2020/01/28/git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<h2 id="添加修改到暂存区跟提交本地仓库"><a href="#添加修改到暂存区跟提交本地仓库" class="headerlink" title="添加修改到暂存区跟提交本地仓库"></a>添加修改到暂存区跟提交本地仓库</h2><pre><code class="js">//提交修改到暂存区
git add .
//提交到本地仓库
git commit -m &quot;annotation&quot;</code></pre>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre><code class="js">//查看版本
git log
//查看全部历史版本
git reflog
//回退到指定版本
git reset --hard versionId
git reset --hard head^ || head^^</code></pre>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><pre><code class="js">//当文件未add或者commit时，撤销修改到修改前或者add状态
git checkout --file
git checkout .
//当文件已经add未commit时，撤销到最近一次commit状态
git reset --hard head^
//当已经commit且未推送远程仓库时，回退到上一版本
git reset --hard head^</code></pre>
<h2 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h2><pre><code class="js">//查看分支：
git branch
//创建分支：
git branch &lt;name&gt;
//切换分支：
git checkout &lt;name&gt;
//创建+切换分支：
git checkout -b &lt;name&gt;
//合并某分支到当前分支：
git merge &lt;name&gt;
//删除分支：
git branch -d &lt;name&gt;</code></pre>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><ul>
<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li>
<li>手动解决冲突，Git用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记出不同分支的内容</li>
<li>再提交，<code>git add</code>，<code>git commit</code></li>
<li>查看分支合并情况，<code>git log --graph --pretty=oneline --abbrev-commit</code></li>
</ul>
<h2 id="常见快捷键"><a href="#常见快捷键" class="headerlink" title="常见快捷键"></a>常见快捷键</h2><ul>
<li>退出 git log ; 按q键</li>
<li>git commit –amend 命令（修改最近一次提交的注释信息），会进入到vim 编辑器</li>
<li>按下字母键 c（此时进入编辑状态），可以开始修改注释信息了</li>
<li>按下Esc (退出编辑状态)； 接着连按两次大写字母Z，退出VIM编辑器</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MySql的安装</title>
    <url>/article/2020/01/28/MySql%E7%9A%84%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<p>#####MySql解压版的安装配置<br>1、配置环境变量；<br>2、配置my.ini文件；<br>3、切换到自己MySQL根目录的bin目录下并执行mysqld –remove；<br>4、继续运行mysqld  –initialize-insecure，生成data文件（删除旧的data文件）；<br>5、运行mysqld –install，安装服务;<br>6、运行net start mysql启动服务；<br>7、运行mysql -u root -p,连续回车进入，无需输入密码；<br>8、接着运行set password for root@localhost = password(‘123’)，设置密码（若退出，则可能已经生成随机密码，此时重复步骤3）；<br>9、grant all privileges on <em>.</em> to ‘root’@’%’ identified by ‘123456’ with grant option;  flush privileges;（</p>
<ol>
<li><em>.</em> 第一个*是指数据库</li>
<li></li>
<li>*代表所有数据库</li>
<li></li>
<li>第二个*指数据库对象</li>
<li></li>
<li>*代表数据库中所有对象</li>
<li></li>
<li>‘root’@’%’ root是制定要授权的数据库用户</li>
<li></li>
<li>%代表允许登录的IP</li>
<li></li>
<li>123456是你的数据库密码）；</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MongoDB安装与启动</title>
    <url>/article/2020/01/28/MongoDB%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8.html</url>
    <content><![CDATA[<p>##MongoDB的安装与启动<br>本次安装环境是在win10下，一开始下载的是msi版本，结果遇到一个不可描述的BUG，怎么也无法安装window服务，索性下载了一个解压版的，马上就安装成功了。下面记录一下安装过程：</p>
<p>1.下载解压包安装包，解压到任意目录下，我下载的版本是<code>mongodb-win32-x86_64-2008plus-ssl-3.4.15</code>；<br>2.配置环境变量，新建变量<code>MongoDB_HOME</code>(随意)，路径为解压所在路径，即<code>C:\home\software\install\mongodb-win32-x86_64-2008plus-ssl-3.4.15</code>;配置<code>path</code>变量，值为<code>%MongoDB_HOOME%\bin</code>;<br>3.在解压目录下新建<code>data</code>与<code>log</code>文件夹，分别存放数据库数据与日志文件；<br>4.使用管理员身份打开命令行，运行<code>mongod.exe --dbpath C:\home\software\install\mongodb-win32-x86_64-2008plus-ssl-3.4.15\data --logpath C:\home\software\install\mongodb-win32-x86_64-2008plus-ssl-3.4.15\log\mongod.log --install --serviceName &quot;MongoDB&quot;</code>;</p>
<ul>
<li><code>--dbpath</code>用来指定数据库文件路径；</li>
<li><code>--logpath</code>用来指定日记文件路径；</li>
<li><code>--install --serviceName &quot;MongoDB&quot;</code>用来安装window服务；</li>
</ul>
<p>5.使用命令行运行<code>net start MongoDB</code>，即可成功启动服务；<br>6.进入解压目录，进入<code>bin</code>目录下，可以看到相关命令，<code>mongod.exe</code>是服务，<code>mongo.exe</code>是链接，<code>mongos.exe</code>是路由;双击<code>mongod.exe</code>，即可连接到数据库，到浏览器下打开<code>http://127.0.0.1:27017</code>，看到<code>It looks like you are trying to access MongoDB over HTTP on the native driver port.</code>，即代表数据库连接成功；</p>
]]></content>
  </entry>
  <entry>
    <title>Generator-与-async-函数的藕断丝连</title>
    <url>/article/2020/01/28/Generator-%E4%B8%8E-async-%E5%87%BD%E6%95%B0%E7%9A%84%E8%97%95%E6%96%AD%E4%B8%9D%E8%BF%9E.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上上篇博文中，我们描述了异步回调的三种形式，相信小伙伴们对此都有了一个全新的认识。不过，一定也有小伙伴心存疑惑，比如第三种的async/await，大多数人可能都是知其然而不知其所以然。今天，就让我们深入探究一下其庐山真面目吧。</p>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>我们来看一个题目： 给document添加一个点击事件，每点击一次则打印一次，依次打印 “吃饭”  - -&gt; “睡觉”  - -&gt; “打豆豆”。</p>
<p>粗心的小伙伴一看就火了，这不是异步回调那一篇的栗子吗？？？</p>
<p>仔细看看啦，上一篇栗子打印的时间间隔是提前确定的，这一次时间间隔则是全由点击事件来控制，至于啥时候点击，则无法确定。</p>
<h2 id="传统实现"><a href="#传统实现" class="headerlink" title="传统实现"></a>传统实现</h2><pre><code class="js">clickEvent(document,&quot;click&quot;,eat); // 吃饭 睡觉 打豆豆
function eat(){
    console.log(&quot;吃饭&quot;);
    clickEvent(document,&quot;click&quot;,sleep,eat);
}
function sleep(){
    console.log(&quot;睡觉&quot;);
    clickEvent(document,&quot;click&quot;,dadoudou,sleep);
}
function dadoudou(){
    console.log(&quot;打豆豆&quot;);
    clickEvent(document,&quot;click&quot;,null,dadoudou);
}
function clickEvent(target,event,fn,rmFn){
    target &amp;&amp; target.addEventListener(event,fn);
    target &amp;&amp; target.removeEventListener(event,rmFn);
}</code></pre>
<p>看着这段代码，你有什么感觉呢？如果是你自己来写，又是什么感觉呢？</p>
<p>先说看，为了摸清打印的顺序，要从clickEvent - -&gt; eat - -&gt; sleep - -&gt; dadoudou四个函数不断跳跃阅读。所幸目前每个业务函数中只有一个打印的操作，想象一下，实际开发中，当业务函数长达几十行甚至更多的时候，要从业务函数中找到clickEvent函数也是一件很辛苦的工作。</p>
<p>再说写，不知道你们是什么样的一个过程，反正我确定了代码思路之后，整个代码顺序调整了不止一次，clickEvent也是后面才抽离出来的，整个过程非常的别扭。</p>
<p>这是为什么呢？很简单，因为代码不符合我们常规的思考过程。</p>
<p>人是一种懒惰的动物，越是简单直接，越会觉得轻松愉快。</p>
<p>那有没有所谓的简单直接的方法呢？</p>
<h2 id="划时代的巨变"><a href="#划时代的巨变" class="headerlink" title="划时代的巨变"></a>划时代的巨变</h2><p>小伙伴们无语了，“博主，你又标题党了！！”</p>
<p>我承认有的时候是有标题党的嫌疑（只是嫌疑！），不过，这一次的标题，再怎么夸张都不为过！！！</p>
<pre><code class="js">//生成器函数
function* clickEvent(){
    yield console.log(&quot;吃饭&quot;);
    yield console.log(&quot;睡觉&quot;);
    yield console.log(&quot;打豆豆&quot;);
}
//创建一个遍历器
var iterator = clickEvent();
document.onclick = function(){
    //调用遍历器
    iterator.next(); // 吃饭 睡觉 打豆豆
}</code></pre>
<p>怎么样？怎么样？怎么样？！！</p>
<p>这可以称得上划时代的巨变了么？可以么？如果你真正比对比上例代码，相信你心里已经有答案了。</p>
<p>平复一下心情，我们来看一下这代码：</p>
<ul>
<li>生成器函数与普通函数的两个不同，一是function后的 <code>*</code> 标识符，二是只能存在与生成器函数里面的 <code>yield</code> 关键字。</li>
<li>通过调用生成器函数来创建一个遍历器，遍历器则是通过自带的 <code>next</code> 方法，逐步执行。</li>
</ul>
<p>再对比一下上面两段代码，通过生成器函数书写的代码，显然不需要进行各种跳跃类高难度动作才能摸清执行顺序，整个代码显得更加简单直接，执行思路也一目了然。</p>
<h2 id="Generator（生成器）与-Iterator（遍历器）的关系"><a href="#Generator（生成器）与-Iterator（遍历器）的关系" class="headerlink" title="Generator（生成器）与 Iterator（遍历器）的关系"></a>Generator（生成器）与 Iterator（遍历器）的关系</h2><p>第一次接触生成器的小伙伴，最不解的一点就是：调用生成器函数后，为什么可以调用 <code>next</code> 方法？</p>
<p>这就要说到ES6新出的 <code>Iterator</code> 接口了。在解释 Iterator 之前，我们先思考一个问题：如何遍历 Array , Set , Map 等数据？遍历的内在机制又是什么呢？</p>
<h5 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h5><p>没错，就是这个全新的ES6遍历命令：</p>
<pre><code class="js">var arr = [&quot;吃饭&quot;,&quot;睡觉&quot;,&quot;打豆豆&quot;];
for(let val of arr){
    console.log(val); // 吃饭 睡觉 打豆豆
}
var set = new Set(arr);
for(let val of set){
    console.log(val); // 吃饭 睡觉 打豆豆
}</code></pre>
<p>有的小伙伴就疑问了，<code>for...of</code> 这么厉害，之前的遍历方法还有用吗？？</p>
<pre><code class="js">var obj = {
    name: &quot;张三&quot;,
    age: 20
}
for(let key in obj){
    console.log(key); // name age
}
for(let key of obj){
    console.log(key); // Uncaught TypeError: obj is not iterable
}</code></pre>
<p>勤快测试的小伙伴就发现了，当用 for…of 遍历对象的时候，竟然报错了， <code>obj is not iterable</code> 。</p>
<p>啥是 iterable ？</p>
<h5 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h5><p>我们先看一段代码：</p>
<pre><code class="js">typeof (new Array())[Symbol.iterator]; //&quot;function&quot;
typeof (new Set())[Symbol.iterator]; //&quot;function&quot;
typeof (new Map())[Symbol.iterator]; //&quot;function&quot;
// 没有该属性
typeof (new Object())[Symbol.iterator]; // &quot;undefined&quot;</code></pre>
<p>讲这里，小伙伴们应该有些眉目了，for…of  遍历的机制就是隐藏在这里。</p>
<p><code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</p>
<pre><code class="js">var arr = [&quot;吃饭&quot;,&quot;睡觉&quot;,&quot;打豆豆&quot;];
var iterator = arr[Symbol.iterator](); // 执行遍历器生成函数，返回一个遍历器；
iterator.next(); // {value: &quot;吃饭&quot;, done: false}
iterator.next(); // {value: &quot;睡觉&quot;, done: false}
iterator.next(); // {value: &quot;打豆豆&quot;, done: false}
iterator.next(); // {value: undefined, done: true}</code></pre>
<p>目前原生具备 Iterator 接口的数据结构如下：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>有些小伙伴这时就迷茫了，原生具备的？那我还怎么玩呀！！</p>
<p>额，这就把人家遍历器看的有点小肚鸡肠啦，其实人家还是给了我们发挥空间的:</p>
<pre><code class="js">var obj = {
    [Symbol.iterator](){
        return {
            begin: 1,
            next(){
                if(this.begin &lt; 4){
                    return {value: this.begin ++, done: false}
                }else{
                    return { value: undefined, done: true}
                }
            }
        }
    }
}
for (let val of obj){
    console.log(val); // 1  2  3
}</code></pre>
<p>这样的话，我们就可以自定义一个遍历器了。</p>
<h5 id="水落石出"><a href="#水落石出" class="headerlink" title="水落石出"></a>水落石出</h5><p>绕了这么一大圈，相信各位小伙伴此时都心中有数啦，让我回头再看看一开始那个栗子：</p>
<pre><code class="js">//生成器函数
function* clickEvent(){
    yield console.log(&quot;吃饭&quot;);
    yield console.log(&quot;睡觉&quot;);
    yield console.log(&quot;打豆豆&quot;);
}
//创建一个遍历器
var iterator = clickEvent();
// 证明了这是一个遍历器
typeof iterator[Symbol.iterator]; //&quot;function&quot;</code></pre>
<p>没有错，就是这么简单，所谓的Generator（生成器），其实就生成 Iterator (遍历器)的一种特殊函数！！</p>
<h2 id="Generator-函数与-async-函数"><a href="#Generator-函数与-async-函数" class="headerlink" title="Generator 函数与 async 函数"></a>Generator 函数与 async 函数</h2><p>讲了这么多，小伙伴们已经急，“天天废话一大摞，你说你，讲了大半天，跟标题有啥子关系哦！”</p>
<p>额，其实我也不想啊！写文章很累的好吧！！！不过考虑到一些基础还不太扎实的小伙伴，循序渐进还是很有必要的，而且这样把整个个知识体系串联了起来，显得更为系统了不是？</p>
<p>我们回到正题。</p>
<p><code>async</code> 函数我们在异步回调的前世今生篇已经有所涉及，但是好事多磨，我们再重写一遍今天这个栗子：</p>
<pre><code class="js">//生成器函数
async function clickEvent(){
    await console.log(&quot;吃饭&quot;);
    await console.log(&quot;睡觉&quot;);
    await console.log(&quot;打豆豆&quot;);
}
//麻烦了,一骨碌全打印出来了
clickEvent(); // 吃饭 睡觉 打豆豆
// 说明 async 函数并不是遍历器
typeof clickEvent[Symbol.iterator]; // &quot;undefined&quot;</code></pre>
<p>小伙伴们顿时兴奋了，“露陷了吧！哈哈哈哈哈！”</p>
<p>额，。。。还好我早已对这种充满幸灾乐祸的人生见惯不惯了。</p>
<p>不过，我有说过 <code>async</code> 能实现吗？有说过吗？？有证据吗？？</p>
<p>“既然都不能实现，你说这些有啥子意思咧”，小伙伴们一脸不屑。</p>
<p>“我想说”，我一脸严肃，“虽然 async 函数不能实现，但是它却是 Generator 函数的语法糖！”</p>
]]></content>
  </entry>
</search>
