---
title: 深入理解闭包
date: 2020-01-28 14:32:04
categories:
tags:
---
## 前言 ##
今天我们来说一个人见人爱，花见花开的的主题 - - 闭包。有的小伙伴就说了，扯犊子，哪里人见人爱，花见花开了？我是见着闭包就烦！好吧，如果是这样，那这句话不是对你说的，我是对神秘莫测的大佬（装逼犯）说的。

好吧，废话有点多，不过有点是真的，如果你掌握了闭包，它确实是个好东西，人见人爱，花见花开是一点也不夸张。



进入正题。

## 闭包初体验 ##
看到深入闭包这个吓唬人的标题还敢进来的，相信各位之前都有一定的接触了，我们就暴力一些，直入正题吧：
```js
function foo() {
	var n = 0;
    function bar() {
    	return ++n;
    }
    return bar;
}
var a = foo();
a(); // 1
a(); // 2
```
好了，相信各位小伙伴已经看过无数个类似的栗子了，甚至有了平平无奇大闭包的印象。

这里我想提问一个问题，为什么 `a` 第2次调用的时候不是1而是再之前的基础上递增？

 - foo 函数调用后返回 bar 函数给 a ,因为 bar 是一个函数对象，所以 a 其实持有的只是 bar 函数的指引。
 - 根据词法作用域，函数的作用域在声明时已经确定了下来，而与函数在哪里调用无关，所以，bar 函数的外层作用域正是 foo 函数的内部作用域。
 - 因为 a 持有 bar 函数的指引，foo 函数调用后，其内部作用域并没有销毁，所以重复调用 a 也就调用 bar 函数时， n 得以不断递增。

相信很多小伙伴对这段描述已经是耳熟能详了，我们就到此为止，接着看看改造后的栗子。

## 孙大圣的汗毛 ##
小伙伴们无语了，“博主！”，“讨论学术能不能严肃点！！”

好吧，虽然我很多时候起标题有些不靠谱，但是，可以肯定的是，这一次的标题是再恰如其分不过了！

怎么说呢？请看：

```js
function foo() {
	var n = 0;
    function bar() {
    	return ++n;
    }
    return bar;
}
var a = foo();
var b = foo();
a(); // 1
a(); // 2
b(); // 1
b(); // 2
```
小伙伴们无语了，这有啥奇怪呀！

好吧，虽然跟上例只有一点点变化，但是其中隐藏着一个极其重要的知识点。

我先问一个问题，为什么 b 调用后， n 不是在之前的基础上递增，而是从头开始？

照例，代码说话：

```js
function foo() {
	var n = [1,2];
    function bar() {
    	n.push(3);
    	return n;
    }
    return bar;
}
var a = foo();
var b = foo();
var a1 = a();
var a2 = a();
var b1 = b();
var b2 = b();
console.log(a1);// [1,2,3,3]
console.log(b1);// [1,2,3,3]
//重点关注！！
console.log(a1 === a2); //true
console.log(b1 === b2); //true
console.log(a1 === b1); //false
```
啥情况？a 跟 b 不都是指向 bar 函数么？怎么返回的 n 不相等呢？

原因简要说就一句话：生成闭包的函数（foo）每调用一次，就创造一个**独立的作用域链**，也可以看做是产生一个上下文环境，**相互独立，互不影响**！

好了，这个时候可以回头看看本小节的标题了。

见没见过孙大圣的汗毛？换句话说孙大圣就是 foo 函数， a 跟 b 就是孙大圣的汗毛了，它们长得跟孙大圣极其类似（要素相同的作用域链），但是它们可以自由活动，互不影响（作用域链相互独立）。


## 铁证如山 ##
小伙伴们就郁闷了，这就能证明了么？

按照我的理解，确实是可以证明了，不过为了让大伙加深认识，我们来看看一个栗子，也是促使我写下本文的一个极好的栗子：

```js
var add = null;
function foo() {
	var n = 0;
    add = function(){
        n++;
        console.log(n);
    }
    function bar(){
        n++;
        console.log(n);
    }
    return bar;
}
var a = foo();
var b = foo();
a();//1
a();//2
add();//1
b();//2
b();//3
```
啥情况？为什么 add 横插一脚调用之后，b 竟然不再从 1 开始了！！！

其实深入理解上一节的小伙伴，加上一点细心，就会发现其中的蹊跷。

上一节说了，a 跟 b 都是 foo 函数产生的一根汗毛，那是怎么产生的呢？

额，被我吓唬一下就一哆嗦的小伙伴，请听我细细道来：

foo 是不是函数？函数是怎么调用的？

当然是一泻千里，一行到底啊！！！函数还能怎么调用！！！

不过这有一个特殊的细节，就是 add 函数。

##### 揭秘时刻

add 函数是表达式的，产生 a 的时候，全局变量 add 被赋值；接着产生 b 的时候，add 变量就被重写了！！！

什么意思呢？

换句话说，在调用 add 的时候，add 是指向的是 b 函数所在的作用域链。

要证明？

```js
var add = null;
function foo() {
    var n = 0;
    add = function(){
        n++;
        console.log(n);
    }
    function bar(){
        n++;
        console.log(n);
    }
    return {bar:bar,add:add};
}
var a = foo();
var b = foo();
console.log(a.add === add); // false
console.log(b.add === add); // true
```

同样，我们也可以把 add 函数加到 a 上面啦，交换一下 a , b 产生的顺序即可：

```js
var add = null;
function foo() {
	var n = 0;
    add = function(){
        n++;
        console.log(n);
    }
    function bar(){
        n++;
        console.log(n);
    }
    return bar;
}
//换一下顺序
var b = foo();
var a = foo();
a();//1
a();//2
add();//3
b();//1
b();//2
```

## 总结 ##
好了，闭包的博文可谓是浩如烟海了，我这篇也是站在巨人的肩膀上胡扯一番，如有错误，还请留言交流。

没有错误也请留下您的脚印，交个朋友嘛，行不行嘛？











