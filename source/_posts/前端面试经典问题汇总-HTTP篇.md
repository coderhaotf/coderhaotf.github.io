---
title: 前端面试经典问题汇总-HTTP篇
date: 2020-01-28 14:31:47
categories:
tags:
---
## GET与POST请求的区别
GET和POST是什么？HTTP协议中的两种发送请求的方法。

HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。

HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP连接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。

为什么GET与POST请求还有这么多差异呢？根源在于浏览器与服务器的限制。

##### **缓存上的区别**

 - get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。
 - post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。


##### **安全上的区别**

 - 查询字符串（名称/值对）是在 GET 请求的 URL 中发送的，有安全问题。
 - 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的，因此安全性较get高


**误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。**

实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:

 - HTTP 协议 未规定 GET 和POST的长度限制
 - GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度
 - 不同的浏览器和WEB服务器，限制的最大长度不一样
 - 要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte


##### **总结**

有关 GET 请求的其他一些注释：

 - GET 请求可被缓存
 - GET 请求保留在浏览器历史记录中
 - GET 请求可被收藏为书签
 - GET 请求不应在处理敏感数据时使用
 - GET 请求有长度限制
 - GET 请求只应当用于取回数据

有关 POST 请求的其他一些注释：

 - POST 请求不会被缓存
 - POST 请求不会保留在浏览器历史记录中
 - POST 不能被收藏为书签
 - POST 请求对数据长度没有要求



## [浏览器缓存](http://www.cnblogs.com/lyzg/p/5125934.html)
强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；

区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。

##### 强缓存

###### Expires

Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。

 - 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header；
 - 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；
 - 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。
 - 如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。

###### Cache-Control

在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：

 - 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header；
 - 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；
 - 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。
 - 如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。

Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。

这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。

##### 强缓存的管理
通常有2种方式来设置是否启用强缓存：

 - 通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；
 - 通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。


##### 协商缓存
Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。

###### Last-Modified，If-Modified-Since

 - 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间；
 - 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值；
 - 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。
 - 浏览器收到304的响应后，就会从缓存中加载资源。
 - 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。


###### ETag、If-None-Match

 - 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系；
 - 浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值；
 - 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化；
 - 浏览器收到304的响应后，就会从缓存中加载资源。


##### 协商缓存的管理

【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。

分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；

分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；

##### 浏览器行为对缓存的影响

 - 当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
 - 当f5刷新网页时，跳过强缓存，但是会检查协商缓存；



## OPTIONS请求方法
非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

 - 获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。
 - 用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。



## 前端工程与性能优化

| 优化方向 |	优化手段 |
| --------   | -----  |
| 请求数量 |	合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 |
|请求带宽 	| 开启GZip，精简JavaScript，移除重复脚本，图像优化|
|缓存利用 	| 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存|
|页面结构 	|将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出|
|代码校验 	|避免CSS表达式，避免重定向|


## ES6模块与CommonJS模块的差异

 - CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用
 - CommonJS 模块是运行时加载，ES6模块是编译时输出接口
 - ES6输入的模块变量，只是一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错



## http 与 https

##### http的不足：

 - 通信使用明文，可能会被窃听
 - 不验证通信方的身份，可能遭遇伪装
 - 无法证明报文的完整性，可能遭遇篡改

##### 何为https?
**http + 加密 + 验证 + 完整性保护 = https**

##### https的原理
https并非应用层上一种新的协议，而是http通信接口部分用SSL（Secure Socket Layer，安全套接层）和TLS（Transport Layer Security，传输安全协议）协议代替。

通常情况下，http与TCP直接通信，当使用SSL时，就演变层先跟SSL通信，再由SSL与TCP通信。

所谓的https，也就是身披SSL协议外壳的http。

##### SSL如何加密？
SSL使用的是一种公开密钥加密（Public-key cryptography）的加密方式。

加密方法中，加密算法是公开的，密钥是保密的，加密跟解密都需要用到密钥。

###### 共享密钥加密（Common key cryto system）
加密与解密使用同一个密钥，也被称为对称密钥加密。

不足：密钥能够安全发送，信息也能安全发送。

###### 公开密钥加密
公开密钥加密使用一对非对称的密钥，一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。

发送密文的一方使用公开密钥加密，对方收到信息之后，再使用私有密钥解密。

##### https使用混合加密机制
公开密钥加密与共享密钥加密相比，其处理速度要慢，所以需要利用其各自的优势。

在交换密钥阶段使用公开密钥加密的方式，之后建立通信交换报文阶段则使用共享密钥加密的方式。

##### 公开密钥的可靠性证明
解决方法是，使用数据证书认证机构（CA,Certificate Authority）和其相关机构颁布的公开密钥证书。

 - 提出公开密钥申请
 - 数字证书认证机构对公开密钥做数字签名，颁发公钥证书
 - 服务器发送公钥证书给客户端，进行公开密钥加密通信
 - 客户端使用内置的数据证书认证机构的公开密钥，对公钥证书的数字签名进行认证。

数据证书认证机构的公开密钥必须安全的转交给客户端，使用通信方式进行安全转交是一件非常困难的事情，所以，浏览器发布时，一般会事先植入认证机构的公开密钥。


## TCP三次握手
TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。

 - 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN-SEND状态，等待服务器B确认。
 - 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN-RECV状态。
 - 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

完成三次握手，客户端与服务器开始传送数据。

LISTEN - 侦听来自远方TCP端口的连接请求；
SYN-SENT -在发送连接请求后等待匹配的连接请求；
SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；
ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；


## TCP四次挥手
TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

 - 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
 - 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
 - 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
 - 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。


## TCP和UDP的区别
“信道复用技术”实现了，在同一条线路上，单位时间内可供X台计算机同时通信。

一个TCP协议连接其实就是在物理线路上创建的一条“虚拟信道”。这条“虚拟信道”建立后，在TCP协议发出FIN包之前（两个终端都会向对方发送一个FIN包），是不会释放的。正因为这一点，TCP协议被称为面向连接的协议！

UDP协议，一样会在物理线路上创建一条“虚拟信道”，否则UDP协议无法传输数据！但是，当UDP协议传完数据后，这条“虚拟信道”就被立即注销了！因此，称UDP是不面向连接的协议！

 - TCP协议提供了可靠的数据传输,但是其拥塞控制、数据校验、重传机制的网络开销很大,不适合实时通信。
 - UDP 协议是无连接的数据传输协议并且无重传机制,会发生丢包、收到重复包、乱序等情况。而对于数据精确性要求不高的状态数据以及视频数据,丢包的影响不大。



## webSocket
WebSocket protocol 是HTML5一种新的协议。它是实现了浏览器与服务器全双工通信(full-duplex)。HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽并达到实时通讯。

在WebSocket出现之前，一般通过两种方式来实现Web实时用：轮询机制和流技术；其中轮询有不同的轮询，还有一种叫Comet的长轮询。

 - 轮询：这是最早的一种实现实时 Web 应用的方案。客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的同步。这种同步方案的缺点是，当客户端以固定频率向服务器发起请求的时候，服务器端的数据可能并没有更新，这样会带来很多**无谓的网络传输**，所以这是一种非常低效的实时方案。

 - 长轮询：是对定时轮询的改进和提高，目地是为了降低无效的网络传输。当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互。当然，如果服务端的数据变更非常频繁的话，这种机制和定时轮询比较起来没有本质上的性能的提高。

 - 流：常就是在客户端的页面使用一个隐藏的窗口向服务端发出一个**长连接的请求**。服务器端接到这个请求后作出回应并不断更新连接状态以保证客户端和服务 器端的连接不过期。通过这种机制可以将服务器端的信息源源不断地推向客户端。这种机制在用户体验上有一点问题，需要针对不同的浏览器设计不同的方案来改进 用户体验，同时这种机制在并发比较大的情况下，对服务器端的资源是一个极大的考验。

WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。
